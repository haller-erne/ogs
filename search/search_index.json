{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OGS - Operator guidance system","text":""},{"location":"#scope","title":"Scope","text":"<p>This documentation provides low-level infomation about the OGS software.  The main purpose is to document the API interfaces (mostly LUA scripting), the available (tool)drivers and show how everything fits together.  This allows advanced users and implementors to unlock the full potential  of OGS by modifying and extending the software.</p> <p>NOTE: This documentation is valid for OGS V3. As V3 is not yet released, some of the information might still change before the final release.</p>"},{"location":"#overview","title":"Overview","text":"<p>The documentation currently has the following information:</p> <ul> <li>Tool driver and tool configuration information (see Tool configuration)</li> <li>LUA scripting (see LUA scripting)</li> <li>LUA helper libraries (see LUA libraries)</li> </ul>"},{"location":"libs/_template_/","title":"Ability","text":"<p>Abilities are CoreObjects that can be added to Players and guide the Player's animation in sync with the Ability's state machine. Spawn an Ability with <code>World.SpawnAsset()</code> or add an Ability as a child of an Equipment/Weapon to have it be assigned to the Player automatically when that item is equipped.</p> <p>Abilities can be activated by association with an Action Binding. Their internal state machine flows through the phases: Ready, Cast, Execute, Recovery, and Cooldown. An Ability begins in the Ready state and transitions to Cast when its Binding (for example Left mouse click) is activated by the owning player. It then automatically flows from Cast to Execute, then Recovery and finally Cooldown. At each of these state transitions it fires a corresponding event.</p> <p>Only one ability can be active at a time. By default, activating an ability will interrupt the currently active ability. The <code>canBePrevented</code> and <code>preventsOtherAbilities</code> properties can be used to customize interruption rules for competing abilities.</p> <p>If an ability is interrupted during the Cast phase, it will immediately reset to the Ready state. If an ability is interrupted during the Execute or Recovery phase, the ability will immediately transition to the Cooldown phase.</p>","tags":["API"]},{"location":"libs/_template_/#properties","title":"Properties","text":"Property Name Return Type Description Tags <code>isEnabled</code> <code>boolean</code> Turns an Ability on/off. It stays on the Player but is interrupted if <code>isEnabled</code> is set to <code>false</code> during an active Ability. True by default. Read-Write <code>canActivateWhileDead</code> <code>boolean</code> Indicates if the Ability can be used while the owning Player is dead. False by default. Read-Only <code>name</code> <code>string</code> The name of the Ability. Read-Only <code>actionBinding</code> <code>string</code> This property is deprecated. Please use <code>actionName</code> instead, but note that <code>actionBinding</code> and <code>actionName</code> use different values.  Which action binding will cause the Ability to activate. Possible values of the bindings are listed on the Ability binding page. Read-Only, Deprecated <code>actionName</code> <code>string</code> Which binding set action name will cause the Ability to activate. See Binding Sets reference. Read-Only <code>owner</code> <code>Player</code> Assigning an owner applies the Ability to that Player. Read-Write <code>castPhaseSettings</code> <code>AbilityPhaseSettings</code> Config data for the Cast phase (see below). Read-Only <code>executePhaseSettings</code> <code>AbilityPhaseSettings</code> Config data for the Execute phase. Read-Only <code>recoveryPhaseSettings</code> <code>AbilityPhaseSettings</code> Config data for the Recovery phase. Read-Only <code>cooldownPhaseSettings</code> <code>AbilityPhaseSettings</code> Config data for the Cooldown phase. Read-Only <code>animation</code> <code>string</code> Name of the animation the Player will play when the Ability is activated. Possible values: See Ability Animation for strings and other info. Read-Only <code>canBePrevented</code> <code>boolean</code> Used in conjunction with the phase property <code>preventsOtherAbilities</code> so multiple abilities on the same Player can block each other during specific phases. True by default. Read-Only","tags":["API"]},{"location":"libs/_template_/#functions","title":"Functions","text":"Function Name Return Type Description Tags <code>Activate()</code> <code>None</code> Activates an Ability as if the button had been pressed. None <code>Interrupt()</code> <code>None</code> Changes an Ability from Cast phase to Ready phase. If the Ability is in either Execute or Recovery phases it instead goes to Cooldown phase. None <code>AdvancePhase()</code> <code>None</code> Advances a currently active Ability from its current phase to the next phase. For example, an ability in the Cast phase will begin the Execute phase, an ability on cooldown will become ready, etc. None <code>GetCurrentPhase()</code> <code>AbilityPhase</code> The current AbilityPhase for this Ability. These are returned as one of: AbilityPhase.READY, AbilityPhase.CAST, AbilityPhase.EXECUTE, AbilityPhase.RECOVERY and AbilityPhase.COOLDOWN. None <code>GetCurrentPhaseSettings()</code> <code>AbilityPhaseSettings</code> Returns the settings for the current phase of this Ability. Returns <code>nil</code> if the current phase is <code>AbilityPhase.READY</code>. None <code>GetPhaseTimeRemaining()</code> <code>number</code> Seconds left in the current phase. None <code>GetTargetData()</code> <code>AbilityTarget</code> Returns information about what the Player has targeted this phase. None <code>SetTargetData(AbilityTarget)</code> <code>None</code> Updates information about what the Player has targeted this phase. This can affect the execution of the Ability. None","tags":["API"]},{"location":"libs/_template_/#events","title":"Events","text":"Event Name Return Type Description Tags <code>readyEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability becomes ready. In this phase it is possible to activate it again. None <code>castEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability enters the Cast phase. None <code>executeEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability enters Execute phase. None <code>recoveryEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability enters Recovery. None <code>cooldownEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability enters Cooldown. None <code>interruptedEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability is interrupted. None <code>tickEvent</code> <code>Event</code>&lt;<code>Ability</code> ability, <code>number</code> deltaTime&gt; Fired every tick while the Ability is active (isEnabled = true and phase is not ready). None","tags":["API"]},{"location":"libs/_template_/#examples","title":"Examples","text":"<p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#castevent","title":"<code>castEvent</code>","text":"<p>The Cast phase begins as soon as an ability is activated. By checking if the player casting the ability <code>isGrounded</code> we can create an effect that propels you upwards, but it doesn't work if you are already jumping or flying. We detect this is the <code>castEvent</code>, which is early enough for an <code>Interrupt()</code> to reset the ability.</p> <pre><code>--Server script\nlocal ability = script.parent\nfunction OnCast(ability)\nif ability.owner.isGrounded then\nability.owner:SetVelocity(Vector3.UP * 2000)\nelse\nability:Interrupt()\nend\nend\nability.castEvent:Connect(OnCast)\n</code></pre> <p>See also: CoreObject.parent | Ability.owner | Player.isGrounded | Vector3.UP | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#cooldownevent","title":"<code>cooldownEvent</code>","text":"<p>In this example, a fighting game has an \"invincible\" mechanic where player attacks are not interrupted while they have this effect. Some powerful attacks make the player invincible during the entire active cycle of the ability. The effect is gained at the beginning of the cast phase and is removed at the end of the recovery phase, before the cooldown begins. The resource system is used in keeping track of the invincibility effect.</p> <pre><code>--Server script\nlocal ability = script.parent\nfunction OnCast(ability)\nability.owner:AddResource(\"invincible\", 1)\nend\nfunction OnCooldown(ability)\nability.owner:RemoveResource(\"invincible\", 1)\nend\nability.castEvent:Connect(OnCast)\nability.cooldownEvent:Connect(OnCooldown)\n</code></pre> <p>See also: CoreObject.parent | Player.owner | Ability.castEvent | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#executeevent","title":"<code>executeEvent</code>","text":"<p>Weapons implement lots of built-in gameplay that doesn't require any scripting, such as attack and reload abilities. However, they can be augmented with additional mechanics. In this example, a special sound effect is played when a weapon shoots while low on ammunition. The script expects to be a child of a weapon's \"Shoot\" ability.</p> <pre><code>--Server script\nlocal ability = script.parent\nlocal weapon = script:FindAncestorByType('Weapon')\nlocal lowAmmoSound = script:GetCustomProperty(\"LowAmmoSound\")\nlocal LOW_AMMO_PERCENTAGE = 0.2\nfunction OnExecute(ability)\nif weapon.currentAmmo / weapon.maxAmmo &lt;= LOW_AMMO_PERCENTAGE then\nWorld.SpawnAsset(lowAmmoSound, {position = weapon:GetWorldPosition()})\nend\nend\nability.executeEvent:Connect(OnExecute)\n</code></pre> <p>See also: CoreObject.parent | Weapon.currentAmmo | World.SpawnAsset | Ability.executeEvent | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#interruptedevent","title":"<code>interruptedEvent</code>","text":"<p>The <code>interruptedEvent</code> fires when an ability is going through it's activation process and <code>Interrupt()</code> is called on it, or if it becomes disabled. In this example, interruption is a key part of the game design, so a visual effect is spawned at the player's position to help communicate the interaction between players.</p> <pre><code>--Server script\nlocal ability = script.parent\nlocal interruptedVfx = script:GetCustomProperty(\"InterruptedVfx\")\nfunction OnInterrupted(ability)\nif Object.IsValid(ability.owner) then\nWorld.SpawnAsset(interruptedVfx, {position = ability.owner:GetWorldPosition()})\nend\nend\nability.interruptedEvent:Connect(OnInterrupted)\n</code></pre> <p>See also: CoreObject.parent | Object.IsValid | Ability.owner | World.SpawnAsset | Player.GetWorldPosition | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#readyevent","title":"<code>readyEvent</code>","text":"<p>The Ready phase begins when an ability comes off cooldown and is \"ready\" to be used again. In this example, we create an invisibility effect that takes advantage of the <code>readyEvent</code>, leveraging the cooldown duration of the ability as a clock to determine when to make the player visible again.</p> <pre><code>-- Server script\nlocal ability = script.parent\nfunction OnExecute(ability)\n-- Hide the player\nability.owner:SetVisibility(false)\nend\nfunction OnReady(ability)\n-- Show the player\nability.owner:SetVisibility(true)\nend\nability.readyEvent:Connect(OnReady)\nability.executeEvent:Connect(OnExecute)\n</code></pre> <p>See also: CoreObject.parent | Ability.owner | Player.SetVisibility | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#recoveryevent","title":"<code>recoveryEvent</code>","text":"<p>The <code>recoveryEvent</code> marks the end of an ability's Execute phase and the beginning of its Recovery phase. In this example, a melee punch ability has a trigger that causes damage to enemies who overlap it. For it to work the trigger is only enabled for a brief moment, during the Execute phase.</p> <pre><code>--Server script\nlocal ability = script.parent\nlocal trigger = script:GetCustomProperty(\"ImpactTrigger\"):WaitForObject()\ntrigger.collision = Collision.FORCE_OFF\nlocal DAMAGE_AMOUNT = 10\nfunction OnExecute(ability)\ntrigger.collision = Collision.FORCE_ON\nend\nfunction OnRecovery(ability)\ntrigger.collision = Collision.FORCE_OFF\nend\nability.executeEvent:Connect(OnExecute)\nability.recoveryEvent:Connect(OnRecovery)\nfunction OnBeginOverlap(trigger, other)\n-- Only damage enemy players\nif other:IsA(\"Player\") and other.team ~= ability.owner.team then\nother:ApplyDamage(Damage.New(DAMAGE_AMOUNT))\nend\nend\ntrigger.beginOverlapEvent:Connect(OnBeginOverlap)\n</code></pre> <p>See also: CoreObject.parent | CoreObjectReference.WaitForObject | Ability.executeEvent | Event.Connect | other.IsA | Player.team | Damage.New | Trigger.beginOverlapEvent</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#tickevent","title":"<code>tickEvent</code>","text":"<p>Abilities fire the <code>tickEvent</code> while they are active or on cooldown (not on Ready state). In this example, a piece of equipment carries several abilities, but we want to do a common update logic on all of them. Note: <code>Ability.tickEvent</code> works somewhat differently from a <code>Tick()</code> function - <code>tickEvent</code> is an actual event that just happens to fire once per tick. Each invocation of the callback runs on its own task. This means that, unlike <code>Tick()</code>, there is no guarantee that it will wait for the previous <code>tickEvent</code> to finish before starting the next one. This means you can't use things like <code>Task.Wait()</code> to add time between ticks.</p> <pre><code>local equipment = script.parent\nlocal allAbilities = equipment:GetAbilities()\nfunction OnTick(ability, deltaTime)\nprint(\"Updating ability \" .. ability.name)\nend\nfor _, ability in ipairs(allAbilities) do\nability.tickEvent:Connect(OnTick)\nend\n</code></pre> <p>See also: CoreObject.parent | Equipment.GetAbilities | Event.Connect | CoreLua.print</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#activate","title":"<code>Activate</code>","text":"<p>The Ability <code>Activate()</code> function behaves as if the player had pressed the key binding. In order for a server gameplay decision to result in an ability activation, it must be communicated over the network somehow. In this example, a trigger overlap is representative of an arbitrary gameplay decision on the server. A broadcast message is sent to the client, who receives the event and activates the ability.</p> <pre><code>--Server script\nlocal trigger = script.parent\nlocal function OnBeginOverlap(trigger, other)\nif other:IsA(\"Player\") then\nEvents.BroadcastToPlayer(other, \"SteppedOnObject\")\nend\nend\ntrigger.beginOverlapEvent(OnBeginOverlap)\n--[[#description\n    Client context script under the ability:\n]]\nlocal ability = script:FindAncestorByType(\"Ability\")\nfunction OnPlayAnimation()\nif ability.owner and ability.owner == Game.GetLocalPlayer() then\nability:Activate()\nend\nend\nEvents.Connect(\"SteppedOnObject\", OnPlayAnimation)\n</code></pre> <p>See also: CoreObject.parent | Trigger.beginOverlapEvent | other.IsA | Events.BroadcastToPlayer | Ability.owner | Game.GetLocalPlayer()</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#advancephase","title":"<code>AdvancePhase</code>","text":"","tags":["API"]},{"location":"libs/_template_/#getcurrentphase","title":"<code>GetCurrentPhase</code>","text":"<p>In this example an ability is on cooldown, but can be set back to <code>Ready</code> by calling <code>AdvancePhase()</code>.</p> <pre><code>function EndAbilityCooldown(ability)\nif ability:GetCurrentPhase() == AbilityPhase.COOLDOWN then\nability:AdvancePhase()\nend\nend\n</code></pre> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#getcurrentphase_1","title":"<code>GetCurrentPhase</code>","text":"","tags":["API"]},{"location":"libs/_template_/#getphasetimeremaining","title":"<code>GetPhaseTimeRemaining</code>","text":"<p>In this example, while the ability is on cooldown, the percentage completion of the cooldown is calculated. This could be useful, for instance, in displaying user interface.</p> <pre><code>local ability = script:FindAncestorByType(\"Ability\")\nfunction Tick()\nif ability:GetCurrentPhase() == AbilityPhase.COOLDOWN then\nlocal duration = ability.cooldownPhaseSettings.duration\nlocal remaining = ability:GetPhaseTimeRemaining()\nlocal percent = 100 * (1 - remaining / duration)\nprint(\"Cooldown remaining: %\" .. string.format(\"%.2f\",percent))\nend\nend\n</code></pre> <p>See also: CoreObject.FindAncestorByType | Ability.GetCurrentPhase | AbilityPhaseSettings.duration | CoreLua.print</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#gettargetdata","title":"<code>GetTargetData</code>","text":"","tags":["API"]},{"location":"libs/_template_/#settargetdata","title":"<code>SetTargetData</code>","text":"<p>The ability's targeting data gives a lot of information about where and what the player is aiming at. If setup correctly, it can also be modified programmatically. In this example, the Z position of the target is flattened horizontally. Useful, for example, in a top-down shooter. For this to work it should be placed in a client context under the ability. The ability should also have the option \"Is Target Data Update\" turned off for the Execute phase, otherwise any data set programmatically will be overwritten when the phase changes.</p> <pre><code>--Server script\nlocal ability = script:FindAncestorByType(\"Ability\")\nfunction OnCast(ability)\nlocal abilityTarget = ability:GetTargetData()\nlocal pos = abilityTarget:GetHitPosition()\npos.z = ability.owner:GetWorldPosition().z + 50\nabilityTarget:SetHitPosition(pos)\nability:SetTargetData(abilityTarget)\nend\nability.castEvent:Connect(OnCast)\n</code></pre> <p>See also: CoreObject.FindAncestorByType | AbilityTarget.GetHitPosition | Ability.owner | Player.GetWorldPosition | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#interrupt","title":"<code>Interrupt</code>","text":"<p>Interrupting an ability either sends it back into ready state (if it was still in the Cast phase) or puts it on cooldown. In this example, we have an ability that searches for all enemies in a 10 meter radius and interrupts their abilities.</p> <pre><code>--Server script\nlocal ability = script.parent\nlocal RADIUS = 1000 -- 10 meters\nfunction OnExecute(ability)\nlocal center = ability.owner:GetWorldPosition()\n-- Search for enemies\nlocal enemies = Game.FindPlayersInCylinder(center, RADIUS, {ignoreTeams = ability.owner.team})\nfor _, enemy in ipairs(enemies) do\n-- Interrupt all their abilities\nlocal enemyAbilities = enemy:GetAbilities()\nfor _,a in ipairs(enemyAbilities) do\na:Interrupt()\nend\nend\nend\nability.executeEvent:Connect(OnExecute)\n</code></pre> <p>See also: CoreObject.parent | Ability.owner | Player.GetWorldPosition | Game.FindPlayersInCylinder | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#actionname","title":"<code>actionName</code>","text":"<p>Even though some API properties are read-only, they are useful is solutions such as user interface. In this example, a client context script searches the local player's list of abilities to find one that matches the action name (input) designated for this UI component. When it's found, the ability's name is written to the UI Text object.</p> <pre><code>--Client script\nlocal ACTION_NAME = script:GetCustomProperty(\"ActionName\")\nlocal NAME_UI = script:GetCustomProperty(\"NameUIText\"):WaitForObject()\nfunction GetLocalPlayerAbilityWithActionName()\nlocal player = Game.GetLocalPlayer()\nlocal abilities = player:GetAbilities()\nfor _, ability in pairs(abilities) do\nif ability.actionName == ACTION_NAME then\nreturn ability\nend\nend\nreturn nil\nend\nfunction Tick()\nlocal ability = GetLocalPlayerAbilityWithActionName()\nif ability then\nNAME_UI.text = ability.name\nend\nend\n</code></pre> <p>See also: CoreObject.name | CoreObjectReference.WaitForObject | Game.GetLocalPlayer | Player.GetAbilities | UIText.text</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#animation","title":"<code>animation</code>","text":"<p>In this example, the <code>ProcessAbilities()</code> function can be called once, such as at the beginning of a round, to take inventory of a player's abilities and classify them based on animation. This example also demonstrates how to disconnect event listeners so that we don't listen for the same event multiple times.</p> <pre><code>--Server script\nfunction OnMelee1HandCast(ability)\nprint(\"One-handed melee attack\")\nend\nfunction OnMelee2HandCast(ability)\nprint(\"Two-handed melee attack\")\nend\nlocal abilityEventListeners = {}\nfunction CleanupListeners(player)\n-- If we have previously processed this player, cleanup all listeners\nif abilityEventListeners[player] then\nfor i, eventListener in ipairs(abilityEventListeners[player]) do\neventListener:Disconnect()\nend\nabilityEventListeners[player] = nil\nend\nend\nfunction ProcessAbilities(player)\nCleanupListeners(player)\nlocal allAbilities = player:GetAbilities()\nfor _, ability in ipairs(allAbilities) do\nif string.match(ability.animation, \"melee\") then\nlocal eventListener\nif string.match(ability.animation, \"1h\") then\neventListener = ability.castEvent:Connect(OnMelee1HandCast)\nelse\neventListener = ability.castEvent:Connect(OnMelee2HandCast)\nend\ntable.insert(abilityEventListeners[player], eventListener)\nend\nend\nend\n-- Lets also cleanup when a player leaves the game, as perhaps their ability objects might stay in the game.\nGame.playerLeftEvent:Connect(CleanupListeners)\n</code></pre> <p>See also: EventListener.Disconnect | Player.GetAbilities | Ability.castEvent | Event.Connect | Game.playerLeftEvent | CoreLua.print</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#canactivatewhiledead","title":"<code>canActivateWhileDead</code>","text":"<p>Some games may have abilities that can be used while the player is dead. In this example, we have abilities that can only be activated while dead. If not dead, then it's interrupted.</p> <pre><code>--Server script\nlocal ability = script:FindAncestorByType(\"Ability\")\nfunction OnCast(ability)\nif ability.canActivateWhileDead and not ability.owner.isDead then\nability:Interrupt()\nend\nend\nability.castEvent:Connect(OnCast)\n--[[#description\n    On the client context, a user interface component that displays ability details is hidden until the player dies:\n]]\nlocal abilityCanvas = script:GetCustomProperty(\"Canvas\")\nlocal ACTION_NAME = script:GetCustomProperty(\"ActionName\")\nfunction Tick(deltaTime)\nlocal ability = GetLocalPlayerAbilityWithActionName()\nif ability\nand ability.isEnabled\nand ability.canActivateWhileDead\nand ability.owner\nand ability.owner.isDead then\nabilityCanvas.visibility = Visibility.INHERIT\nelse\nabilityCanvas.visibility = Visibility.FORCE_OFF\nend\nend\n-- Searches the local player's abilities until one with a matching action name is found\n-- The ACTION_NAME search criteria should be set in the custom property\nfunction GetLocalPlayerAbilityWithActionName()\nlocal abilities = Game.GetLocalPlayer():GetAbilities()\nfor _, ability in pairs(abilities) do\nif ability.actionName == ACTION_NAME then\nreturn ability\nend\nend\nreturn nil\nend\n</code></pre> <p>See also: CoreObject.FindAncestorByType | Ability.owner | Player.isDead | Event.Connect | CoreLua.Tick</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#canbeprevented","title":"<code>canBePrevented</code>","text":"<p>In this example, an ability recognizes that it has been interrupted by the activation of another, special ability, that is setup to serve for animation cancelling. The <code>canBePrevented</code> property is usually true in this game, but in this special case it has been configured as false so that it can be activated at any time. The player gains vertical impulse as result of the synergy and hears a small audio cue that helps communicate the mechanic.</p> <pre><code>--Server script\nlocal ability = script.parent\nlocal cancelSound = script:GetCustomProperty(\"CancelSound\")\nfunction OnInterrupted(ability)\nlocal player = ability.owner\nif not Object.IsValid(player) then return end\nfor _, a in ipairs(player:GetAbilities()) do\nif a:GetCurrentPhase() ~= AbilityPhase.READY and not a.canBePrevented then\nplayer:AddImpulse(Vector3.UP * 1000)\nWorld.SpawnAsset(cancelSound, {position = player:GetWorldPosition()})\nreturn\nend\nend\nend\nability.interruptedEvent:Connect(OnInterrupted)\n</code></pre> <p>See also: CoreObject.parent | Ability.owner | Object.IsValid | Player.GetAbilities | Vector3.UP | World.SpawnAsset | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#castphasesettings","title":"<code>castPhaseSettings</code>","text":"","tags":["API"]},{"location":"libs/_template_/#executephasesettings","title":"<code>executePhaseSettings</code>","text":"","tags":["API"]},{"location":"libs/_template_/#recoveryphasesettings","title":"<code>recoveryPhaseSettings</code>","text":"","tags":["API"]},{"location":"libs/_template_/#cooldownphasesettings","title":"<code>cooldownPhaseSettings</code>","text":"<p>In this example, a function in a client context script can be called to show the elapsed times for an ability. The UI Text it controls displays how many seconds are remaining in the current phase, and the color of the text blends from black to white to indicate the percentage of completion. Although the Execute and Recovery phases are actually separate, they are here presented to the player as a single phase.</p> <pre><code>--Client script\nlocal COUNTDOWN_TEXT = script:GetCustomProperty(\"CountdownText\"):WaitForObject()\nfunction UpdateForAbility(ability)\nlocal currentPhase = ability:GetCurrentPhase()\nlocal percent = 1\nlocal cooldownText = \"Ready\"\nif currentPhase ~= AbilityPhase.READY then\nlocal phaseDuration\nlocal timeRemaining = ability:GetPhaseTimeRemaining()\nif currentPhase == AbilityPhase.CAST then\nphaseDuration = ability.castPhaseSettings.duration\nelseif currentPhase == AbilityPhase.EXECUTE then\n-- In the case of Execute and Recovery phases, we can show those as a single one\nlocal recoveryD = ability.recoveryPhaseSettings.duration\nphaseDuration = ability.executePhaseSettings.duration + recoveryD\ntimeRemaining = timeRemaining + recoveryD\nelseif currentPhase == AbilityPhase.RECOVERY then\nphaseDuration = ability.recoveryPhaseSettings.duration\nelse --currentPhase == AbilityPhase.COOLDOWN\nphaseDuration = ability.cooldownPhaseSettings.duration\nend\nif phaseDuration &gt; 0 then\npercent = 1 - timeRemaining / phaseDuration\nend\ncooldownText = string.format(\"%.1f\", timeRemaining)\nend\nCOUNTDOWN_TEXT.text = cooldownText\nlocal c = Color.Lerp(Color.BLACK, Color.WHITE, percent)\nCOUNTDOWN_TEXT:SetColor(c)\nend\n</code></pre> <p>See also: CoreObject.GetCustomProperty | CoreObjectReference.WaitForObject | Ability.GetCurrentPhase | AbilityPhaseSettings.duration | UIText.text | Color.Lerp</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#isenabled","title":"<code>isEnabled</code>","text":"<p>In this example, an equipment is setup with multiple abilities that all use the same action binding. This script cycles through the abilities, making sure only one is enabled at a time. The <code>owner</code> property is cleared for the previous ability and set for the next one, as part of ensuring the correct one activates when the binding is pressed.</p> <pre><code>--Server script\nlocal equipment = script:FindAncestorByType(\"Equipment\")\nlocal abilities = {}\nlocal abilityIndex = 1\nfunction OnAbilityRecovery(ability)\nif (#abilities &gt; 1) then\nabilities[abilityIndex].isEnabled = false\nabilities[abilityIndex].owner = nil\nabilityIndex = abilityIndex + 1\nif (abilityIndex &gt; #abilities) then\nabilityIndex = 1\nend\nabilities[abilityIndex].isEnabled = true\nabilities[abilityIndex].owner = equipment.owner\nend\nend\nfor _, child in pairs(equipment:FindDescendantsByType(\"Ability\")) do\ntable.insert(abilities, child)\nchild.isEnabled = (#abilities == 1)\nchild.recoveryEvent:Connect(OnAbilityRecovery)\nend\n</code></pre> <p>See also: CoreObject.FindAncestorByType | Ability.owner | Equipment.owner | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#owner","title":"<code>owner</code>","text":"<p>Usually, abilities are presented as part of an equipment, but that isn't a requirement. In this example, when new players join the game they are assigned an ability through the use of the <code>owner</code> property.</p> <pre><code>--Server script\nlocal abilityTemplate = script:GetCustomProperty(\"AbilityTemplate\")\nfunction OnPlayerJoined(player)\nlocal ability = World.SpawnAsset(abilityTemplate)\nability.owner = player\nend\nGame.playerJoinedEvent:Connect(OnPlayerJoined)\n</code></pre> <p>See also: CoreObject.GetCustomProperty | World.SpawnAsset | Player.owner | Game.playerJoinedEvent | Event.Connect</p>","tags":["API"]},{"location":"libs/_template_/#tutorials","title":"Tutorials","text":"<p>Abilities in Core</p>","tags":["API"]},{"location":"libs/lua-dpapi/","title":"LuaDPApi","text":"<p>LuaDPApi provides an interface to the Microsoft Data Protection API. It implements a thin LUA wrapper interface over the <code>CryptProtectData</code> and <code>CryptUnprotectData</code> API calls. </p> <p>The main purpose is to store secrets (like passwords, or API token etc.) in a configuration file (like to OGS <code>station.ini</code>) without exposing the sensitive data to the world (e.g. if storing backups of these configuration files or versioning these files through git). This works by encrypting the secret data and writing the encrypted string into the configuration file. The application reading the configuration file can the decrypt the data and use it.</p> <p>In the background, the Microsoft Data Protection API encrypts/decrypts data by deriving an encryption key based on either the unique machine-id or a user-specific id:</p> <ul> <li>If the scope during the encryption is the machine-id, then all users, who are able to log on to this machine, will be able to decrypt the data. </li> <li>If the scope during the encryption is the user-id, then only the user, who encrypted the data will be able to decrypt later. Changes top the user password are tracked internally, so even after a password change, the user will be able to decrypt. If a users password is reset, then no access to the encrypted data is possible anymore.</li> </ul> <p>Note, that in an ActiveDirectory environment, backup keys are stored on the domain controller - allowing the domain administrator to decrypt, too. </p> <p>In addition to the user/machine-scope, an additional <code>enthropy</code> parameter can be used during encryption. In this case, the <code>enthropy</code>-data is added as part of the encryption key - effectively allowing successful decryption only, if the very same <code>enthropy</code>-data is added during decryption. This is e.g. used by the Edge browser to encrypt website passwords - the <code>entropy</code> data is the website URL, so without knowng the actual URL, no password can be decrypted.</p>","tags":["API"]},{"location":"libs/lua-dpapi/#module","title":"Module","text":"<p>The LuaDPApi module provides global functions to access the Microsoft Data Protection API.</p>","tags":["API"]},{"location":"libs/lua-dpapi/#functions","title":"Functions","text":"Function Name Return Type Description Tags <code>protect(data: string, scope: string = 'machine' entropy: string = nil)</code> <code>data: string</code> or <code>nil, win32error: integer</code> Encrypts the given data (binary string) using the given scope (one of 'maschine' or 'user') and entropy. Returns the encrypted data (as a binary string) or nil and the Win32 API error code. None <code>unprotect(data: string, entropy: string = nil)</code> <code>data: string</code> or <code>nil, win32error: integer</code> Dencrypts the given data (binary string) using the given entropy. Returns the decrypted data (as a binary string) or nil and the Win32 API error code. None <p>Info</p> <p>Note that the LUA functions pass raw data strings to the underlying Microsoft Data Protection API functions. Encoding and decoding text strings (e.g. to read/write the encrypted binary data from/to a configuration file) must be handled by additional code.</p> <p>Tip</p> <p>As encrypted data is binary, for configuration files, it is usually stored as a base64 encoded string. Use the LUA <code>mime</code> library (part of the <code>luasocket</code> library) to encode and decode a base64 string (see below for sample code). Also make sure to use the same text encoding for encryption and decryption (LUA uses UTF8-strings)!</p>","tags":["API"]},{"location":"libs/lua-dpapi/#examples","title":"Examples","text":"","tags":["API"]},{"location":"libs/lua-dpapi/#encrypt-a-string","title":"Encrypt a string","text":"<p>This sample shows how to encrypt a given plaintext string (LUA string, UTF8-encoded) and encode the encrypted data into a base64 string.</p> <pre><code>local dpapi = require('luadpapi')  -- load the DPAPI\nlocal mime = require('mime')       -- load luasocket/mime (base64)\n-- Sample plaintext password (or connection string, etc)\nlocal plaintext = 'MySuperSecretPassword' \n-- Encrypt the plaintext for the 'machine' scope. All users logged \n-- into the same machine will be able to decrypt the data later.\n-- encrypt (usually done at the commandline through powershell):\nlocal encrypted_data, err = dpapi.protect(plaintext, 'machine') \nif encrypted_data == nil then\nprint(\"ERROR: encrypt failed, err=\", err)\nos.exit(-1)\nend\n-- Do a base64 encode of the encrypted data for storing in *.ini file:\nlocal encrypted_b64 = mime.b64(encrypted_data)     \n-- TODO: save to some text file, but for now just print it\nprint(\"encrypted, base64 encoded data: \", encrypted_b64)\n</code></pre>","tags":["API"]},{"location":"libs/lua-dpapi/#decrypt-base64-encoded-data","title":"Decrypt base64-encoded data","text":"<p>This sample shows how to decrypt previously encrypted and base64 encoded data. </p> <pre><code>local dpapi = require('luadpapi')   -- load the DPAPI\nlocal mime = require('mime')        -- load luasocket/mime (base64)\n-- Sample plaintext password (or connection string, etc)\n-- !!! Make sure to paste the data generated from the previous sample!\nlocal encrypted_b64 = 'AQAAANCMnd8BFdERjHoAwE/Cl+'...'ylQ=' \n-- Convert from base64 to raw data\nlocal encrypted = mime.unb64(encrypted_b64)\n-- Decrypt the raw data.\nlocal decrypted_data, err = dpapi.unprotect(encrypted) \nif decrypted_data == nil then\nprint(\"ERROR: decrypt failed, err=\", err)\nos.exit(-1)\nend\n-- TODO: use the decrypted data - assume this is a string and print it:\nprint(\"decrypted data: \", decrypted_data)\n</code></pre>","tags":["API"]},{"location":"libs/lua-dpapi/#encryptdecrypt-using-powershell","title":"Encrypt/decrypt using Powershell","text":"<p>The DPAPI is also implemented in the [Security.Cryptography.ProtectedData] DotNET assembly, so  these functions can be also be used from Powershell.</p> <p>Warning</p> <p>In contrast to LUA, Powershell by default uses Unicode encodiung (16-Bit characters)!  For interoperability with LUA, make sure to encode/decode all strings to UTF8 (as shown  in the samples below)!</p> <p>The following samples are based on https://stackoverflow.com/questions/46400234/encrypt-string-with-the-machine-key-in-powershell.</p> <pre><code>Function Decrypt-WithMachineKey($s) {\nAdd-Type -AssemblyName System.Security\n$SecureStr = [System.Convert]::FromBase64String($s)\n$bytes = [Security.Cryptography.ProtectedData]::Unprotect($SecureStr, $null, [Security.Cryptography.DataProtectionScope]::LocalMachine)\n$Password = [System.Text.Encoding]::UTF8.GetString($bytes)\nreturn $Password\n}\nFunction Encrypt-WithMachineKey($s) {\nAdd-Type -AssemblyName System.Security\n$bytes = [System.Text.Encoding]::UTF8.GetBytes($s)\n$SecureStr = [Security.Cryptography.ProtectedData]::Protect($bytes, $null, [Security.Cryptography.DataProtectionScope]::LocalMachine)\n$SecureStrBase64 = [System.Convert]::ToBase64String($SecureStr)\nreturn $SecureStrBase64\n}\n# Encrypt\n$plaintext = \"MySuperSecretPassword\"\n$encrypted_b64 = Encrypt-WithMachineKey($plaintext)\n# Show the base64-string\n$encrypted_b64\n# Decrypt again\n$decrypted = Decrypt-WithMachineKey($encrypted_b64)\n# Show the decrypted string\n$decrypted\n</code></pre>","tags":["API"]},{"location":"libs/lua-dpapi/#sample-powershell-commandlet-for-encryption","title":"Sample powershell commandlet for encryption","text":"<p>The following script is a sample for a commandlet to encrypt sensitive data from the commandline. Use this as follows:</p> <pre><code>powershell -file myscript.ps1 -data \"MySuperSecretPassword\"\n</code></pre> <p>Here is the sample:</p> <pre><code># Encrypt a given text using DPAPI (machine key)\n# \n#   powershell -file myscript.ps1 -data \"MySuperSecretPassword\"\n#\nparam(\n[Parameter(Mandatory=$True, Position=0)]\n[System.String]\n$data\n)\nFunction Encrypt-WithMachineKey($s) {\nAdd-Type -AssemblyName System.Security\n$bytes = [System.Text.Encoding]::UTF8.GetBytes($s)\n$SecureStr = [Security.Cryptography.ProtectedData]::Protect($bytes, $null, [Security.Cryptography.DataProtectionScope]::LocalMachine)\n$SecureStrBase64 = [System.Convert]::ToBase64String($SecureStr)\nreturn $SecureStrBase64\n}\n# Encrypt\n$encrypted_b64 = Encrypt-WithMachineKey($data)\n# Show the base64-string\n$encrypted_b64\n</code></pre>","tags":["API"]},{"location":"libs/lua-hid/","title":"LuaHID","text":"<p>LuaHID provides an interface to access USB devices over the <code>HID</code> (human input device) protocol. It implements a thin LUA wrapper interface over the  cross platform hidapi library (hidapi.dll, see  signal11/hidapi (github.com), licensed under BSD License). The code is derived from ynezz/luahidapi (github.com) (MIT License) and adopted to OGS.</p> <p>Note, that although USB mice and keyboards are technically HID devices, the Windows API does not allow to access these through the HID API (for security reasons). All other (custom) USB HID devices should work.</p>","tags":["API"]},{"location":"libs/lua-hid/#module","title":"Module","text":"<p>The LuaHID module provides global functions to access the systems HID API. Before calling any other function of the module, the <code>init()</code> function must be called. </p> <p>To actually connect to a physical device, an instance of the <code>HidDevice</code> object must be created (see #class_hiddevice below) by calling the <code>open()</code> function. This requires specifying the VID (vendor ID) and PID (device id) and (optionally) the SN (serial number). If the parameters are not known beforehand, they may be listed through calling the module level <code>enumerate()</code> function. This returns a table of all currently connected devices. Specific device actions (like reading/writing) can then be executed on the object returned from the <code>open()</code> call.</p>","tags":["API"]},{"location":"libs/lua-hid/#properties","title":"Properties","text":"Property Name Return Type Description Tags <code>_VERSION</code> <code>string</code> Current version of the LuaHID module. See also the <code>version_mod()</code> function to get more details about the DLL module version. Read-Only <code>_TIMESTAMP</code> <code>string</code> Timestamp of the last build of the LuaHID module. Read-Only","tags":["API"]},{"location":"libs/lua-hid/#functions","title":"Functions","text":"Function Name Return Type Description Tags <code>init()</code> <code>boolean</code> Initializes the LuaHID library. Returns true on success, nil on failure. None <code>exit()</code> <code>boolean</code> Cleans up and terminates the LuaHID library. Returns true on success, nil on failure. None <code>enumerate(integer vid, integer pid)</code><code>enumerate()</code> <code>hidenum</code> Returns a HID device enumeration object for HID devices that matches given vid, pid pair. Enumerates all HID devices if no arguments provided or (0,0) used.IMPORTANT: Mouse and keyboard devices are not visible on WindowsReturns nil if failed. None <code>open(string path)</code><code>open(number vid, number pid)</code> <code>HidDevice</code> Opens a HID device using a path name or a vid,pid pair. Returns a HID device object on success - specifying a serial number is currently not implemented. Returns nil on failure. None <code>write(HidDevice dev, string report)</code><code>write(HidDevice dev, integer report_id, string report)</code> <code>integer</code> Writes the given <code>report</code> data string to the <code>report_id</code> (0 by default). Returns number of bytes actually sent on success, nil on failure. None <code>read(HidDevice dev, integer report_size [, timeout_msec])</code> <code>string</code> Reads data from the given device. If a device has multiple reports, the first byte indicates the report ID and one extra byte needs to be allocated via report_size. For a normal call, <code>timeout_msec</code> can be omitted and blocking will depend on the selected option setting. Passing <code>timeout_msec</code> == -1 will always block. Returns the report data (as string) on success, nil on failure. None <code>set(HidDevice dev, string option)</code> <code>integer</code> Set the read blocking option, allowed parameters are <code>noblock</code> and <code>block</code>. Returns true on success, nil on failure. None <code>getstring(HidDevice dev, string option)</code> <code>string</code> Reads the given option property from the device. Currently known option names are <code>manufacturer</code>, <code>product</code> and <code>serial</code>. Returns the option value on success, nil on failure. None <code>setfeature(HidDevice dev, integer feature_id, string data)</code> <code>integer</code> Send a feature report for the given <code>feature_id</code> with the given <code>feature_data</code>. Returns the number of bytes actually sent on success, nil on failure. None <code>getfeature(HidDevice dev, integer feature_id, integer feature_size)</code> <code>string</code> Get (read) a feature report for the given <code>feature_id</code>. A 0 is used for a single feature report. Returns the feature data (as a string) on success, nil on failure. None <code>error(HidDevice dev)</code> <code>string</code> Returns a string (as ASCII) describing the last error occurred for the device or nil if there was no error. None <code>close(HidDevice dev)</code> <code>None</code> Closes the given HidDevice object. None <code>msleep(integer milliseconds)</code> <code>None</code> Convenience function to sleep a number of milliseconds. None <code>version_mod()</code> <code>string, table</code> Returns the file version info of the LuaHID DLL (as a string in the from \"major.minor.build-hi,build-low\" and a table with the same values. None","tags":["API"]},{"location":"libs/lua-hid/#class-hiddeviceinfo","title":"Class HidDeviceInfo","text":"<p>The HidDeviceInfo table provides information about a USB HID device connected to the system. The HidDeviceInfo is retrieved by calling the <code>enumerate()</code> function and iterating the result by calling the <code>next()</code> member. </p>","tags":["API"]},{"location":"libs/lua-hid/#properties_1","title":"Properties","text":"Property Name Return Type Description Tags <code>path</code> <code>string</code> System specific device path. Read-Only <code>vid</code> <code>integer</code> Vendor ID of the device. Read-Only <code>pid</code> <code>integer</code> Product ID of the device. Read-Only <code>serial_number</code> <code>string</code> Device serial number. Read-Only <code>release</code> <code>integer</code> Release number (version) of the device. Read-Only <code>manufacturer_string</code> <code>string</code> Manufacturer name. Read-Only <code>product_ _string</code> <code>string</code> Product name. Read-Only <code>usage_page</code> <code>integer</code> HID usage page of the device. Read-Only <code>usage</code> <code>integer</code> HID usage of the device. Read-Only <code>interface</code> <code>integer</code> Interface number of the device. Read-Only","tags":["API"]},{"location":"libs/lua-hid/#class-hidenum","title":"Class HidEnum","text":"<p>The HidEnum class is actually an iterator and represents the list returned from calling the <code>enumerate</code> module function. Each element of the list represents a connected USB HID device and has the properties shown in the following section.  To iterate the list, call the <code>next()</code> instance function - each call to next returns a <code>HidDeviceInfo</code> table and internally advances to the next item.</p>","tags":["API"]},{"location":"libs/lua-hid/#functions_1","title":"Functions","text":"Function Name Return Type Description Tags <code>next()</code> <code>HidDevice</code> Returns the current device info data and steps on to the next element in the list. None <code>close()</code> <code>None</code> Closes the iterator and frees any resources. There is normally no need to call this, as the object is garbage collected automatically. None","tags":["API"]},{"location":"libs/lua-hid/#class-hiddevice","title":"Class HidDevice","text":"","tags":["API"]},{"location":"libs/lua-hid/#functions_2","title":"Functions","text":"<p>The member functions of HidDevice are wrapped functions of the module. The following lines are identical:</p> <pre><code>local hidapi = require('LuaHID')\n-- ...\n-- assume dev is a HidDevice object returned from calling open()\n-- The following are identical:\nhidapi.write(dev, report_id, report_data)\ndev:write(report_id, report_data)\n</code></pre> Function Name Return Type Description Tags <code>write(string report)</code><code>write(HidDevice dev, integer report_id, string report)</code> <code>integer</code> See <code>LuaHID.write(...)</code> None <code>read(integer report_size [, timeout_msec])</code> <code>string</code> See <code>LuaHID.read(...)</code> None <code>set(HidDevice dev, integer option)</code> <code>integer</code> See <code>LuaHID.set(...)</code> None <code>getstring(HidDevice dev, string option)</code> <code>string</code> See <code>LuaHID.getstring(...)</code> None <code>setfeature(HidDevice dev, integer feature_id, string data)</code> <code>integer</code> See <code>LuaHID.setfeature(...)</code> None <code>getfeature(HidDevice dev, integer feature_id, integer feature_size)</code> <code>string</code> See <code>LuaHID.getfeature(...)</code> None <code>error()</code> <code>string</code> See <code>LuaHID.error(...)</code> None <code>close(HidDevice dev)</code> <code>None</code> See <code>LuaHID.close(...)</code> None","tags":["API"]},{"location":"libs/lua-hid/#examples","title":"Examples","text":"","tags":["API"]},{"location":"libs/lua-hid/#enumerate-connected-devices","title":"Enumerate connected devices","text":"<p>This sample lists all connected HID devices and shows some of their properties. <pre><code>-- Load the LuaHID module\nlocal hidapi = require('LuaHID')\nprint(string.format(\"Lib VERSION %s build on %s\", hid._VERSION, hid._TIMESTAMP))\n-- Initialize the library\nif hidapi.init() then\nprint(\"hid library: init\")\nelse\nprint(\"hid library: init error\")\nreturn\nend\n-- Enumerate the currently connected devices and print some information\nlocal enum = hidapi.enumerate()\nif not enum then\nprint(\"Enumeration: no device found or enumeration failed!\")\nreturn\nelse\nwhile true do\nlocal dev = enum:next()\nif not dev then break end\nprint(\"Device found:\")\nprint(string.format(\"path = '%s'\", dev.path))\nprint(string.format(\"vid = 0x%04X\", dev.vid))\nprint(string.format(\"pid = 0x%04X\", dev.pid))\nprint(string.format(\"serial_number = '%s'\", dev.serial_number))\nend\nend\nend\n-- Do a clean shutdown\nif hidapi.exit() then\nprint(\"hid library: exit\")\nelse\nprint(\"hid library: exit error\")\nreturn\nend\n</code></pre></p>","tags":["API"]},{"location":"libs/lua-hid/#readwrite-device-report-data","title":"Read/write device report data","text":"<p>This sample tries to connect to a specific device using a given VID/PID and writes/reads some data in non-blocking mode.  <pre><code>-- Load the LuaHID module\nlocal hidapi = require('LuaHID')\nprint(string.format(\"Lib VERSION %s build on %s\", hid._VERSION, hid._TIMESTAMP))\n-- Initialize the library\nif hid.init() then\nprint(\"hid library: init\")\nelse\nprint(\"hid library: init error\")\nreturn\nend\n-- Open a device by VID/PID\nUSB_DEVICE_VID = 0x04D8\nUSB_DEVICE_PID = 0x8ABC\nUSB_REPORT_SIZE = 4\nlocal dev = hidapi.open(USB_DEVICE_VID, USB_DEVICE_PID)\nif not dev then\nprint(\"Open: unable to open test device\")\nreturn\nend\nprint(\"Open: opened test device\")\n-- Read the serial number\nlocal sn = dev:getstring(\"serial\")\nif sn then\nprint(\"Product String: \"..sn)\nelse\nprint(\"Unable to read product string\")\nreturn\nend\n-- set non-blocking reads\nif not dev:set(\"noblock\") then\nprint(\"Failed to set non-blocking option\")\nreturn\nend\n-- Try to read from the device. There shoud be no\n-- data here, but execution should not block.\nlocal rx = dev:read(USB_REPORT_SIZE)\nif rx then\nprint(\"Done non-blocking read test\")\nprint(\"Size of report read = \"..#rx)\nelse\nprint(\"Read error during non-blocking read test\")\nreturn\nend\n-- Prepare and write report; report 0 is implied\nlocal tx = string.char(0x12, 0x34, 0x56, 0x78)\nlocal res = dev:write(tx)\nif not res then\nprint(\"Unable to write()\")\nprint(\"Error: \"..dev:error())\nreturn\nend\n-- Try reading data\nlocal rx\nfor i = 1, 10 do\n-- a non-infinite read loop\n-- since we read immediately right after writing, the device buffer\n-- will be empty, it will NAK, and an empty string is returned\nrx = dev:read(USB_REPORT_SIZE)\nif not rx then\nprint(\"Unable to read()\")\nprint(\"Error: \"..dev:error())\nreturn\nelseif rx == \"\" then\nprint(\"Waiting...\")\nelse\nbreak\nend\nfor j = 1,200000 do end -- short delay\nend\nif #rx &gt; 0 then\nprint(\"Successfully read data from device!\")\nend\n-- Close the device\ndev:close()\nprint(\"Close: closed test device\")\n-- Do a clean shutdown\nif hidapi.exit() then\nprint(\"hid library: exit\")\nelse\nprint(\"hid library: exit error\")\nreturn\nend\n</code></pre></p>","tags":["API"]},{"location":"libs/lua-hid/#more-samples","title":"More samples","text":"<p>More samples can be found in then <code>examples</code>-folder in the GitHub repository at luahidapi/doc/examples at master \u00b7 ynezz/luahidapi (github.com).</p>","tags":["API"]},{"location":"libs/lua-modbus/","title":"LuaModbus","text":"<p>LuaModbus provides a wrapper over libModbus (see libmodbus (github.com), LGPL-2.1) to access Modbus-TCP/UDP-Devices from LUA. In addition to wrapping the libModbus library, LuaModbus also adds a background thread to cyclically read/write a set of registers and automatically reconnect the connection. Using this thread, after the connection is (re)established, a register can automatically be set to a given value (e.g. for setting a \"startup\" bit as seen in the Rexroth/Phoenix Contact I/O modules). The actual LUA wrapper is based on the etactica/lua-libmodbus (github.com) LUA bindings (MIT-License), but heavily modified for use with OGS.</p> <p>Unless otherwise noted, LuaModbus implements the same set of features as the original lua-libmodbus, so the library documentation (Reference (etactica.github.io)) is a very good source of information.</p> <p>Content will follow soon...</p>","tags":["API"]},{"location":"libs/lua-net/","title":"LuaNet","text":"<p>LuaNet provides simple to use functions for REST/OpenAPI calls using http and https protocols. Compared to luasocket and luassl, it uses the the Windows infrastructure and therefore correctly works with system proxies. Feature-wise it is not as flexible as luasocket/luassl at the moment (e.g. no direct access to all headers), but it is good enough for OAuth and SAP endpoints (like the SAP Digital Manufacturing Cloud).</p> <p>The basic functions work in a blocking mode, i.e. the process calling the function is blocked until a response from the endpoint is received. However, there are also asynchronous functions for starting a (post) request and polling for the completion. This is especially useful for long-running OpenAPI calls (like some SAP digital manufacturing cloud endpoints).</p> <p>Info</p> <p>All functions in LuaNet work transparently, i. e. use raw text strings (binary) for request and response body texts. For OpenAPI/REST services typically JSON encoded objects are used. From the large number of lua json libraries (e. g. see Awesome Lua), we recommend to use Lua CJSON. If you use another library, make sure it support UTF8 correctly! </p>","tags":["API"]},{"location":"libs/lua-net/#module","title":"Module","text":"<p>The LuaNet module provides global functions to execute http/https requests.</p>","tags":["API"]},{"location":"libs/lua-net/#functions","title":"Functions","text":"<p>The following table lists blocking functions: </p> Function Name Return Type Description Tags <code>get(url: string, user: string = nil, pass: string = nil)</code> <code>data: string, status: number, statustext: string, data: string</code> or <code>nil, status: number, statustext: number</code> Executes a blocking get request for the given URL. If the server returns (http) status = 200, then the response is considered valid. In any case, <code>status</code> and <code>statustext</code> will receive the http response header status data. If a response body is available, then this is returned in the <code>data</code> return value (even if status ~= 200). None <code>get_oauth_token(url: string, user: string = nil, pass: string = nil)</code> <code>status: number, data: string</code> or <code>nil, status: number, statustext: string</code> Requests client credentials from an OAuth2 server (granttype = client_credentials). None <code>post(url: string, body: string = nil, auth_bearer_token: string = nil)</code> <code>status: number, data: string, statustext: string</code> Send a post request to the given endpoint <code>URL</code>, with post <code>data</code> in the request body, optinally adding the <code>auth_bearer_token</code> value to the <code>Authorization</code> header. None <p>The following table lists the non-blocking functions:</p> Function Name Return Type Description Tags <code>post_async(url: string, body: string = nil, auth_bearer_token: string = nil)</code> <code>handle: number</code> or <code>nil</code> Starts an async post request (see the blocking <code>post</code> above for parameter descriptions). On success a <code>handle</code> is returned, which can be used for polling the request status or aborting the request. None <code>abort_async_request(handle: number)</code> (no return value) Tries to abort a currently active request identified by the <code>handle</code> value (as returned from <code>post_async()</code>. If the request is currently active, it might block for a short time - until the request is actually cancelled. If a request was cancelled, then further calls to <code>poll_async_request()</code> will return <code>nil</code>, as the internal request object for the given handle was deleted and does not exist anymore. None <code>poll_async_request(handle: number)</code> <code>requeststate: number, status: number, data: string, statustext: string</code>  or <code>nil, errorcode: number, errortext: string</code> Checks the request state of a pending request and returns the current state in <code>requeststate</code>. If the 'handle' was not found, nil is returned for <code>requeststae</code>, else the current (internal) process step. A value of &gt;= 100 indicates, that the request has completed and the other return values are valid (see the blocking <code>post</code> above for result value descriptions). Note, that the internal request object is automatically deleted after <code>poll_async_request()</code> returns a status of &gt;= 100. None <p>Warning</p> <p>A request started through <code>post_async()</code> must be completed by either aborting the request through <code>abort_async_request()</code> or by polling the request (by using <code>poll_async_request</code>) until a state of &gt;= 100 is returned. If not, then the internal request object will not get deleted thus consuming more and more resource.</p>","tags":["API"]},{"location":"libs/lua-net/#examples","title":"Examples","text":"","tags":["API"]},{"location":"libs/lua-net/#simple-get-request","title":"Simple get request","text":"<p>This sample shows how to execute a simple https get request with basic authentication (e.g. typical surveillance camera).</p> <pre><code>local mime = require('mime')       -- load luasocket/mime (base64)\n-- Sample plaintext password (or connection string, etc)\nlocal plaintext = 'MySuperSecretPassword' \n-- Encrypt the plaintext for the 'machine' scope. All users logged \n-- into the same machine will be able to decrypt the data later.\n-- encrypt (usually done at the commandline through powershell):\nlocal encrypted_data, err = dpapi.protect(plaintext, 'machine') \nif encrypted_data == nil then\nprint(\"ERROR: encrypt failed, err=\", err)\nos.exit(-1)\nend\n-- Do a base64 encode of the encrypted data for storing in *.ini file:\nlocal encrypted_b64 = mime.b64(encrypted_data)     \n-- TODO: save to some text file, but for now just print it\nprint(\"encrypted, base64 encoded data: \", encrypted_b64)\n</code></pre>","tags":["API"]},{"location":"libs/lua-net/#decrypt-base64-encoded-data","title":"Decrypt base64-encoded data","text":"<p>This sample shows how to decrypt previously encrypted and base64 encoded data. </p> <pre><code>local dpapi = require('luadpapi')   -- load the DPAPI\nlocal mime = require('mime')        -- load luasocket/mime (base64)\n-- Sample plaintext password (or connection string, etc)\n-- !!! Make sure to paste the data generated from the previous sample!\nlocal encrypted_b64 = 'AQAAANCMnd8BFdERjHoAwE/Cl+'...'ylQ=' \n-- Convert from base64 to raw data\nlocal encrypted = mime.unb64(encrypted_b64)\n-- Decrypt the raw data.\nlocal decrypted_data, err = dpapi.unprotect(encrypted) \nif decrypted_data == nil then\nprint(\"ERROR: decrypt failed, err=\", err)\nos.exit(-1)\nend\n-- TODO: use the decrypted data - assume this is a string and print it:\nprint(\"decrypted data: \", decrypted_data)\n</code></pre>","tags":["API"]},{"location":"tools/","title":"Tool configuration","text":""},{"location":"tools/#overview","title":"Overview","text":""},{"location":"tools/#stationini","title":"station.ini","text":""},{"location":"tools/remote-tool/","title":"RemoteTool","text":"<p>OGS supports connecting tools over a <code>ToolGateway</code>. This enables advanced  tool management scenarios, e.g. \"roaming\" tools between multiple stations.</p> <p>Using the <code>RemoteTool</code> driver requires a <code>ToolGateway</code> running on a server - the server then actually controls the tool, whereas the OGS stations only communication with the <code>ToolGateway</code>. This allows delegating tool management to the central <code>ToolGateway</code>. </p> <p>For each tool managed through the <code>ToolGateway</code>, OGS only uses a generic <code>RemoteTool</code> type channel in its local configuration, the <code>ToolGateway</code> then has the actual tool-specific configuration (like e.g. OpenProtocol tools).</p>"},{"location":"tools/remote-tool/#installation","title":"Installation","text":"<p>The <code>RemoteTool</code> driver is implemented in <code>RemoteTool.dll</code>. To use any <code>RemoteTool</code> tool, the driver must be loaded in the <code>[TOOL_DLL]</code> section of the projects <code>station.ini</code> configuration file (see also Tool configuration).</p> <p>To enable the driver in station.ini, set it as follows:</p> <pre><code>[TOOL_DLL]\nRemoteTool.dll=1\n</code></pre> <p>The overall parameters for the <code>RemoteTool</code> driver are configured in the \u00b4[RemoteTool]<code>section. This is basically used to configure the</code>ToolGateway` connection parameters, here is a sample setup:</p> <pre><code>[RemoteTool]\nToolGateway_Addr=mytoolgateway.mycompany.com\nToolGateway_Port=\n</code></pre> <p>For more information about the driver parameters, see Driver Parameters below.</p>"},{"location":"tools/remote-tool/#tool-registration-and-configuration","title":"Tool registration and configuration","text":"<p>All <code>RemoteTool</code>-tools are registered in the <code>[CHANNELS]</code> section of the projects <code>station.ini</code> file.</p> <p>The <code>[CHANNELS]</code> section only defines a channel number to channel name mapping - the channel/tool specific settings are then configured in a seperate section defined by the channel name. Inside the section, a reference to the <code>RemoteTool</code> driver then links driver and channel accordingly.</p> <p>The overall layout is therefore as follows (sample is for channel 2):</p> <pre><code>[CHANNELS]\n# Map the channel/tool 2 to the 'RemoteTool_Nexo1'-section\n2=RemoteTool_Nexo1\n\n[RemoteTool_Nexo1]\n# link to the RemoteTool driver\nDRIVER=RemoteTool\n# more channel/tool specific parameters for this tool/driver\n</code></pre> <p>Please see Channel/tool parameter reference below for more information about the available parameters.</p>"},{"location":"tools/remote-tool/#channeltool-parameter-reference","title":"Channel/tool parameter reference","text":"<p>Currently, there are no channel/tool-specific parameters needed (other than specifying the <code>DRIVER=RemoteTool</code>) to use this driver. All concrete tool communication settings are to be configured on the <code>ToolGateway</code> server side. </p>"},{"location":"tools/remote-tool/#driver-parameter-reference","title":"Driver parameter reference","text":"<p>The driver parameters are defined in the <code>[RemoteTool]</code> section in the projects <code>station.ini</code>.</p> <p>The following parameters are available:</p>"},{"location":"tools/remote-tool/#toolgateway_addr","title":"ToolGateway_Addr","text":"<p>IP address or hostname of the tool gateway.</p>"},{"location":"tools/remote-tool/#toolgateway_port","title":"ToolGateway_Port","text":"<p>(optional)</p> <p>Port number to use for connecting to the tool gateway. If not given, the driver tries to use the RPC endpoint mapper using the service UUID to resolve the connection endpoint (might require additional firewall settings).</p>"},{"location":"tools/openprotocol/","title":"OpenProtocol tools","text":"<p>OGS supports connecting tools with <code>OpenProtocol</code> interface. As tools differ in functionality and also different tool vendors implement the <code>OpenProtocol</code> specification in slightly different ways, OGS has special protocol handlers for the following tools:</p> <ul> <li>Rexroth Nexo and Nexo 2 wireless tools (for more information, see Nexo OpenProtocol)</li> <li>Rexroth CS351 and KE350 system tools (for more information, see System 350 OpenProtocol)</li> <li>Rexroth OPEXplus (for more information, see OPEXplus OpenProtocol)</li> <li>GWK Operator+ torque wrenches (for more information, see GWK Operator+ OpenProtocol)</li> <li>Crane TCI torque wrenches (for more information, see Crane OpenProtocol)</li> <li>Gehmeyr Exact Wifi tools (for more information, see Gehmeyr OpenProtocol)</li> <li>Sturtevant Richmont Global 400 MP connected Exacta 2 digital torque wrenches (for more information, see Sturtevant Richmond OpenProtocol)</li> </ul> <p>The overall configuration for these tools is similar and the actual driver has the same set of configuration parameters - described on this page.</p> <p>To workaround various glitches in the tools concrete OpenProtocol implementation, the tools are identified by their MID0002 vendor string and their tool type name. For more details, see the CHANNEL TYPE Parameter description in the Channel parameter reference below. </p> <p>The supported tool types and vendor codes are:</p> Tool type Vendor code Vendor Comments NEXO BRC Bosch Rexroth Wireless Nexo Tool CS351 BRC Bosch Rexroth Single channel Compact Box KE350 BRC Bosch Rexroth Multispindle system CRANE CEL Crane Electronics TCI Multi, Wrenchstar GHM GHM Gehmeyr GF-ION-EXACT GWK GWK GWK Operator+ CET CET Sturtevant Richmond Global 400mt controller"},{"location":"tools/openprotocol/#installation","title":"Installation","text":"<p>The <code>OpenProtocol</code> driver is implemented in <code>OpConn.dll</code>. To use any <code>OpenProtocol</code> tool, the driver must be loaded in the <code>[TOOL_DLL]</code> section of the projects <code>station.ini</code> configuration file (see also Tool configuration).</p>"},{"location":"tools/openprotocol/#tool-registration-and-configuration","title":"Tool registration and configuration","text":"<p>All <code>OpenProtocol</code>-tools are registered in the <code>[OPENPROTO]</code> section of the projects <code>station.ini</code> file.</p> <p>The <code>[OPENPROTO]</code> section mixes the tool parameters and the channel mapping (due to historic reasons) by combining the channel number and the parameter name/value in the <code>station.ini</code> entry. </p> <p>Each parameter is prefixed with the channel number and followed by parameter name as follows:</p> <pre><code>CHANNEL_&lt;two-digit channel&gt;_&lt;param name&gt;=&lt;param value&gt;\n</code></pre> <p>Where - <code>&lt;two-digit channel&gt;</code> is the channel number in the range 01...99 (the channel number maps 1:1 to the tool number from the workflow configuration)  - <code>&lt;param name&gt;</code> is the parameter name (see Channel parameter reference) - <code>&lt;param value&gt;</code> is the actual parameter value for the given parameter</p> <p>In addition to the channel-specific parameters, there are also shared parameters. These act as default parameters for the channel-specific settings and can be overridden by the channel specific values.</p> <p>For more details on the shared parameters, see Shared parameter reference) below .</p> <p>A sample <code>OpenProtocol</code> tool configuration (channel 01) would therefore look similar to the following:</p> <pre><code>[OPENPROTO]\n# Shared/default parameters\nPORT=4545\n# Channel/Tool 1 parameters\nCHANNEL_01=10.10.2.163\nCHANNEL_01_TYPE=NEXO\nCHANNEL_01_CHECK_TIME_ENABLED=1\nCHANNEL_01_NEXONAR_CHANNEL=6\nCHANNEL_01_CURVE_REQUEST=1\n</code></pre>"},{"location":"tools/openprotocol/#shared-parameter-reference","title":"Shared parameter reference","text":"<p>The shared parameters can be used to change the global defaults for all OpenProtocol tools. If assigned, then these settings will override the built-in defaults. Note, that a channel-specific setting will take priority anyways.</p>"},{"location":"tools/openprotocol/#port","title":"PORT","text":"<p>(optional, defaults to 4545)</p> <p>Defines the TCP port used for OpenProtocol communication. By default uses the standard OpenProtocol port 4545. If the controller supports multiple tools through a single IP address, then typically this setting must be changed to correctly connect to the individual tool.</p>"},{"location":"tools/openprotocol/#check_time_interval","title":"CHECK_TIME_INTERVAL","text":""},{"location":"tools/openprotocol/#time_tolerance","title":"TIME_TOLERANCE","text":""},{"location":"tools/openprotocol/#external_io_offset","title":"EXTERNAL_IO_OFFSET","text":""},{"location":"tools/openprotocol/#channel-parameter-reference","title":"Channel parameter reference","text":"<p>For specific information about a tools settings or the tools configuration needed (on the tool side), please see the tool-specific information.</p> <p>The parameter names are composed of the channel prefix <code>CHANNEL_</code> followed by the channel/tool number (1-32) and the actual parameter name (e.g. <code>TYPE</code>). - see the detailed description above. </p> <p>In general, the following parameters are available for a <code>OpenProtocol</code>-tool:</p>"},{"location":"tools/openprotocol/#ip","title":"IP","text":""},{"location":"tools/openprotocol/#port_1","title":"PORT","text":"<p>(optional, defaults to the shared parameter value)</p>"},{"location":"tools/openprotocol/#type","title":"TYPE","text":"<p>(mandatory)</p> <p>The allowed tool types and their default parameters are listed in the following table:</p> Tool type Alive send rate Response Timeout Comments NEXO 2 5 CS351 5 15 KE350 5 15 CRANE 1 5 GHM 2 5 MID0060 Rev 999 only, no alarms GWK 2 5 No MID0040 support, use MID0061 tool SN CET 2 5 no alarms, incorrect (+1) result ID sequence <p>NOTES: - The Alive send rate and Response timeout default parameter values can be overridden by the ALIVEXMTT and RSPTIMEOUT parameters.  - All tools use a slightly different set of MIDs to control operation, e.g. some do support alarms, others don't or allow different revisions of the MID commands. - For Nexo with firmware &lt; V1500, a Alive send rate of 1000ms or less is recommended to ensure stable WiFi operation - For CS351 and KE350, do not use a Alive send rate less than 5 second, else the controller may become unresponsive </p>"},{"location":"tools/openprotocol/#ccw_ack","title":"CCW_ACK","text":""},{"location":"tools/openprotocol/#params","title":"PARAMS","text":""},{"location":"tools/openprotocol/#alivexmtt","title":"ALIVEXMTT","text":""},{"location":"tools/openprotocol/#showalive","title":"SHOWALIVE","text":""},{"location":"tools/openprotocol/#rsptimeout","title":"RSPTIMEOUT","text":""},{"location":"tools/openprotocol/#barcode_mid0051_rev","title":"BARCODE_MID0051_REV","text":""},{"location":"tools/openprotocol/#check_ext_cond","title":"CHECK_EXT_COND","text":""},{"location":"tools/openprotocol/#appl_start","title":"APPL_START","text":""},{"location":"tools/openprotocol/#curve_request","title":"CURVE_REQUEST","text":""},{"location":"tools/openprotocol/#check_time_enabled","title":"CHECK_TIME_ENABLED","text":""},{"location":"tools/openprotocol/#ignore_id","title":"IGNORE_ID","text":""},{"location":"tools/openprotocol/gwk/","title":"GWK Operator+","text":"<p>The GWK Operator+ OpenProtocol implementation (currently, as of June 2023) has quite some quirks. OGS tries to workaround most of them, but the following parameters needs to be tweaked:</p> <ul> <li>The GWK tool only supports a single OpenProtocol session (even if multiple TCP connections are allowed). Make sure to disable multiple connections in the GWK xPico Web settings (under the \"Tunnel\"--&gt;\"Accept\" category)</li> <li>The GWK tool seems to never actively disconnect a TCP session and does not close an OpenProtcol session, if the TCP connection gets dropped. According to the GWK development, the internal session is only closed, if no message is received within 15 seconds (the MID9999 alive timeout) - irregardless of the state of the TCP connection. As a workaround, OGS therefore always waits for 30 seconds to reconnect to the tool in case of network communication errors. Faster reconnects are not recommended, as the tool replies with MID0004 (error 96) for the next MID0001 (which makes any OpenProtocol client disconnect). Having a reconnect time of less than 15 seconds therefore will lead to a reconnect loop, where never a good connection to the tool can be established.</li> </ul> <p>see Bosch Rexroth OPEXplus for information about the tool.</p> <p></p>"},{"location":"tools/openprotocol/sturtevant/","title":"Sturtevant Richmond Global 400mp","text":"<p>The Sturtevant Richmond controller allows </p> <p>see Global 400mp Torque Controller</p> <p></p>"},{"location":"v3/lua/customtools/","title":"Lua custom tools","text":"","tags":["API"]},{"location":"v3/lua/customtools/#overview","title":"Overview","text":"<p>OGS has an interface to add additional tool drivers by adding Windows-DLLs to the <code>[TOOL_DLL]</code> section in <code>station.ini</code>. To make it easier to implement custom tool drivers, OGS provides <code>heLuaTool.dll</code> - this allows implementing tool drivers in pure LUA. </p> <p>To implement a tool driver in LUA, usually the following steps are required:</p> <ul> <li>Add/enable <code>heLuaTool.dll</code> in the <code>[TOOL_DLL]</code>-section in <code>station.ini</code></li> <li>Create a custom LUA tool driver file (see bvelow) and add it to your projects configuration (add the file name to the <code>requires = {}</code>-list in <code>config.lua</code>)</li> <li>Add one or more channels to <code>station.ini</code> (in the <code>[CHANNELS]</code>-section in <code>station.ini</code>). Note, that the section name assigned to the tool number must start with <code>LuaTool_</code>!</li> <li>Add the specified section to <code>station.ini</code> and set <code>Driver=heLuaTool</code> and <code>TYPE=</code> to the tool driver name as defined in your custom LUA tool driver</li> <li>Also add the tool/channel parameters as required by your LUA driver in the specified section.</li> <li>To allow using the custom tools, add then to the <code>custom</code> section in the heOpCfg tools editor tab. Also add new tool/action properties as required. Make sure to use the same tool/channel numbers as defined in your <code>station.ini</code>. </li> </ul> <p>Here is an excerpt from <code>station.ini</code> showing the relevant entries:</p> station.ini<pre><code>[TOOL_DLL]\nheLuaTool.dll=1 ; (1)!\n[CHANNELS]\n20=LuaTool_MyCustomTool ; (2)!\n[LuaTool_MyCustomTool]\nDriver=heLuaTool\nTYPE=MyCustomTool\n; additional LUA too specific parameters can follow\n</code></pre> <ol> <li> <p>Load and enable the generic LUA tool interface DLL</p> </li> <li> <p>Create the channel/tool 20 and assign the configuration section <code>LuaTool_MyCustomTool</code>. Make sure to start the section name with <code>LuaTool_</code>, else the Lua tool DLL will not get loaded for this section!</p> </li> </ol> <p>To implement a tool driver using LUA, there are basically two options:</p> <ol> <li>Use the low-level API provided by <code>heLuaTool.dll</code>.</li> <li>Use the Simplified API </li> </ol> <p>Info</p> <p>It is highly recommended to use the Simplified API described below to implement custom tool drivers - using the low-level API requires in-depth knowledge of the API to not break other drivers!</p>","tags":["API"]},{"location":"v3/lua/customtools/#simplified-api","title":"Simplified API","text":"<p>The simplified custom tool driver API uses five states and associated transitions to implement the tool behaviour. Each transitions can be implemented in the custom tool LUA code to provide the custom functionality - if not implemented, the transition is executed without a custom action.</p> <p>Here is the state diagram for the behaviour:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; active: init()\n    inactive --&gt; active: activate()\n    active --&gt; inactive: deactivate()\n    active --&gt; enabled: enable()\n    enabled --&gt; enabled: execute()\n    enabled --&gt; disabled: disable()\n    disabled --&gt; enabled: enable()\n    disabled --&gt; inactive: deactivate()</code></pre>","tags":["API"]},{"location":"v3/lua/customtools/#luanet","title":"LuaNet","text":"<p>LuaNet provides simple to use functions for REST/OpenAPI calls using http and https protocols. Compared to luasocket and luassl, it uses the the Windows infrastructure and therefore correctly works with system proxies. Feature-wise it is not as flexible as luasocket/luassl at the moment (e.g. no direct access to all headers), but it is good enough for OAuth and SAP endpoints (like the SAP Digital Manufacturing Cloud).</p> <p>The basic functions work in a blocking mode, i.e. the process calling the function is blocked until a response from the endpoint is received. However, there are also asynchronous functions for starting a (post) request and polling for the completion. This is especially useful for long-running OpenAPI calls (like some SAP digital manufacturing cloud endpoints).</p> <p>Info</p> <p>All functions in LuaNet work transparently, i. e. use raw text strings (binary) for request and response body texts. For OpenAPI/REST services typically JSON encoded objects are used. From the large number of lua json libraries (e. g. see Awesome Lua), we recommend to use Lua CJSON. If you use another library, make sure it support UTF8 correctly! </p>","tags":["API"]},{"location":"v3/lua/customtools/#module","title":"Module","text":"<p>The LuaNet module provides global functions to execute http/https requests.</p>","tags":["API"]},{"location":"v3/lua/customtools/#functions","title":"Functions","text":"<p>The following table lists blocking functions: </p> Function Name Return Type Description Tags <code>get(url: string, user: string = nil, pass: string = nil)</code> <code>data: string, status: number, statustext: string, data: string</code> or <code>nil, status: number, statustext: number</code> Executes a blocking get request for the given URL. If the server returns (http) status = 200, then the response is considered valid. In any case, <code>status</code> and <code>statustext</code> will receive the http response header status data. If a response body is available, then this is returned in the <code>data</code> return value (even if status ~= 200). None <code>get_oauth_token(url: string, user: string = nil, pass: string = nil)</code> <code>status: number, data: string</code> or <code>nil, status: number, statustext: string</code> Requests client credentials from an OAuth2 server (granttype = client_credentials). None <code>post(url: string, body: string = nil, auth_bearer_token: string = nil)</code> <code>status: number, data: string, statustext: string</code> Send a post request to the given endpoint <code>URL</code>, with post <code>data</code> in the request body, optinally adding the <code>auth_bearer_token</code> value to the <code>Authorization</code> header. None","tags":["API"]},{"location":"v3/lua/customtools/#mermaid-test","title":"Mermaid test","text":"<p>The following is a simple mermaid sequence diagram, for more details, see https://squidfunk.github.io/mkdocs-material/reference/diagrams/</p> <pre><code>sequenceDiagram\n  autonumber\n  Alice-&gt;&gt;John: Hello John, how are you?\n  loop Healthcheck\n      John-&gt;&gt;John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts!\n  John--&gt;&gt;Alice: Great!\n  John-&gt;&gt;Bob: How about you?\n  Bob--&gt;&gt;John: Jolly good!</code></pre>","tags":["API"]},{"location":"v3/lua/eventlog/","title":"Workflow and interaction events","text":""},{"location":"v3/lua/eventlog/#overview","title":"Overview","text":"<p>The OGS core allows to subscribe for various events from the kernel. The main use case is to log all actions to allow full traceability or to measure event timings.</p> <p>The LUA eventlog interface consists of the single global table <code>EventLog</code> - and a few functions which are called by OGS. The <code>EventLog</code> table must be created by the LUA code during startup, as <code>EventLog.Init()</code> is only called once during the OGS startup sequence.</p> <p>The following functions should be defined to use the EventLog-Interface:</p> <ul> <li><code>EventLog.Init()</code>: Is called during OGS startup. To enable the EventLog events, the function must return true.</li> <li><code>EventLog.Stop()</code>: Is called before OGS shuts down. </li> <li><code>EventLog.Write(EventType, ...)</code>: Is called whenever a new event is emitted by the OGS core.</li> </ul> <p>The following <code>EventType</code> values are currently supported:</p> <ul> <li><code>COMMON</code> (= 0): </li> <li><code>BARCODE</code> (= 1): </li> <li><code>INTERACTION</code> (= 2):</li> <li><code>USER_LOGON</code> (= 3):</li> <li><code>ALARM</code> (= 4):</li> <li><code>WORKFLOW</code> (= 5): </li> <li><code>RESULT</code> (= 6): Called whenever the current tool result is updated.</li> <li><code>SOFTWARE_ERROR</code> (= 7):  -- configuration( ini)  errors</li> </ul>"},{"location":"v3/lua/eventlog/#events","title":"Events","text":"<p>The <code>EventLog.Write(EventType, ...)</code> function is called with different parameters, depending on the actual <code>EventType</code>. If the event is related to a user action, then the parameters <code>User1</code> and <code>User2</code> provide information about the users logged on when the event occurred. The parameters are as follows:</p> <ul> <li><code>User1</code>: The operator-level user</li> <li><code>User1</code>: The supervisor-level user (if logged on)</li> </ul>"},{"location":"v3/lua/eventlog/#common-event","title":"Common event","text":"<p>The common event is currently not used by the OGS core, but reserved as a general status/text event placeholder. It can be used e.g. from the LUA side to inject custom events. The function signature is as follows:</p> <pre><code>EventLog.Write(BARCOMMON, Status, Text)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li>Status (int): Custom status code</li> <li>Text (string): Custom event message</li> </ul>"},{"location":"v3/lua/eventlog/#barcode-event","title":"Barcode event","text":"<p>The barcode event is fired, whenever a new barcode is received. The function signature is as follows:</p> <pre><code>EventLog.Write(BARCODE, FieldNo, User1, User2, Code, Source, Tag)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li>FieldNo: Barcode field number (reference into the barcode table)</li> <li>Code: The actual ID-Code value</li> <li>Source: The ID code source (<code>Barcode</code>, <code>RFID</code>, ... whatever is configured in <code>station.ini</code> or added through <code>barcode.lua</code>)</li> <li>Tag: The barcode table tag name - typically used to identify the type of the scanned bar code. This has a 1:1 relation to the FieldNo value and is defined in the projects barcode table (see <code>barcode.lua</code>).</li> </ul>"},{"location":"v3/lua/eventlog/#interaction-event","title":"Interaction event","text":"<p>The interaction event is fired, whenever one of the operator buttons is pressed on the GUI. The function signature is as follows:</p> <pre><code>EventLog.Write(INTERACTION, Request, User1, User2, Text, JobSeq, OpSeq, Field)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li> <p>Request: The actual request code, one of the following:</p> <ul> <li> <p>noReq (0x0000=: no request</p> </li> <li> <p>finishProcess (0x0001): finish assembly processing</p> </li> <li>clearProcess (0x0002): clear all tightening results on assembly go to first Job</li> <li>startJob (0x0004): start current Job (is available only in WorkflowState::WaitJobStart)</li> <li>finishJob (0x0008): finish current Job processing and set WorkflowState::WaitJobStart</li> <li>skipJob (0x0010): finish current Job processing and go to next Job</li> <li>clearJob (0x0020): clear all tightening results on current Job and set WorkflowState::WaitJobStart</li> <li>skipRundown (0x0040): set current operation to NOK and go to next operation</li> <li>clearBolt (0x0080): set current Bolt to NOT_PROCESSED</li> <li>startDiag (0x0100): enable start diagnostic job</li> <li>selectRundown (0x0200): select Job / Bolt in view or on image</li> <li>userLogon (0x0400): user logon</li> <li>pauseJob (0x0800): pause Job</li> <li>processNOK (0x1000): continue processing after NOK result</li> <li>CCW (0x2000): CCW</li> <li>manualInput (0x4000): manual input in start view (added for LUA trace log only)</li> <li>unmountJob (0x8000): unmount Job</li> <li>switchTool (0x10000): switch between alternative and standard tool</li> <li>teachToolPos (0x20000): enable teach mode for teaching a new tool position (only if positioning mode is enabled)</li> </ul> </li> <li> <p>Text: Usually empty, except for the <code>manualInput</code> request - in this case provides the actual manual input value.</p> </li> <li>JobSeq: Current job sequence</li> <li>OpSeq: Current task/operation sequence</li> <li>Field: Used for the <code>manualInput</code> request - has the field name for which data was entered.</li> </ul>"},{"location":"v3/lua/eventlog/#logon-event","title":"Logon event","text":"<p>The logon event is fired, whenever a user logs on or off. The function signature is as follows:</p> <pre><code>EventLog.Write(LOGON, Status, User1, User2, Text, Level)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li> <p>Status: Logon result status, one of the following values</p> <ul> <li>0 = Success (user is logged on)</li> <li>-1 = Username not found (unknown username or database connection error)</li> <li>-2 = Invalid password (or password check failed)</li> <li>-3 = No priviledges (user is known, password is correct, but missing rights for actual logon - might happen, if e.g. certification check or trainig checks fail for the user (or are outdated))</li> <li>1 = Logoff (user has successfully logged off)</li> <li>2 = Autologon (the autologon user is now logged on)</li> </ul> </li> <li> <p>Text: Depending on the status value one of the following</p> <ul> <li>'login': for successful user login.</li> <li>'autologon' for failed user autologon </li> <li>username in case of otherwise failed login attempts</li> </ul> </li> <li> <p>Level: Active user level (0 = nobody logged in, 1 = operator level, 2 = supervisor level, 3 = admin level)</p> </li> </ul>"},{"location":"v3/lua/eventlog/#alarm-event","title":"Alarm event","text":"<p>The alarm event is fired, whenever a new alarm is raised or if an alarm state changes. The function signature is as follows:</p> <pre><code>EventLog.Write(ALARM, Status, User1, User2, Text)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li>Status (int): Alarm level (0 = alarm cleared)</li> <li>Text (string): Alarm message</li> </ul>"},{"location":"v3/lua/eventlog/#workflow-event","title":"Workflow event","text":"<p>The workflow event is fired, whenever the workflow state changes. The function signature is as follows:</p> <pre><code>EventLog.Write(WORKFLOW, Status, User1, User2, Text)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li>Status (int): Type code</li> <li>Text (string): Descriptive message</li> </ul>"},{"location":"v3/lua/eventlog/#result-event","title":"Result event","text":"<p>The result event is fired, whenever the result state for the current tool operation changes. The function signature is as follows:</p> <pre><code>EventLog.Write(RESULT, Status, User1, User2, Text)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li>Status (int): Quality code of the result</li> <li>Text (string): currently not used</li> </ul>"},{"location":"v3/lua/eventlog/#sample-code","title":"Sample code","text":""},{"location":"v3/lua/eventlog/#write-events-to-a-logfile","title":"Write events to a logfile","text":"<p>A sample implementaion for logging all events to a file is provides in <code>heEventLog.lua</code> (in the lualib folder).</p>"},{"location":"v3/lua/eventlog/#send-events-over-mqtt","title":"Send events over MQTT","text":"<p>To send the events over MQTT, here is a snippet on how to convert the event data into a json message ready to be published over MQTT.</p> <p>The sample omits the MQTT boilerplate code and focuses on the Eventlog implementation (see luamqttclient for more info).</p> <p><pre><code>local mqtt = require('luamqttclient')\nlocal json = require('json')    \nlocal MqttTopic = 'mytopic/mysubtopic'      -- the MQTT event topic\n-- setup the global eventlog table\nEventLog = {\n}\n-- The init function called from OGS\nEventLog.Init = function()\n--[[\n        initialize MQTT [omitted]\n    ]]\n-- send a MQTT bootup message\nlocal msg = json.encode({type=0,name='COMMON',status=0,text='OGS started'})        \nMC:Publish(MqttTopic, 0, msg)\nreturn true\nend\n-- The Stop function - send a MQTT shutdown message\nEventLog.Stop = function()\n-- send a MQTT shutdown message\nlocal msg = json.encode({type=0,name='COMMON',status=0,text='OGS shutdown'})        \nMC:Publish(MqttTopic, 0, msg)\nend\n-- Define a event parameter/name mapping table\nEventLog.EvtParms = {   -- define custom tags names for the function parameters\n[1] = { name='BARCODE',     'fieldno', 'user1', 'user2', 'code', 'source', 'tag' },\n[2] = { name='INTERACTION', 'status', 'user1', 'user2', 'text', 'jobseq', 'opseq', 'field' },\n[3] = { name='USER_LOGON',  'status', 'user1', 'user2', 'login', 'level' },\n[4] = { name='ALARM',       'severity', 'user1', 'user2', 'message' },\n[5] = { name='WORKFLOW',    'status', 'user1', 'user2', 'message', 'source', 'tag' },\n[6] = { name='RESULT',      'status', 'user1', 'user2', 'code', 'source', 'tag' },\n--[0] = { name='COMMON', 'type', 'status', 'text' },\n--[7] = { name='SOFTWARE_ERROR', 'type', 'status', 'text' },\n}\n-- The Eventlog.Write function is called from OGS whenever a new event occurrs\nEventLog.Write = function (type, ...)\n-- map the parameters/names depending on the event type\nlocal params = EventLog.EvtParms[type]\nlocal t = os.date('*t')\nlocal res = {\ntype = type,\ntimestamp = string.format('%04d-%02d-%02d %02d:%02d:%02d',t.year,t.month,t.day,t.hour,t.min,t.sec),\n}\nres.name = params.name or 'UNKNOWN'\nif params then\nfor i = 2,#arg do\nres[params[i-1]] = arg[i-1]\nend\nend\n-- publish over mqtt\nlocal msg = json.encode(res)        \nMC:Publish(MqttTopic, 0, msg)\nend\n</code></pre> Running this code then generates json messages like the following (login event):</p> <pre><code>{\n\"type\":3,\n\"timestamp\":\"2023-03-31 09:56:00\",\n\"name\":\"USER_LOGON\",\n\"status\":0,\n\"user1\":\"U40003ACC4D\",\n\"user2\":\"\",\n\"login\":\"login\"\n}\n</code></pre>"},{"location":"v3/lua/webbrowser/","title":"Browser","text":""},{"location":"v3/lua/webbrowser/#overview","title":"Overview","text":"<p>The OGS runtime uses up to 4 web browser (Microsoft WebView2) instances. The instances are:</p> <ul> <li><code>StartView</code>: Browser on the start screen</li> <li><code>ProcessView</code>: Browser on the process screen (only visible, if the <code>url</code>-parameter in the job/task is set)</li> <li><code>SidePanel</code>: Browser on the slide-in side panel (requires enabling the sidepanel in <code>station.ini</code>)</li> <li><code>InstructionView</code>: Browser in the instruction view popup (is triggered from LUA, so only visible with custom LUA code)</li> </ul> <p>The OGS infrastructure provides functions to bidirectionally exchange data between the JavaScript code running inside the web browser and the LUA code running inside OGS. There is a LUA function to execute JavaScript code in the webbrowser and a JavaScript bridge, which calls a LUA function (if registered accordingly). To make things a bit easier, starting with OGS V3.0.8510, there is also a JavaScript helper object injected into the page.</p> <p>To implement this functionality, OGS provides the following:</p> <ul> <li>For the LUA side: a global <code>Browser</code> table with functions to manipulate the browser instances</li> <li>For the JavaScript side: <ul> <li>an injected JavaScript helper object, which provides easy to use functions to access the Bridge and send a message string</li> <li>the (lowlevel) JavaScript hostObjects bridge accessibal through the <code>hostObjects</code> interface of the Chromium browser (<code>window.chrome.webview.hostObjects.sync.&lt;instance&gt;</code>, with <code>instance</code> one of the above)</li> </ul> </li> </ul>"},{"location":"v3/lua/webbrowser/#injected-javascript-helper-object","title":"Injected JavaScript helper object","text":"<p>NOTE: Available starting with OGS V3.0.8510.</p> <p>OGS injects a JavaScript <code>OGS</code> object into the page after the \"NavigationComplete\" Event of the Edge Browser. This especially makes using the <code>Bridge</code> to send messages out to the OGS core easier (see JavaScript hostObjects bridge below for details) and also allows overriding some events. The <code>OGS</code>-object provides the following members:</p> <ul> <li><code>getBridgeName(): string</code>: Returns the bridge instance name (which is identical to the browser instance name, e.g. <code>'StartView'</code>).</li> <li><code>SendCmd(cmd: string): boolean</code>: send the <code>cmd</code> string  to the OGS core. The function returns <code>true</code>, if the string was sent correctly. If <code>false</code> is returned, the command was not sent. This usually happens during and shortly after page load (and even for a small time after DocumentComplete), as the Edge bridge host object needs some time to initialize. Best practice is to embed the <code>SendCmd()</code> into a timer started with window.onload() or in the body. An even better option is to implement the OGS.onInit() override (see sample below).</li> <li>event: <code>onInit(url: string)</code>: This function can be implemented on the JavaScript side to get notified when OGS is done loading the webpage (called after the <code>OnNavigateComplete</code>-Event of the Edge browser). This can(should) be used to have a reliable event on when the OGS-Communication is available.</li> <li>event: <code>onShow()</code>: This function can be implemented on the JavaScript side to get notified when the web browser gets visible to the user. This is especially useful for the <code>SidePanel</code> view, as the user can open/close the browser view without reloading the page.</li> <li>event: <code>onHide()</code>: This function can be implemented on the JavaScript side to get notified when the web browser gets visible to the user.</li> </ul> <p>Here is a sample on how to use the <code>OGS</code>-JavaScript helper oject to send a \"hello\"-message after the bridge gets ready:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html &gt;\n&lt;/html&gt;\n&lt;body&gt;\n&lt;!-- whatever content is in the page --&gt;\n&lt;/body&gt;\n&lt;script&gt;\n// Create the OGS object and implement the callbacks/events\nOGS = {};       OGS.onInit = function(url) {\nconsole.log(\"OGS.onInit called: \", url, OGS);\n// if we get here, everyhing is initialized, so now send the 'hello' message\nOGS.SendCmd('hello!');\n}\nOGS.onShow = function OGS_onShow() {\nconsole.log(\"OGS.onShow called!\");\n}\nOGS.onHide = function() {\nconsole.log(\"OGS.onHide called!\");\n}\n&lt;/script&gt;\n</code></pre> <p>An alternative way (without using the OGS object) would be to poll until everything is ready:</p> <pre><code>// Send Hello after the bridge is ready\nfunction SendHello()\nvar timer = window.setInterval( () =&gt; {\nif (OGS) {  // check, if the global OGS object exists\nif (OGS.SendCmd('Hello')) {\n// successfully send, remove the timer\nclearInterval(timer);\n}\n}\n}, 100);    // execute every 100ms until the bridge is ready\nend\nwindow.onload = function() {\nSendHello();\n}\n</code></pre>"},{"location":"v3/lua/webbrowser/#javascript-hostobjects-bridge","title":"JavaScript hostObjects bridge","text":"<p>NOTE: Starting with OGS V3.0.8510, it is recommended to use the JavaScript hostObjects bridge (see previous section) instead. </p> <p>To allow interaction between the JavaScript code running in the Browser and the OGS core, OGS registers a hostObject in the WebView2 browser for the JavaScript side. The registered object is named identically to the browser instance, e.g. <code>StartView</code> and implements a single string property <code>ObjectMessage</code>.</p> <p>To send a string to OGS from JavaScript, simply assign a value to the <code>window.chrome.webview.hostObjects.sync.&lt;instance&gt;.ObjectMessage</code> property (<code>instance</code> is the name of the actual browser instance, e.g. <code>StartView</code>, <code>ProcessView</code>, ..., see above).</p> <p>NOTE: To use the bridge, one has to use the correct <code>&lt;instance&gt;</code>!</p>"},{"location":"v3/lua/webbrowser/#sample-code","title":"Sample code","text":"<pre><code>// send a command string to OGS - from the StartView instance\nfunction sendOgsCommand(cmd)\n{\nif (!window.chrome || !window.chrome.webview\n|| !window.chrome.webview.hostObjects\n|| !window.chrome.webview.hostObjects.sync) {\n// WebView2 is not yet fully initialized\nreturn;     }\nlet ogs = window.chrome.webview.hostObjects.sync.StartView;\nif (ogs) {\nogs.ObjectMessage = cmd;    }\n}\n</code></pre>"},{"location":"v3/lua/webbrowser/#global-browser-table","title":"Global Browser table","text":"<p>OGS exposes the browser instances through the global <code>Browser</code> object. The <code>Browser</code> object implements the following functions:</p> <ul> <li>Navigate: Load a new URL in the web browser</li> <li>ExecJS_nonblocking: Run javascript inside the web browser (asynchronously, not returning a value)</li> <li>RegMsgHandler: Register a LUA callback function to be called when the JavaScript side writes to the object message endpoint.</li> </ul>"},{"location":"v3/lua/webbrowser/#navigate","title":"Navigate","text":"<p>The <code>Browser.Navigate</code> function starts loading a new URL into the given browser instance.</p> <pre><code>Browser.Navigate(instance, url)\n</code></pre>"},{"location":"v3/lua/webbrowser/#parameters","title":"Parameters","text":"<ul> <li>instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') </li> <li>url [string]: Url to navigate the browser instance to (in the standard URL format, e.g. file://filename or https://server/page)</li> </ul>"},{"location":"v3/lua/webbrowser/#sample-code_1","title":"Sample code","text":"<pre><code>-- Navigate the StartView browser to https://www.my-url.com/mypage\nBrowser.Navigate('StartView', 'https://www.my-url.com/mypage')\n</code></pre>"},{"location":"v3/lua/webbrowser/#show","title":"Show","text":"<p>The <code>Browser.Show</code> function is similar to the <code>Browser.Navigate</code> function, but also ensures the webbrowser is actually visible. The actual behaviour depends on the view - e.g. for the <code>SidePanel</code> view, the side panel pops out. For the <code>ProcessView</code> view, this switches from the image-view to the web view.</p> <pre><code>local oldUrl = Browser.Show(instance, url)\n</code></pre>"},{"location":"v3/lua/webbrowser/#parameters_1","title":"Parameters","text":"<ul> <li>instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') </li> <li>url [string]: Url to navigate the browser instance to (in the standard URL format, e.g. file://filename or https://server/page)</li> </ul>"},{"location":"v3/lua/webbrowser/#return-value","title":"Return value","text":"<p>The function returns the \"current\" URL of the webbrowser (the URL before changing to the given one). This can be used to return to the previous URL after hiding the browser.</p>"},{"location":"v3/lua/webbrowser/#sample-code_2","title":"Sample code","text":"<pre><code>-- Make the SidePanel visible and navigate the\n-- web browser to https://www.my-url.com/mypage\nlocal oldUrl = Browser.Show('SidePanel', 'https://www.my-url.com/mypage')\n</code></pre>"},{"location":"v3/lua/webbrowser/#hide","title":"Hide","text":"<p>The <code>Browser.Hide</code> function is complementary to the <code>Browser.Show</code> function - it closes the browser view (only relevant for <code>SidePanel</code> and <code>ProcessView</code>).</p> <pre><code>Browser.Hide(instance)\n</code></pre>"},{"location":"v3/lua/webbrowser/#parameters_2","title":"Parameters","text":"<ul> <li>instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') </li> </ul>"},{"location":"v3/lua/webbrowser/#sample-code_3","title":"Sample code","text":"<pre><code>-- Hide the SidePanel\nBrowser.Hide('SidePanel')\n</code></pre>"},{"location":"v3/lua/webbrowser/#regmsghandler","title":"RegMsgHandler","text":"<p>The <code>Browser.RegMsgHandler</code> function registers or unregisters a LUA function to be called whenever the JavaScript running in the browser writes a message to the hostObject bridge <code>OGS.ObjectMessage</code> property.</p> <p>NOTE: Calling the function mutliple times with the same url parameter  will replace a previously registered handler for the same url.</p>"},{"location":"v3/lua/webbrowser/#function-signature","title":"Function signature","text":"<pre><code>-- Register the callback function\nfn, err = Browser.RegMsgHandler(instance, callbackfn, url)\n</code></pre>"},{"location":"v3/lua/webbrowser/#parameters_3","title":"Parameters","text":"<ul> <li> <p>instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') </p> </li> <li> <p>callbackfn [function]: LUA function to be called when the JavaScript code writes a string to the <code>OGS.ObjectMessage</code> hostObject. If callbackfn is <code>nil</code>, then the current registration is removed. The callback function has the following signature:</p> <pre><code>callbackfn(instance, objectMessage)\n</code></pre> <p><code>instance</code> [string] is the web browsers instance name (e.g. 'StartView') and <code>objectMessage</code> [string] the text which was written to the <code>OGS.ObjectMessage</code> property of the hostObject bridge from the JavaScript side.</p> </li> <li> <p>url [string or nil]: The optional <code>url</code> parameter allows registering seperate message handlers for different URLs shown in the browser. This is especially handy for the <code>SidePanel</code> view, where typically different pages are viewed (see Browser.show(...url...) above). If the <code>url</code> parameter is missing (on nil), then the handler is registered globally (for the given browser instance).</p> </li> </ul>"},{"location":"v3/lua/webbrowser/#return-values","title":"Return values","text":"<p>If the function was executed successfully, the callbackfn is returned as the first return value. Else nil is returned and the second return value has an error message string (wrong parameters or unknown instance).</p>"},{"location":"v3/lua/webbrowser/#sample-code_4","title":"Sample code","text":"<pre><code>local function callbackfn(instance, objectMessage)\n-- do whatever you want to do here if the javascript \n-- code writes the OGS.ObjectMessage property\nend\n-- Register a LUA function to be called from the JavaScript side\nBrowser.RegMsgHandler('StartView', callbackfn)\n</code></pre>"},{"location":"v3/lua/webbrowser/#execjs_nonblocking","title":"ExecJS_nonblocking","text":"<p>The <code>Browser.ExecJS_nonblocking</code> executes JavaScript code in the web browser instance.</p> <pre><code>Browser.ExecJS_nonblocking(instance, jstext)\n</code></pre>"},{"location":"v3/lua/webbrowser/#parameters_4","title":"Parameters","text":"<ul> <li>instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') </li> <li>jstext [string]: JavaScript string to execute in the browser. Note that this must be valid JavaScript code. </li> </ul> <p>NOTES: </p> <ul> <li>When passing strings through the function, make sure to properly escape them!</li> <li>Best practice is to write a JavaScript function in the web page and only call it through this function.</li> <li>You can serialize LUA objects to a JSON string and pass this through the function. The JavaScript side can then easily deserialize it.</li> <li>You can only call Javascript functions defined in the global scope from the LUA/OGS side. Make sure to either register them in a global object (e.g. add them to the OGS object (best), to window or to globalThis) .</li> </ul>"},{"location":"v3/lua/webbrowser/#sample-code_5","title":"Sample code","text":"<p>LUA side:</p> <pre><code>-- define which browser view to use\nlocal instance = 'StartView'\n-- define a function to be called from JavaScript\nlocal callbackfn = function(instance, msg)\nXTRACE(16, \"I am called from Javascript: msg=\" .. msg)\nend\n-- Register (global) callback for the browser instance\nBrowser.RegMsgHandler(instance, callbackfn)\n-- Build a JavaScript command, call the function \"OGS.myFunction\" with\n-- some JSON text\nlocal param = '{ \"cmd\": \"showmessage\" }'\nlocal command = \"OGS.myFunction(\"..param..\");\"\n-- Call the JavaScript function in the browser instance\nBrowser.ExecJS_nonblocking(instance, command)\n</code></pre> <p>Javascript side (for the StartView browser window):</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html &gt;\n&lt;/html&gt;\n&lt;body&gt;\n&lt;!-- whatever content is in the page --&gt;\n&lt;/body&gt;\n&lt;script&gt;\n// Create the OGS object and implement the callbacks/events\nOGS = {};       OGS.onInit = function(url) {\n// if we get here, everyhing is initialized, so now send the 'hello' message\nOGS.SendCmd('hello!');\n}\nOGS.myFunction = function(params) {\n// This function was called from LUA code\nconsole.log(\"OGS.myFunction called!\", params);\n// Now call back into OGS and return a complex object\nvar retval = { cmd: 'test', params: { p1: 1, p2: 'string' } };\nOGS.SendCmd(JSON.stringify(retval));\n}\n&lt;/script&gt;\n</code></pre>"},{"location":"v3/lua/webserver/","title":"Webserver","text":""},{"location":"v3/lua/webserver/#overview","title":"Overview","text":"<p>The OGS runtime uses the Microsoft Windows builtin http.sys web server to server static pages and dynamic pages. The dynamic pages are implemented through LUA scripting and makes it possible to flexibly implement web services like OpenAPI / REST services or others.</p> <p>A typical use case is to provide a REST interface for third-party systems to connect them to OGS, another is to implement backend logic for a single page application web page frontend running inside OGS (see also OGS Webbrowser LUA interface).</p> <p>The web server LUA api works by registering LUA callback functions for specific URL prefixes, which are then called by the web server, whenever the given URL is requested from a web client.</p>"},{"location":"v3/lua/webserver/#prerequisites","title":"Prerequisites","text":"<p>To use the LUA web server API, the web server must be enabled through <code>station.ini</code> (in the <code>[WebServer]</code> section) and the Microsoft <code>http.sys</code> web server must be configured accordingly (a URL reservation must be activated through the <code>netsh http add urlacl ...</code> command).</p> <p>By default the, installer registers a web endpoint at http://localhost:59990, so the endpoint is only accessible from the local machine and only for a locally logged on user.</p> <p>To access the web server from the outside, make sure to change the listen address in the <code>station.ini</code> file, the URL reservation through <code>netsh http ...</code> and check the firewall settings. </p>"},{"location":"v3/lua/webserver/#global-webserver-table","title":"Global Webserver table","text":"<p>OGS exposes the web server through the global <code>Webserver</code> object. The <code>Webserver</code> object implements the following functions:</p> <ul> <li>RegUrl: Register a LUA callback function to be called when a specific URL prefix is requested from the web server.</li> </ul>"},{"location":"v3/lua/webserver/#regurl","title":"RegUrl","text":"<p>The <code>Webserver.RegUrl</code> function registers or unregisters a LUA function to be called whenever the web server receives a request to the given URL prefix.</p> <pre><code>fn, err = Webserver.RegUrl(prefix, callbackfn)\n</code></pre>"},{"location":"v3/lua/webserver/#parameters","title":"Parameters","text":"<ul> <li>prefix [string]: Path prefix to match against when checking the request URL. Note that this only checks for the path part of the URL (e.g. '/home'). </li> <li> <p>callbackfn [function]: LUA function to be called when a web request matches the prefix. The callback function has the following signature:</p> <pre><code>table = callbackfn(reqpath, reqparams, verb, body)\n</code></pre> <p>Where reqpath [string] is the full request path, (e.g. '/api/items'), reqparams [string] the request parameters (e.g. '?max=10&amp;class=5'), verb [integer] the request type (GET, PUT, POST, DELETE) and body [string] the body (binaty) string value (only for POST and PUT).</p> <p>The callback function should return a response table with the required parameters to build the http response (optional body).</p> <p>[Datails tbd.]</p> </li> </ul>"},{"location":"v3/lua/webserver/#return-values","title":"Return values","text":"<p>If the function was executed successfully, the callbackfn is returned as the first return value. Else nil is returned and the second return value has an error message string (wrong parameters or unknown instance).</p>"},{"location":"v3/lua/webserver/#sample-code","title":"Sample code","text":"<pre><code>local function handlerfn(reqpath, reqparams, verb, body)\n-- process the request, return the response object (or nil\n-- if this request is not handled) \nreturn nil\nend\n-- Register a LUA function to be called whenever a web request to /api/lua\n-- is made\nBrowser.RegMsgHandler('/api/lua', handlerfn)\n</code></pre>"}]}