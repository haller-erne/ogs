


### Single channel tool

The signals used in this scenario are:

- CW
- CCW
- CcwSel
- CwLock, CcwLock
- CwAnd, CcwAnd


## OpenProtocol IO access

Aditional I/O signals (8 in, 8 out) can be accessed through OpenProtocol and mapped to any I/O through the PLC assignment table. 

In CS351, the system actually provides 16 inputs and 16 outputs (see the following screenshot). These are cyclically read/written by OGS:

![alt text](resources/cs351-custom-io.png)

However, only a subset is usable as custom I/O, as parts are required for operating the tool:

- CS351 Inputs OP2.1-2.2: Used by OGS for ActEn and CcwLock/CcwAnd
- CS351 Outputs OP1.0-OP1.7: Used for tool status inputs

To access the custom IO signals from LUA, the following is required:

1. Set `EXTERNAL_IO_OFFSET=` in station.ini in the `[OPENPROTO]` section to a non-zero value. The value defines the actual offset, where the LUA output signal start - usually this is set to `EXTERNAL_IO_OFFSET=2`, so all LUA output signals starting from OP2.3 (CS351 inputs) can be controlled.

2. Cyclically call to `ToolIoExchange()` from LUA.

Note, that the number of available outputs vary according to the `EXTERNAL_IO_OFFSET=` definition. The offset given moves the process data image for the LUA function accordingly - with offset=2, `bit 0` of the data returend from the LUA function is then `OP 2.3` (as shown in the screenshot above).

The input data (for the LUA function) always reports all available 16 inputs, i.e. the custom signals are usually in the upper 8 bits of the returned data (mapping to `OP 2.0 - OP 2.7`).

## LUA ToolIoExchange() function


| Function Name | Return Type | Description | Tags |
| -------- | ----------- | ----------- | ---- |
| `ToolIoExchange(tool:integer, output:integer)` | `input:integer, error:string` | Writes `output` data to the `tool` interface and returns the current `input` data. If and error occurs, then `error` is non-nil and provides an error message. | None |


## Sample LUA code

Here is some sample code, mirroring the custom inputs to the custom outputs:

``` lua
-- station_io.lua

-- Requirements:
-- * Define Channel_01 as OpenProtocol tool (CS351/KE350) in station.ini
-- * Set EXTERNAL_IO_OFFSET=2 in [OPENPROTO] section

-- Handle the OpenProtocol IOs
local prev_output = nil
local prev_input = nil
local output = 0
local channel = 1           -- use Channel_01 
local tool_error = nil

-- StatePoll is called cyclically
local function OnStatePoll(info)

    local wf = info.Workflow

    -- Cyclically update the OpenProtocol I/O data
    local input, err = ToolIOExchange(channel, output)
    if err then
        if not tool_error then
            SetLuaAlarm('ToolIO', -2, param_as_str(err))
            XTRACE(1, param_as_str(err))
            tool_error = true
        end
        return nil
    else
        if tool_error then
            ResetLuaAlarm('ToolIO')
            XTRACE(8, 'Tool3 IO running!')
            tool_error = nil
        end
        if output ~= prev_output or input ~= prev_input then
            XTRACE(16, string.format('IO changed. Input: %02Xh, Output: %02Xh', input, output))
            prev_output = output
            prev_input  = input
        end
    end

    -- mirror input to output - note: custom inputs are the high byte!
    output = input / 256

end

if StatePollFunctions ~= nil then
	StatePollFunctions.add(OnStatePoll)
end


```