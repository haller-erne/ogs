{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OGS - Operator guidance system Scope This documentation provides low-level infomation about the OGS software. The main purpose is to document the API interfaces (mostly LUA scripting) and show how everything fits together. This allows advanced users and implementors to unlock the full potential of OGS by modifying and extending the software. NOTE: This documentation is valid for OGS V3. As V3 is not yet released, some of the information might still change before the final release. Overview The documentation consist of the following...","title":"Home"},{"location":"#ogs-operator-guidance-system","text":"","title":"OGS - Operator guidance system"},{"location":"#scope","text":"This documentation provides low-level infomation about the OGS software. The main purpose is to document the API interfaces (mostly LUA scripting) and show how everything fits together. This allows advanced users and implementors to unlock the full potential of OGS by modifying and extending the software. NOTE: This documentation is valid for OGS V3. As V3 is not yet released, some of the information might still change before the final release.","title":"Scope"},{"location":"#overview","text":"The documentation consist of the following...","title":"Overview"},{"location":"libs/lua-ads/","text":"","title":"ADS communication (TwinCat, Nexeed, Beckhoff)"},{"location":"libs/lua-modbus/","text":"","title":"Modbus/TCP/UDP communication"},{"location":"libs/lua-opcua/","text":"","title":"OpcUA communication"},{"location":"tools/","text":"Tool configuration Overview station.ini","title":"Overview"},{"location":"tools/#tool-configuration","text":"","title":"Tool configuration"},{"location":"tools/#overview","text":"","title":"Overview"},{"location":"tools/#stationini","text":"","title":"station.ini"},{"location":"tools/remote-tool/","text":"RemoteTool OGS supports connecting tools over a ToolGateway . This enables advanced tool management scenarios, e.g. \"roaming\" tools between multiple stations. Using the RemoteTool driver requires a ToolGateway running on a server - the server then actually controls the tool, whereas the OGS stations only communication with the ToolGateway . This allows delegating tool management to the central ToolGateway . For each tool managed through the ToolGateway , OGS only uses the a generic RemoteTool in its local configuration, the ToolGateway then has the tool-specific configuration (like e.g. OpenProtocol tools ). Installation The RemoteTool driver is implemented in RemoteTool.dll . To use any RemoteTool tool, the driver must be loaded in the [TOOL_DLL] section of the projects station.ini configuration file (see also Tool configuration ). To enable the driverin station.ini, set it as follows: [TOOL_DLL] RemoteTool.dll=1 The overall parameters for the RemoteTool driver are configured in the \u00b4[RemoteTool] section. This is basically used to configure the ToolGateway` connection parameters, here is a sample setup: [RemoteTool] ToolGateway_Addr=mytoolgateway.mycompany.com ToolGateway_Port= For more information about the driver parameters, see Driver Parameters below. Tool registration and configuration All RemoteTool -tools are registered in the [CHANNELS] section of the projects station.ini file. The [CHANNELS] section only defines a channel number to channel name mapping - the channel/tool specific settings are then configured in a seperate section defined by the channel name. Inside the section, a reference to the RemoteTool driver then links driver and channel accordingly. The overall layout is therefore as follows (sample is for channel 2): [CHANNELS] # Map the channel/tool 2 to the 'RemoteTool_Nexo1'-section 2=RemoteTool_Nexo1 [RemoteTool_Nexo1] # link to the RemoteTool driver DRIVER=RemoteTool # more channel/tool specific parameters for this tool/driver Please see Channel/tool parameter reference below for more information about the available parameters. Channel/tool parameter reference Currently, there are no channel/tool-specific parameters needed (other than specifying the DRIVER=RemoteTool ) to use this driver. All concrete tool communication settings are to be configured on the ToolGateway server side. Driver parameter reference The driver parameters are defined in the [RemoteTool] section in the projects station.ini . The following parameters are available: ToolGateway_Addr IP address or hostname of the tool gateway. ToolGateway_Port (optional) Port number to use for connecting to the tool gateway. If not given, the driver tries to use the RPC endpoint mapper using the service UUID to resolve the connection endpoint (might require additional firewall settings).","title":"Remote Tool"},{"location":"tools/remote-tool/#remotetool","text":"OGS supports connecting tools over a ToolGateway . This enables advanced tool management scenarios, e.g. \"roaming\" tools between multiple stations. Using the RemoteTool driver requires a ToolGateway running on a server - the server then actually controls the tool, whereas the OGS stations only communication with the ToolGateway . This allows delegating tool management to the central ToolGateway . For each tool managed through the ToolGateway , OGS only uses the a generic RemoteTool in its local configuration, the ToolGateway then has the tool-specific configuration (like e.g. OpenProtocol tools ).","title":"RemoteTool"},{"location":"tools/remote-tool/#installation","text":"The RemoteTool driver is implemented in RemoteTool.dll . To use any RemoteTool tool, the driver must be loaded in the [TOOL_DLL] section of the projects station.ini configuration file (see also Tool configuration ). To enable the driverin station.ini, set it as follows: [TOOL_DLL] RemoteTool.dll=1 The overall parameters for the RemoteTool driver are configured in the \u00b4[RemoteTool] section. This is basically used to configure the ToolGateway` connection parameters, here is a sample setup: [RemoteTool] ToolGateway_Addr=mytoolgateway.mycompany.com ToolGateway_Port= For more information about the driver parameters, see Driver Parameters below.","title":"Installation"},{"location":"tools/remote-tool/#tool-registration-and-configuration","text":"All RemoteTool -tools are registered in the [CHANNELS] section of the projects station.ini file. The [CHANNELS] section only defines a channel number to channel name mapping - the channel/tool specific settings are then configured in a seperate section defined by the channel name. Inside the section, a reference to the RemoteTool driver then links driver and channel accordingly. The overall layout is therefore as follows (sample is for channel 2): [CHANNELS] # Map the channel/tool 2 to the 'RemoteTool_Nexo1'-section 2=RemoteTool_Nexo1 [RemoteTool_Nexo1] # link to the RemoteTool driver DRIVER=RemoteTool # more channel/tool specific parameters for this tool/driver Please see Channel/tool parameter reference below for more information about the available parameters.","title":"Tool registration and configuration"},{"location":"tools/remote-tool/#channeltool-parameter-reference","text":"Currently, there are no channel/tool-specific parameters needed (other than specifying the DRIVER=RemoteTool ) to use this driver. All concrete tool communication settings are to be configured on the ToolGateway server side.","title":"Channel/tool parameter reference"},{"location":"tools/remote-tool/#driver-parameter-reference","text":"The driver parameters are defined in the [RemoteTool] section in the projects station.ini . The following parameters are available:","title":"Driver parameter reference"},{"location":"tools/remote-tool/#toolgateway_addr","text":"IP address or hostname of the tool gateway.","title":"ToolGateway_Addr"},{"location":"tools/remote-tool/#toolgateway_port","text":"(optional) Port number to use for connecting to the tool gateway. If not given, the driver tries to use the RPC endpoint mapper using the service UUID to resolve the connection endpoint (might require additional firewall settings).","title":"ToolGateway_Port"},{"location":"tools/openprotocol/","text":"OpenProtocol tools OGS supports connecting tools with OpenProtocol interface. As tools differ in functionality and also different tool vendors implement the OpenProtocol specification in slightly different ways, OGS has special protocol handlers for the following tools: Rexroth Nexo and Nexo 2 wireless tools (for more information, see Nexo OpenProtocol ) Rexroth CS351 and KE350 system tools (for more information, see System 350 OpenProtocol ) GWK Operator+ torque wrenches (for more information, see GWK Operator+ OpenProtocol ) Crane TCI torque wrenches (for more information, see Crane OpenProtocol ) Gehmeyr Exact Wifi tools (for more information, see Gehmeyr OpenProtocol ) The overall configuration for these tools is similar and the actual driver has the same set of configuration parameters - described on this page. Installation The OpenProtocol driver is implemented in OpConn.dll . To use any OpenProtocol tool, the driver must be loaded in the [TOOL_DLL] section of the projects station.ini configuration file (see also Tool configuration ). Tool registration and configuration All OpenProtocol -tools are registered in the [OPENPROTO] section of the projects station.ini file. The [OPENPROTO] section mixes the tool parameters and the channel mapping (due to historic reasons) by combining the channel number and the parameter name/value in the station.ini entry. Each parameter is prefixed with the channel number and followed by parameter name as follows: CHANNEL_<two-digit channel>_<param name>=<param value> Where - <two-digit channel> is the channel number in the range 01...99 (the channel number maps 1:1 to the tool number from the workflow configuration) - <param name> is the parameter name (see Channel parameter reference ) - <param value> is the actual parameter value for the given parameter In addition to the channel-specific parameters, there are also shared parameters. These act as default parameters for the channel-specific settings and can be overridden by the channel specific values. For more details on the shared parameters, see Shared parameter reference ) below . A sample OpenProtocol tool configuration (channel 01) would therefore look similar to the following: [OPENPROTO] # Shared/default parameters PORT=4545 # Channel/Tool 1 parameters CHANNEL_01=10.10.2.163 CHANNEL_01_TYPE=NEXO CHANNEL_01_CHECK_TIME_ENABLED=1 CHANNEL_01_NEXONAR_CHANNEL=6 CHANNEL_01_CURVE_REQUEST=1 Shared parameter reference PORT (optional, defaults to 4545) EXTERNAL_IO_OFFSET CHECK_TIME_INTERVAL and TIME_TOLERANCE EXTERNAL_IO_OFFSET Channel parameter reference For specific information about a tools settings or the tools configuration needed (on the tool side), please see the tool-specific information. In general, the following parameters are available for a OpenProtocol -tool: Connection information PORT (optional, defaults to the shared parameter value) TYPE (mandatory) CCW_ACK PARAMS ALIVEXMTT SHOWALIVE RSPTIMEOUT BARCODE_MID0051_REV CHECK_EXT_COND APPL_START CURVE_REQUEST CHECK_TIME_ENABLED IGNORE_ID","title":"Overview"},{"location":"tools/openprotocol/#openprotocol-tools","text":"OGS supports connecting tools with OpenProtocol interface. As tools differ in functionality and also different tool vendors implement the OpenProtocol specification in slightly different ways, OGS has special protocol handlers for the following tools: Rexroth Nexo and Nexo 2 wireless tools (for more information, see Nexo OpenProtocol ) Rexroth CS351 and KE350 system tools (for more information, see System 350 OpenProtocol ) GWK Operator+ torque wrenches (for more information, see GWK Operator+ OpenProtocol ) Crane TCI torque wrenches (for more information, see Crane OpenProtocol ) Gehmeyr Exact Wifi tools (for more information, see Gehmeyr OpenProtocol ) The overall configuration for these tools is similar and the actual driver has the same set of configuration parameters - described on this page.","title":"OpenProtocol tools"},{"location":"tools/openprotocol/#installation","text":"The OpenProtocol driver is implemented in OpConn.dll . To use any OpenProtocol tool, the driver must be loaded in the [TOOL_DLL] section of the projects station.ini configuration file (see also Tool configuration ).","title":"Installation"},{"location":"tools/openprotocol/#tool-registration-and-configuration","text":"All OpenProtocol -tools are registered in the [OPENPROTO] section of the projects station.ini file. The [OPENPROTO] section mixes the tool parameters and the channel mapping (due to historic reasons) by combining the channel number and the parameter name/value in the station.ini entry. Each parameter is prefixed with the channel number and followed by parameter name as follows: CHANNEL_<two-digit channel>_<param name>=<param value> Where - <two-digit channel> is the channel number in the range 01...99 (the channel number maps 1:1 to the tool number from the workflow configuration) - <param name> is the parameter name (see Channel parameter reference ) - <param value> is the actual parameter value for the given parameter In addition to the channel-specific parameters, there are also shared parameters. These act as default parameters for the channel-specific settings and can be overridden by the channel specific values. For more details on the shared parameters, see Shared parameter reference ) below . A sample OpenProtocol tool configuration (channel 01) would therefore look similar to the following: [OPENPROTO] # Shared/default parameters PORT=4545 # Channel/Tool 1 parameters CHANNEL_01=10.10.2.163 CHANNEL_01_TYPE=NEXO CHANNEL_01_CHECK_TIME_ENABLED=1 CHANNEL_01_NEXONAR_CHANNEL=6 CHANNEL_01_CURVE_REQUEST=1","title":"Tool registration and configuration"},{"location":"tools/openprotocol/#shared-parameter-reference","text":"","title":"Shared parameter reference"},{"location":"tools/openprotocol/#port","text":"(optional, defaults to 4545)","title":"PORT"},{"location":"tools/openprotocol/#external_io_offset","text":"","title":"EXTERNAL_IO_OFFSET"},{"location":"tools/openprotocol/#check_time_interval-and-time_tolerance","text":"","title":"CHECK_TIME_INTERVAL and TIME_TOLERANCE"},{"location":"tools/openprotocol/#external_io_offset_1","text":"","title":"EXTERNAL_IO_OFFSET"},{"location":"tools/openprotocol/#channel-parameter-reference","text":"For specific information about a tools settings or the tools configuration needed (on the tool side), please see the tool-specific information. In general, the following parameters are available for a OpenProtocol -tool:","title":"Channel parameter reference"},{"location":"tools/openprotocol/#connection-information","text":"","title":"Connection information"},{"location":"tools/openprotocol/#port_1","text":"(optional, defaults to the shared parameter value)","title":"PORT"},{"location":"tools/openprotocol/#type","text":"(mandatory)","title":"TYPE"},{"location":"tools/openprotocol/#ccw_ack","text":"","title":"CCW_ACK"},{"location":"tools/openprotocol/#params","text":"","title":"PARAMS"},{"location":"tools/openprotocol/#alivexmtt","text":"","title":"ALIVEXMTT"},{"location":"tools/openprotocol/#showalive","text":"","title":"SHOWALIVE"},{"location":"tools/openprotocol/#rsptimeout","text":"","title":"RSPTIMEOUT"},{"location":"tools/openprotocol/#barcode_mid0051_rev","text":"","title":"BARCODE_MID0051_REV"},{"location":"tools/openprotocol/#check_ext_cond","text":"","title":"CHECK_EXT_COND"},{"location":"tools/openprotocol/#appl_start","text":"","title":"APPL_START"},{"location":"tools/openprotocol/#curve_request","text":"","title":"CURVE_REQUEST"},{"location":"tools/openprotocol/#check_time_enabled","text":"","title":"CHECK_TIME_ENABLED"},{"location":"tools/openprotocol/#ignore_id","text":"","title":"IGNORE_ID"},{"location":"v3/getting-started/","text":"","title":"Getting Started"},{"location":"v3/lua/webbrowser/","text":"Browser Overview The OGS runtime uses up to 4 web browser (Microsoft WebView2) instances. The instances are: - StartView : Browser on the start screen - ProcessView : Browser on the process screen (only visible, if the url -parameter in the job/task is set) - SidePanel : Browser on the slide-in side panel (requires enabling the sidepanel in station.ini ) - InstructionView : Browser in the instruction view popup (is triggered from LUA, so only visible with custom LUA code) The OGS infrastructure provides functions to bidirectionally exchange data between the JavaScript code running inside the web browser and the LUA code running inside OGS. There is a LUA function to execute JavaScript code in the webbrowser and a JavaScript bride, which calls a LUA function (if registered accordingly). To implement this functionality, OGS provides the following: - For the JavaScript side: a bridge implementation accessibal through the hostObjects interface of the Chromium browser ( window.chrome.webview.hostObjects.sync.OGS ) - For the LUA side: a global Browser table with functions to manipulate the browser instances JavaScript hostObjects bridge OGS registers a hostObject in the WebView2 browser for the JavaScript side. The registered object is named OGS and implements a single string property ObjectMessage . To send a string to OGS from JavaScript, simply assign a value to the window.chrome.webview.hostObjects.sync.OGS.ObjectMessage property. Sample code // send a command string to OGS function sendOgsCommand(cmd) { if (!window.chrome || !window.chrome.webview || !window.chrome.webview.hostObjects || !window.chrome.webview.hostObjects.sync) { // WebView2 is not yet fully initialized return; } let ogs = window.chrome.webview.hostObjects.sync.OGS; if (ogs) { ogs.ObjectMessage = cmd; } } Global Browser table OGS exposes the browser instances through the global Browser object. The Browser object implements the following functions: Navigate : Load a new URL in the web browser ExecJS_nonblocking : Run javascript inside the web browser (asynchronously, not returning a value) RegMsgHandler : Register a LUA callback function to be called when the JavaScript side writes to the object message endpoint. Navigate The Browser.Navigate function starts loading a new URL into the given browser instance. Browser.Navigate(instance, url) Parameters instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') url [string]: Url to navigate the browser instance to (in the standard URL format, e.g. file://filename or https://server/page) Sample code -- Navigate the StartView browser to https://www.my-url.com/mypage Browser.Navigate('StartView', 'https://www.my-url.com/mypage') RegMsgHandler The Browser.RegMsgHandler function registers or unregisters a LUA function to be called whenever the JavaScript running in the browser writes a message to the hostObject bridge OGS.ObjectMessage property. -- Register the callback function fn, err = Browser.RegMsgHandler(instance, callbackfn) Parameters instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') callbackfn [function]: LUA function to be called when the JavaScript code writes a string to the OGS.ObjectMessage hostObject. If callbackfn is nil , then the current registration is removed. The callback function has the following signature: callbackfn(instance, objectMessage) Where instance [string] is the web browsers instance name (e.g. 'StartView') and objectMessage [string] the text which was written to the OGS.ObjectMessage property of the hostObject bridge from the JavaScript side. Return values If the function was executed successfully, the callbackfn is returned as the first return value. Else nil is returned and the second return value has an error message string (wrong parameters or unknown instance). Sample code local function callbackfn(instance, objectMessage) -- do whatever you want to do here if the javascript -- code writes the OGS.ObjectMessage property end -- Register a LUA function to be called from the JavaScript side Browser.RegMsgHandler('StartView', callbackfn) ExecJS_nonblocking The Browser.ExecJS_nonblocking executes JavaScript code in the web browser instance. Browser.ExecJS_nonblocking(instance, jstext) Parameters instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') jstext [string]: JavaScript string to execute in the browser. Note that this must be valid JavaScript code. NOTES : When passing strings through the function, make sure to propery escape them! Best practice is to write a JavaScript function in the web page and only call it through this function. You can serialize LUA objects to a JSON string and pass this through the function. The JavaScript side can then easily deserialize it. Sample code -- Build a JavaScript command, call the function \"my_function\" with -- some JSON text local param = '{ \"cmd\": \"showmessage\" }' local command = \"my_function(\"..param..\");\" -- Call the JavaScript function in the StartView browser Browser.ExecJS_nonblocking('StartView', command)","title":"Web browsers"},{"location":"v3/lua/webbrowser/#browser","text":"","title":"Browser"},{"location":"v3/lua/webbrowser/#overview","text":"The OGS runtime uses up to 4 web browser (Microsoft WebView2) instances. The instances are: - StartView : Browser on the start screen - ProcessView : Browser on the process screen (only visible, if the url -parameter in the job/task is set) - SidePanel : Browser on the slide-in side panel (requires enabling the sidepanel in station.ini ) - InstructionView : Browser in the instruction view popup (is triggered from LUA, so only visible with custom LUA code) The OGS infrastructure provides functions to bidirectionally exchange data between the JavaScript code running inside the web browser and the LUA code running inside OGS. There is a LUA function to execute JavaScript code in the webbrowser and a JavaScript bride, which calls a LUA function (if registered accordingly). To implement this functionality, OGS provides the following: - For the JavaScript side: a bridge implementation accessibal through the hostObjects interface of the Chromium browser ( window.chrome.webview.hostObjects.sync.OGS ) - For the LUA side: a global Browser table with functions to manipulate the browser instances","title":"Overview"},{"location":"v3/lua/webbrowser/#javascript-hostobjects-bridge","text":"OGS registers a hostObject in the WebView2 browser for the JavaScript side. The registered object is named OGS and implements a single string property ObjectMessage . To send a string to OGS from JavaScript, simply assign a value to the window.chrome.webview.hostObjects.sync.OGS.ObjectMessage property.","title":"JavaScript hostObjects bridge"},{"location":"v3/lua/webbrowser/#sample-code","text":"// send a command string to OGS function sendOgsCommand(cmd) { if (!window.chrome || !window.chrome.webview || !window.chrome.webview.hostObjects || !window.chrome.webview.hostObjects.sync) { // WebView2 is not yet fully initialized return; } let ogs = window.chrome.webview.hostObjects.sync.OGS; if (ogs) { ogs.ObjectMessage = cmd; } }","title":"Sample code"},{"location":"v3/lua/webbrowser/#global-browser-table","text":"OGS exposes the browser instances through the global Browser object. The Browser object implements the following functions: Navigate : Load a new URL in the web browser ExecJS_nonblocking : Run javascript inside the web browser (asynchronously, not returning a value) RegMsgHandler : Register a LUA callback function to be called when the JavaScript side writes to the object message endpoint.","title":"Global Browser table"},{"location":"v3/lua/webbrowser/#navigate","text":"The Browser.Navigate function starts loading a new URL into the given browser instance. Browser.Navigate(instance, url)","title":"Navigate"},{"location":"v3/lua/webbrowser/#parameters","text":"instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') url [string]: Url to navigate the browser instance to (in the standard URL format, e.g. file://filename or https://server/page)","title":"Parameters"},{"location":"v3/lua/webbrowser/#sample-code_1","text":"-- Navigate the StartView browser to https://www.my-url.com/mypage Browser.Navigate('StartView', 'https://www.my-url.com/mypage')","title":"Sample code"},{"location":"v3/lua/webbrowser/#regmsghandler","text":"The Browser.RegMsgHandler function registers or unregisters a LUA function to be called whenever the JavaScript running in the browser writes a message to the hostObject bridge OGS.ObjectMessage property. -- Register the callback function fn, err = Browser.RegMsgHandler(instance, callbackfn)","title":"RegMsgHandler"},{"location":"v3/lua/webbrowser/#parameters_1","text":"instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') callbackfn [function]: LUA function to be called when the JavaScript code writes a string to the OGS.ObjectMessage hostObject. If callbackfn is nil , then the current registration is removed. The callback function has the following signature: callbackfn(instance, objectMessage) Where instance [string] is the web browsers instance name (e.g. 'StartView') and objectMessage [string] the text which was written to the OGS.ObjectMessage property of the hostObject bridge from the JavaScript side.","title":"Parameters"},{"location":"v3/lua/webbrowser/#return-values","text":"If the function was executed successfully, the callbackfn is returned as the first return value. Else nil is returned and the second return value has an error message string (wrong parameters or unknown instance).","title":"Return values"},{"location":"v3/lua/webbrowser/#sample-code_2","text":"local function callbackfn(instance, objectMessage) -- do whatever you want to do here if the javascript -- code writes the OGS.ObjectMessage property end -- Register a LUA function to be called from the JavaScript side Browser.RegMsgHandler('StartView', callbackfn)","title":"Sample code"},{"location":"v3/lua/webbrowser/#execjs_nonblocking","text":"The Browser.ExecJS_nonblocking executes JavaScript code in the web browser instance. Browser.ExecJS_nonblocking(instance, jstext)","title":"ExecJS_nonblocking"},{"location":"v3/lua/webbrowser/#parameters_2","text":"instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') jstext [string]: JavaScript string to execute in the browser. Note that this must be valid JavaScript code. NOTES : When passing strings through the function, make sure to propery escape them! Best practice is to write a JavaScript function in the web page and only call it through this function. You can serialize LUA objects to a JSON string and pass this through the function. The JavaScript side can then easily deserialize it.","title":"Parameters"},{"location":"v3/lua/webbrowser/#sample-code_3","text":"-- Build a JavaScript command, call the function \"my_function\" with -- some JSON text local param = '{ \"cmd\": \"showmessage\" }' local command = \"my_function(\"..param..\");\" -- Call the JavaScript function in the StartView browser Browser.ExecJS_nonblocking('StartView', command)","title":"Sample code"},{"location":"v3/lua/webserver/","text":"Webserver Overview The OGS runtime uses the Microsoft Windows builtin http.sys web server to server static pages and dynamic pages. The dynamic pages are implemented through LUA scripting and makes it possible to flexibly implement web services like OpenAPI / REST services or others. A typical use case is to provide a REST interface for third-party systems to connect them to OGS, another is to implement backend logic for a single page application web page frontend running inside OGS (see also OGS Webbrowser LUA interface ). The web server LUA api works by registering LUA callback functions for specific URL prefixes, which are then called by the web server, whenever the given URL is requested from a web client. Prerequisites To use the LUA web server API, the web server must be enabled through station.ini (in the [WebServer] section) and the Microsoft http.sys web server must be configured accordingly (a URL reservation must be activated through the netsh http add urlacl ... command). By default the, installer registers a web endpoint at http://localhost:59990, so the endpoint is only accessible from the local machine and only for a locally logged on user. To access the web server from the outside, make sure to change the listen address in the station.ini file, the URL reservation through netsh http ... and check the firewall settings. Global Webserver table OGS exposes the web server through the global Webserver object. The Webserver object implements the following functions: RegUrl : Register a LUA callback function to be called when a specific URL prefix is requested from the web server. RegUrl The Webserver.RegUrl function registers or unregisters a LUA function to be called whenever the web server receives a request to the given URL prefix. fn, err = Webserver.RegUrl(prefix, callbackfn) Parameters prefix [string]: Path prefix to match against when checking the request URL. Note that this only checks for the path part of the URL (e.g. '/home'). callbackfn [function]: LUA function to be called when a web request matches the prefix. The callback function has the following signature: table = callbackfn(reqpath, reqparams, verb, body) Where reqpath [string] is the full request path, (e.g. '/api/items'), reqparams [string] the request parameters (e.g. '?max=10&class=5'), verb [integer] the request type (GET, PUT, POST, DELETE) and body [string] the body (binaty) string value (only for POST and PUT). The callback function should return a response table with the required parameters to build the http response (optional body). [Datails tbd.] Return values If the function was executed successfully, the callbackfn is returned as the first return value. Else nil is returned and the second return value has an error message string (wrong parameters or unknown instance). Sample code local function handlerfn(reqpath, reqparams, verb, body) -- process the request, return the response object (or nil -- if this request is not handled) return nil end -- Register a LUA function to be called whenever a web request to /api/lua -- is made Browser.RegMsgHandler('/api/lua', handlerfn)","title":"Webserver (and REST API)"},{"location":"v3/lua/webserver/#webserver","text":"","title":"Webserver"},{"location":"v3/lua/webserver/#overview","text":"The OGS runtime uses the Microsoft Windows builtin http.sys web server to server static pages and dynamic pages. The dynamic pages are implemented through LUA scripting and makes it possible to flexibly implement web services like OpenAPI / REST services or others. A typical use case is to provide a REST interface for third-party systems to connect them to OGS, another is to implement backend logic for a single page application web page frontend running inside OGS (see also OGS Webbrowser LUA interface ). The web server LUA api works by registering LUA callback functions for specific URL prefixes, which are then called by the web server, whenever the given URL is requested from a web client.","title":"Overview"},{"location":"v3/lua/webserver/#prerequisites","text":"To use the LUA web server API, the web server must be enabled through station.ini (in the [WebServer] section) and the Microsoft http.sys web server must be configured accordingly (a URL reservation must be activated through the netsh http add urlacl ... command). By default the, installer registers a web endpoint at http://localhost:59990, so the endpoint is only accessible from the local machine and only for a locally logged on user. To access the web server from the outside, make sure to change the listen address in the station.ini file, the URL reservation through netsh http ... and check the firewall settings.","title":"Prerequisites"},{"location":"v3/lua/webserver/#global-webserver-table","text":"OGS exposes the web server through the global Webserver object. The Webserver object implements the following functions: RegUrl : Register a LUA callback function to be called when a specific URL prefix is requested from the web server.","title":"Global Webserver table"},{"location":"v3/lua/webserver/#regurl","text":"The Webserver.RegUrl function registers or unregisters a LUA function to be called whenever the web server receives a request to the given URL prefix. fn, err = Webserver.RegUrl(prefix, callbackfn)","title":"RegUrl"},{"location":"v3/lua/webserver/#parameters","text":"prefix [string]: Path prefix to match against when checking the request URL. Note that this only checks for the path part of the URL (e.g. '/home'). callbackfn [function]: LUA function to be called when a web request matches the prefix. The callback function has the following signature: table = callbackfn(reqpath, reqparams, verb, body) Where reqpath [string] is the full request path, (e.g. '/api/items'), reqparams [string] the request parameters (e.g. '?max=10&class=5'), verb [integer] the request type (GET, PUT, POST, DELETE) and body [string] the body (binaty) string value (only for POST and PUT). The callback function should return a response table with the required parameters to build the http response (optional body). [Datails tbd.]","title":"Parameters"},{"location":"v3/lua/webserver/#return-values","text":"If the function was executed successfully, the callbackfn is returned as the first return value. Else nil is returned and the second return value has an error message string (wrong parameters or unknown instance).","title":"Return values"},{"location":"v3/lua/webserver/#sample-code","text":"local function handlerfn(reqpath, reqparams, verb, body) -- process the request, return the response object (or nil -- if this request is not handled) return nil end -- Register a LUA function to be called whenever a web request to /api/lua -- is made Browser.RegMsgHandler('/api/lua', handlerfn)","title":"Sample code"}]}