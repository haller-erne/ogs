{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OGS - Operator guidance system","text":""},{"location":"#scope","title":"Scope","text":"<p>This documentation provides low-level infomation about the OGS software.  The main purpose is to document the API interfaces (mostly LUA scripting), the available (tool)drivers and show how everything fits together.  This allows advanced users and implementors to unlock the full potential  of OGS by modifying and extending the software.</p> <p>NOTE: This documentation is valid for OGS V3. </p>"},{"location":"#overview","title":"Overview","text":"<p>The documentation currently has the following information:</p> <ul> <li>Tool driver and tool configuration information (see Tool configuration)</li> <li>LUA scripting (see LUA scripting)</li> <li>LUA helper libraries (see LUA libraries)</li> </ul>"},{"location":"appnotes/branding/","title":"Explain branding options","text":""},{"location":"appnotes/branding/#installer","title":"Installer","text":""},{"location":"appnotes/branding/#editor","title":"Editor","text":""},{"location":"appnotes/branding/#runtime","title":"Runtime","text":""},{"location":"appnotes/databanking/","title":"Databanking","text":"<p>Databanking is the general term used by OGS for tracking the parts assembly state across multiple stations. It is actually a set of LUA interfaces in OGS, that facilitate two main functions:</p> <ol> <li>When starting a workflow, read the part/job state </li> <li>When finishing a workflow, write the part/job state</li> </ol> <p>Reading and writing the part/job state can be implemented in LUA. Therefore almost any backed system can be used to access and store the parts current build state.</p> <p>Typical use cases are:</p> <ul> <li>Rework stations (usually having the workflows of multiple stations combined into a single, large workflow).</li> <li>EOL-Checks (end of line checks): Can be used to selectively check single tasks from the assembly stations and visualize these to the operator and add additional (plausibility) checks.</li> </ul> <p>A default implementation using a Microsoft SQL server backend is available and described in this appnote.</p>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#default-sql-server-implementation","title":"Default SQL Server implementation","text":"","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#overview","title":"Overview","text":"<p>The SQL server default databanking implementation identifies and stores data by combining then following properties and using it as a key for data retrieval:</p> <ul> <li>Part serial number</li> <li>Job name</li> <li>Task name</li> </ul> <p>(see also howto customize the datbanking lookup key below)</p> Sample rework scenario <p>Info</p> <ul> <li>All data is retrieved by using the key <code>[part serial number]:[Job name]:[Task name]</code>, so the rework station shows the exact part/task status of the previous operations</li> <li>The rework station does not need to have all jobs/tasks defined identically to the original stations (e.g. S1 Job 1 is not defined in the example rework config shown above). Setup just what you need!</li> </ul>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#example","title":"Example","text":"<p>Say <code>station 1</code> processes the part with the serial <code>123456</code> as follows:</p> Jobs Tasks Result S1 Job 1 Task 1.1 OK S1 Job 2 Task 2.1 OK Task 2.1 NOK S1 Job 3 Task 3.1 not completed <p>Say the rework station <code>station 5</code> is configured to rework all jobs as follows:</p> Jobs Tasks S1 Job 2 Task 2.1 Task 2.1 S1 Job 3 Task 3.1 S2 Job 1 Task 4.1 S3 Job 1 Task 5.1 S4 Job 1 Task 6.1 <p>If the part with the serial <code>123456</code> is scanned in <code>station 5</code> (assume due to being NOK in <code>station 1</code> it is directly routed to the rework station <code>station 5</code>), it now shows up as follows in the OGS process screen (current part status was loaded from the databanking SQL server):</p> Jobs Tasks Result S1 Job 2 Task 2.1 OK Task 2.1 NOK S1 Job 3 Task 3.1 not completed S2 Job 1 Task 4.1 not completed S3 Job 1 Task 5.1 not completed S4 Job 1 Task 6.1 not completed","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#server-requirements","title":"Server requirements","text":"<p>A Microsoft SQL server database must be available and accessible from each OGS station using databanking. As OGS accesses the data every time a workflow is started and completed, a reliable and fast network connection to the database server is very important.</p> <p>Supported SQL server versions are: 2019, 2022.</p>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#client-requirements","title":"Client Requirements","text":"<p>Databanking is fully supported with OGS &gt;= V3.0.</p> <p>Additional software components required:</p> <ul> <li>SQL Server native client 11 (SNAC/SQLNCLI) or SQL Server OLE DB driver (MSOLEDBSQL). NOTE: On an x64 operating system, the x64 versions od the database drivers must be used! </li> </ul>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#installation","title":"Installation","text":"<p>To install follow the steps outlined in the next sections. All files mentioned are available from the public OGS GitHub repository databanking sample.</p>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#sql-server-schema-and-seed-data","title":"SQL Server Schema and seed data","text":"<p>Use the databanking.sql file to install the database schema and lookup data required by the default databanking implementation. </p> <p>For more information, see the README file in the OGS GitHub repository databanking sample folder.</p>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#integrate-databanking-into-ogs-project","title":"Integrate databanking into OGS Project","text":"<p>To integrate databanking into your OGS project, the following changes to the project are needed:</p> <ol> <li>Add the databanking.lua file to your project by adding it into the <code>requires</code> table in your projects <code>config.lua</code> file.</li> <li> <p>Modify your <code>station.ini</code> file to add the database connection information in the <code>[DATABANKING]</code> section to the <code>ConnectionString=</code> parameter. Here is a sample (using SQL server native client, see Connection strings below for more info):</p> <pre><code>[DATABANKING]\nConnectionString=Provider=SQLNCLI11.1;User ID=&lt;my-user&gt;;Password=&lt;my-pass&gt;;Initial Catalog=&lt;my-db&gt;;Data Source=&lt;my-server&gt;\\&lt;my-instance&gt;[,server-port]\n</code></pre> </li> </ol> <p>Info</p> <p>To use an encrypted database connection string, see database connection strings below.</p>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#database-connection-strings","title":"Database connection strings","text":"<p>The databanking setup in this sample uses Microsoft ADO to connect to the database. It therefore is not limited to Microsoft SQL server, but works with all databases providing ODBC or OleDB database drivers.</p> <p>To prevent information leakage, you can also use encrypted database connection strings. This works by encrypting the plaintext connection string with Microsofts data protection API using the machine key of the current system. As this ties the encrypted string to the physical machine, copies of the configureation file cannot be decrypted on another machine. See sample powershell command for encryption on how to encrypt a plaintext string for use with OGS.</p> <p>For Microsoft SQL server, there are multiple options for connecting to the database, supported are the (old) SQL server native client and the current SQL server OleDB driver. These are described in more detail in the following section.</p> <p>Info</p> <p>To workaround missing or invalid server certificates, add <code>Encrypt=false;</code> and/or <code>TrustServerCertificate=false;</code> to the connection string.</p>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#sql-server-oledb-driver-msoledbsql","title":"SQL Server OleDB driver (MSOLEDBSQL)","text":"<p>Here is a sample connection string using the SQL server native client 11:</p> <pre><code>[DATABANKING]\nConnectionString=Provider=MSOLEDBSQL;Data Source=&lt;my-server&gt;\\&lt;my-instance&gt;[,server-port];Initial Catalog=&lt;my-db&gt;;User ID=&lt;my-user&gt;;Password=&lt;my-pass&gt;;\n</code></pre> <p>A quick reference to the parameters can be found at connectionstrings.com or in the official Microsoft documentation.</p>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#sql-server-native-client-snacsqlncli","title":"SQL Server native client (SNAC/SQLNCLI)","text":"<p>Here is a sample connection string using the SQL server native client 11:</p> <pre><code>[DATABANKING]\n; Define the database connection used for databanking\nConnectionString=Provider=SQLNCLI11.1;Data Source=&lt;my-server&gt;\\&lt;my-instance&gt;[,server-port];Initial Catalog=&lt;my-db&gt;;User ID=&lt;my-user&gt;;Password=&lt;my-pass&gt;;\n\n; Define, if data received from databanking should be saved locally (only used for special cases, e.g. for locate.exe, default = 0)\nSaveLocal=0\n</code></pre> <p>A quick reference to the parameters can be found at connectionstrings.com or in the official Microsoft documentation.</p>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#custom-implementations","title":"Custom implementations","text":"<p>TODO: describe the LUA functions used for databanking.</p> <pre><code>function InitOELReport()\n\nfunction SaveResultEvent(PartID, Root, JobSeq, JobName, OpSeq, OpName, Final)\n\nfunction GetTaskResultEvent(PartID, Root, JobSeq, JobName, TaskSeq, TaskName, OpSeq, Final)\n\nfunction SaveStationResultEvent(PartID, StationName, State, Time, Duration, User)\n\nextern SaveJobLocal()\n\n-- Not exactly a databanking function, but it is used in databanking.lua\n-- to track manually deleted data.\nfunction ClearResultsEvent(PartID, Root, JobSeq, JobName, TaskSeq, TaskName)\n</code></pre> <p>Note, that the <code>databanking.lua</code> also overrides the following events:</p> <ul> <li>Barcode_StopAssembly</li> <li>Barcode_StartAssembly</li> </ul> <p>Make sure to not override these events without calling the old implementation, else databanking will not work.</p>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#lookup-identifier-customization","title":"Lookup identifier customization","text":"<p>In general, databanking uses the unique part id (that's handled internally) plus an identifier named <code>AFO</code> to (uniquely) identify a result in databanking. The sample databanking implementation uses a central function to generate the <code>AFO</code> value in the follwoing function : <pre><code>-- Generate a result lookup key\n-- By default: return string '(Root:)Jobname+[Taskname]'\nfunction M.GetAFO(Root, JobSeq, JobName, TaskSeq, TaskName) {}\n</code></pre></p> <p>The return value is a string, which is used as the parameter for the SQL stored procedure to read the process state from the databanking database.</p> <p>To override the default implementation, you can override the function in you own LUA module as follows:</p> <pre><code>-- My module, loaded through the requires table in `config.lua`\n\n-- require the databanking.lua module\nlocal databanking = require('databanking')\n\n-- override the GetAFO function:\ndatabanking.GetAFO = function (Root, JobSeq, JobName, TaskSeq, TaskName)\n    -- my implementation\n    -- generate and return a string with a result lookup key\n    return afo\nend\n</code></pre>","tags":["appnote","enterprise"]},{"location":"appnotes/debugging/","title":"Debugging LUA scripts","text":"<p>OGS ships with a debugging helper script (<code>&lt;instdir&gt;/lualib/libdebug</code>), which is intended to be used with Visual Studio Code and Tom Blinds / lsmoths Second local LUA debuger.</p>","tags":["API"]},{"location":"appnotes/debugging/#debugging-with-vscode","title":"Debugging with VSCode","text":"<p>To use the LUA debugger, the following steps are required:</p> <ol> <li>Install  Visual Studio Code and Tom Blinds / lsmoths Second local LUA debuger extension (search for <code>local lua debugger</code> in Visual Studio Code extensions or install from the link)</li> <li>Add a debugging configuration (see below for a sample debugging configuration)</li> <li>Load the debugger from one of the LUA scripts executed by OGS (requires adding one line, see below for a sample).</li> </ol> <p>To actually start debugging, open your OGS project folder (something like <code>c:\\OGS projects\\sample configuration</code>), create the debugging configuration there and hit <code>F5</code> to start debugging.</p> <p>Info</p> <p>Currently Tom Blinds / lsmoths Second local LUA debuger does not directly support changing breakpoints while the code is running. Either make sure to set some breakpoints before you start the application therefore or cyclically call <code>lldebugger.pullBreakpoints()</code> from your application code (see pullBreakpointsSupport)</p>","tags":["API"]},{"location":"appnotes/debugging/#sample-vscode-debugging-configuration","title":"Sample VSCode debugging configuration","text":"<p>Here is a sample debugging (launch) configuration for VSCode (<code>./vscode/launch.json</code>) - replace <code>&lt;instdir&gt;</code> with the full path where OGS is installed (typically <code>C:/Program Files (x86)/Bosch Rexroth AG/OGS/V3.0</code>)</p> .vscode/launch.json<pre><code>    {\n        \"version\": \"0.2.0\",\n        \"configurations\": [\n            {\n                \"name\": \"OGS (local lua debugger)\",\n                \"type\": \"lua-local\",\n                \"request\": \"launch\",\n                \"program\": {\n                    \"command\": \"&lt;instdir&gt;/monitor.exe\",\n                    \"communication\": \"stdio\"\n                },\n                \"args\": [\n                ],\n                \"scriptRoots\": [\n                    \"&lt;instdir&gt;\",\n                    \"&lt;instdir&gt;/lualibs\",\n                ],\n                \"stopOnEntry\": true,\n                \"pullBreakpointsSupport\": true,\n                \"cwd\": \"&lt;instdir&gt;\",\n                \"verbose\": false,\n                \"integratedTerminal\": true\n            }\n        ]\n    }\n</code></pre>","tags":["API"]},{"location":"appnotes/debugging/#start-the-debugger-backend-from-your-lua-script","title":"Start the debugger backend from your LUA script","text":"<p>To make the debugger work, it is required to run the debugger backend (VSCode only provides the \"frontend\" GUI) from your LUA code. </p> <p>To do so, add the following line to one of the LUA files loaded by OGS:</p> <pre><code>    require('lua-local-debugger')\n</code></pre> <p>Best is to add it into <code>&lt;yourproject&gt;/config.lua</code> somewhere at the top.</p> <p>Info</p> <p>When starting monitor.exe through VSCode, it will automatically break at the end of <code>lua-local-debugger.lua</code> (if the launch.json settings include \"stopOnEntry\": true). You can now set breakpoints or step out into the code where you added the require line.</p> <p>For more details, see https://github.com/tomblind/local-lua-debugger-vscode (lua local debugger) or https://github.com/tarantool/tarantool-lua-debugger-vscode (tarantool lua debugger).</p>","tags":["API"]},{"location":"appnotes/debugging/#known-issues-and-workarounds","title":"Known issues and workarounds","text":"<p>Although the debugger is easy to install and configure, it has some known issues:</p> <ul> <li>Sometimes it is needed to clear the vscode workspace userdata at   %appdata%\\Code\\User\\workspaceStorage (see https://github.com/tomblind/local-lua-debugger-vscode/issues/57)</li> <li>A working LUA repl seems is not available, even if a console is actually avaliable - see https://github.com/tomblind/local-lua-debugger-vscode/issues/81 on how to enable it.</li> </ul>","tags":["API"]},{"location":"appnotes/debugging/#repl","title":"REPL","text":"<p>An interactive REPL is available when debugging with VSCode, see Known issues and workarounds above. </p> <p>An alternative is to use vclua (see also vclua on github and vclua form designer) and build your own. There is a simple sample available for use with OGS (debug-repl-vcl.lua). To use it with OGS, include <code>debug-repl-vcl</code> in the <code>requires</code> list in <code>config.lua</code>. </p> <p>This will then show an additional top level window with a textbox and an edit control. You can enter commands into the edit control and execute them by hitting the enter button.</p> <p>Here is a sample screenshot:</p> <p></p>","tags":["API"]},{"location":"appnotes/station_io/","title":"Station IO","text":"","tags":["appnote"]},{"location":"appnotes/station_io/#overview","title":"Overview","text":"<p>Many times, a real world installation of OGS needs to interact with external sensors and actuators. Typical samples are external push buttons (to acknowledge an operation) connected to a remote I/O module or positioning sensors connected over EtherNet/IP.</p> <p>To simplify access to external IO, OGS provides two generic LUA modules to interact with Modbus/TCP and EtherNet/IP based remote IO devices.</p> <p>These modules provide the following:</p> <ul> <li>Configuration of the devices (like IP address and register scanlist) in <code>station.ini</code></li> <li>Cyclic data exchange in the background (not blocking LUA processing)</li> <li>A LUA interface to add application specific code for mapping input/output data and connecting the physical IOs to a logical OGS function </li> </ul> <p>Currently the following modules are available (see below for more details on using them):</p> <ul> <li><code>station_io_enip.lua</code>: Handle Ethernet/IP remote IO devices using a class 1 (implicit) connection. IP addresses are configurable through station.ini. A set of 'known' devices is included, but others can be added (by specifying the CIP forward open parameters).</li> <li><code>station_io_modbus.lua</code>: Handle Modbus/TCP remote I/O devices. IP addresses and scan list (registers to be scanned cyclically) are configurable through station.ini.</li> </ul> <p>Info</p> <p>Note, that you can also use the OpenProtocol custom IO signals for IO. This is not covered here, see the OpenProtocol tools section for more information.</p>","tags":["appnote"]},{"location":"appnotes/station_io/#usage","title":"Usage","text":"<p>The recommended way to use the station IO modules is to create a station specific <code>station_io.lua</code> file and add this to the <code>config.lua</code> requires list.</p>","tags":["appnote"]},{"location":"appnotes/station_io/#station_io_enip","title":"station_io_enip","text":"","tags":["appnote"]},{"location":"appnotes/station_io/#station_io_modbus","title":"station_io_modbus","text":"","tags":["appnote"]},{"location":"dataoutput/eventlog/","title":"Event logging","text":"","tags":["dataoutput"]},{"location":"dataoutput/eventlog/#overview","title":"Overview","text":"<p>In OGS, the term <code>Event logging</code> refers to capturing and processing various events from within the OGS application. Compared with OGS Traceability, the focus of event logging is not part-related, but station-related. Instead of e.g. detailed tightening result data and curves, <code>Event logging</code> captures alarms and other station events. It can therefore be used for LEAN purposes, OEE monitoring and other availability and optimization questions. </p> <p>The following event categories are available:</p> <ul> <li>Barcode scans</li> <li>GUI interaction events</li> <li>User logon/logoff events</li> <li>Alarms</li> <li>Workflow events</li> <li>Tool result events</li> <li>Common events</li> <li>Error events</li> </ul> <p>By default, all these event categories are available, but there is no default handler registered. Therefore, by default, none of these events are logged.</p>","tags":["dataoutput"]},{"location":"dataoutput/eventlog/#log-events-to-file","title":"Log events to file","text":"<p>As part of the OGS installation, a default implementation for <code>Event logging</code>  is provided in <code>&lt;install dir&gt;\\lualib\\heEventLog.lua</code>. This implementation writes *.csv files (filename includes a timestamp) with event data, so they can easily be uploaded to a database or analyzed by Excel. A file is generated for each day, once a day the old file is then uploaded to a server file share.</p> <p>The following sections describe how to use it in your project.</p>","tags":["dataoutput"]},{"location":"dataoutput/eventlog/#add-heeventloglua-to-your-project","title":"Add heEventlog.lua to your project","text":"<p>To add <code>heEventlog.lua</code> to your project, simply include it into the <code>requires</code> list in your projects <code>config.lua</code>. Here is a sample:</p> <pre><code>-- config.lua\nrequires = {\n    \"barcode\",\n    \"user_manager\",\n    \"heEventlog\"        -- load the event logging functions\n}\ncurrent_project.logo_file = 'logo-rexroth.png'\ncurrent_project.billboard = 'http://127.0.0.1:60000/billboard.html'\n</code></pre>","tags":["dataoutput"]},{"location":"dataoutput/eventlog/#configuration-stationini","title":"Configuration (station.ini)","text":"<p>The <code>heEventlog.lua</code> implementation requires some additional parameters in <code>station.ini</code>. These parameters are configured in the <code>[EVENT_LOG]</code> section as follows:</p> <pre><code>[EVENT_LOG]\n; Set local directory for (temporarily) storing log files\nDIRECTORY=C:\\OGS_Log\n;; Set target directory for storing the logfiles\nTARGET_DIR=\\\\myserver\\share$\\OGS\\LOG-Files\\station-01\n</code></pre> <p>The following parameters are required:</p> <ul> <li><code>DIRECTORY</code>: Local directory for saving the current days file (and possibly older files, if they can't be transmitted to the server)</li> <li><code>TARGET_DIR</code>: Final destination for the event files. Finished files (containing all events from a whole day) will be moved to this folder and deleted locally.</li> </ul>","tags":["dataoutput"]},{"location":"dataoutput/eventlog/#customizing","title":"Customizing","text":"<p>To customize the logging (e.g. to send the event in realtime to some logging server or MQTT broker), the OGS global <code>Eventlog</code> and its member functions can be implemented in custom code.</p> <p>Note, that you will have to create the global <code>Eventlog</code> LUA table and the needed member functions in your code - see <code>&lt;install dir&gt;\\lualib\\heEventLog.lua</code>. </p> <p>The following member functions of the global LUA table <code>Eventlog</code> mujst be implemented:</p> <ul> <li><code>Eventlog.Init()</code>: Called once when OGS is loaded, return true on success, /else nil, error.</li> <li><code>Eventlog.Stop()</code>: Called when OGS is about to terminate. Last chance to finish any pending task, before the application is shut down.</li> <li><code>Eventlog.Write(evt, status, user1, user2, test, p1, p2, p3, p4, p5, p6)</code>: Called by OGS for each event. The event details are passed as parameters as follows:<ul> <li>evt: Event type: one of COMMON (0), BARCODE (1), INTERACTION (2),   USER_LOGON (3), ALARM (4), WORKFLOW (5), RESULT (6), ERROR (7). See the default implementation in <code>heEventlog.lua</code> for event type specific information.</li> <li>status: Event status (like ok, nok, etc.). See the default implementation    in <code>heEventlog.lua</code> for event type specific information.</li> <li>user1, user2: Currently logged on user ID when the event was emitted</li> <li>p1-p6: Event parameters. The actual meaning of the parameter depends on    the event type, see the default implementation in <code>heEventlog.lua</code> for event type specific information.</li> </ul> </li> </ul>","tags":["dataoutput"]},{"location":"dataoutput/printout/","title":"Printout and label printing","text":"","tags":["dataoutput"]},{"location":"dataoutput/printout/#overview","title":"Overview","text":"<p>There is actually no direct support for printout in the OGS station runtime (monitor.exe). However, as printing is a pretty common use case (primarily Label printouts or end-of-line result report sheets), there is support for printing using a report generator.</p> <p>This is usually used in one of the following ways:</p> <ul> <li>As a custom LUA tool which prints a label at some step in a workflow.</li> <li>As a pdf file creator (or sheet printout) at the end of the workflow to   document al process steps done (station-build report or end-of-line   report (with Databanking)).</li> </ul> <p>Both features use either the <code>heLabelPrinter.exe</code> or the <code>locate.exe</code> helper applications shipped with OGS. <code>heLabelPrinter.exe</code> is mainly used, if no SQL queries from the OGS <code>station.fds</code> database are needed, else <code>locate.exe</code> is used. Both applications can run in two modes:</p> <ul> <li>Commandline mode: If called from a LUA file, commands and variables for    the reports are passed over the command line. The application does not show    a GUI window, but creates a file or a printout and exits after everything   was completed.</li> <li>Interactive/GUI mode: For <code>heLabelPrinter.exe</code>, this allows to interactively   edit the printing template. <code>locate.exe</code> also supports this, but can also   be used to show data stored in the <code>station.fds</code> database - and create   printing template with complex SQL queries.</li> </ul> <p>Both applications use the FastReport VCL report generator to create and print/save the documents. See the FastReport Online help on how to create and test reports and how to create reusable report templates.</p>","tags":["dataoutput"]},{"location":"dataoutput/printout/#usage","title":"Usage","text":"","tags":["dataoutput"]},{"location":"dataoutput/printout/#helabelprinterexe","title":"heLabelPrinter.exe","text":"","tags":["dataoutput"]},{"location":"dataoutput/printout/#design-a-report","title":"Design a report","text":"<p>To design a label, run the executable <code>heLabelPrinter.exe</code> without parameters. Click the button \"Edit label template\" to open the FastReport template designer. </p> <p>The following screenshot shows a typical template with some variables (to be provided by a LUA script from OGS over the command line) and a generated 2D-barcode:</p> <p></p> <p>To add the report variables (as text) to the design surface, simply drag&amp;drop from the \"Variables\" tab (on the right hand side). To create new variables, use the main menu <code>Report --&gt; Variables...</code>. This will show the variable editor, where you can then add new variables.</p> <p>To test the newly created report, got to <code>File --&gt; Preview...</code>.</p>","tags":["dataoutput"]},{"location":"dataoutput/printout/#execute-a-report-with-variables","title":"Execute a report (with variables)","text":"<p>To execute a report from the command line, the following syntax is used:</p> <pre><code>heLabelPrinter.exe [key1=value1]...[keyN=valueN]\n</code></pre> <p>The following key values are defined:</p> <ul> <li><code>form=</code>: Defines the report template to use</li> <li><code>show=</code>: If set to <code>YES</code> then show the console progress window. </li> <li><code>output=</code>: Defines the printer name for printing the report or the output    file name for saving the report (in pdf format)</li> </ul> <p>All other key values are used as variable values for the report variables. If you specify e.g. <code>MN=123</code>, then the report variable <code>MN</code> will be set to <code>123</code> - this will then replace the template field accordingly.</p> <p>Typical command lines are:</p> <pre><code>@rem Generate a pdf report and show it. Use INT_VAR1=12345 and STR_VAR2=YES\nheLabelPrinter.exe [form=label.fr3][show=YES][INT_VAR1=12345][STR_VAR2=YES][output=C:\\\\tmp\\\\mumu.pdf]\n\n@rem Print the same report on printer KYOCERA FS1900. Use INT_VAR1=12345 and STR_VAR2=YES\nheLabelPrinter.exe [form=label.fr3][show=YES][INT_VAR1=12345][STR_VAR2=YES][output=KYOCERA FS1900]\n</code></pre>","tags":["dataoutput"]},{"location":"dataoutput/printout/#locateexe","title":"locate.exe","text":"<p>Compared with <code>heLabelPrinter</code>, <code>locvate</code> requires a <code>station.fds</code> database with workflow result data. Whereas <code>heLabelPrinter</code> can be easily used for simple print jobs (like labels), <code>locate.exe</code> is used for build-, tool- and partdata-reports.</p>","tags":["dataoutput"]},{"location":"dataoutput/printout/#design-a-report_1","title":"Design a report","text":"<p>To design a label, run the executable <code>locate.exe</code> without parameters. Choose a database to work with andcheck the \"design\" checkbox in the top row. To open the FastReport template designer, click either the \"print\" button or the \"...\" (ellipsis) button next to the \"design\" checkbox.</p> <p>Compared to the <code>heLabelPrinter</code> gui, you will see the data tab populated with the OGS station database tables. You can use these to build queries and create reports. For more details, please request the database schema documentation.</p>","tags":["dataoutput"]},{"location":"dataoutput/printout/#execute-a-report","title":"Execute a report","text":"<p>To execute a report from the command line, the following syntax is used:</p> <pre><code>locate.exe [key1=value1]...[keyN=valueN]\n</code></pre> <p>The following key values are defined:</p> <ul> <li><code>db=</code>: full path to a database file (station.fds)</li> <li><code>sn=</code>: current serial number (required)</li> <li><code>form=</code>: Defines the report template to use</li> <li><code>show=</code>: If set to <code>YES</code> then show the console progress window. </li> <li><code>output=</code>: Defines the printer name for printing the report or the output    file name for saving the report (in pdf format)</li> </ul> <p>All other key values are used as variable values for the report variables. If you specify e.g. <code>MN=123</code>, then the report variable <code>MN</code> will be set to <code>123</code> - this will then replace the template field accordingly.</p> <p>NOTES: - Variables can also be used in SQL queries! - the paramete <code>sn</code> is mandatory, as <code>locate.exe</code> is typically used for reading   the current parts data.</p> <p>Typical command lines are:</p> <pre><code>@rem Generate a pdf report and show it. Use INT_VAR1=12345 and STR_VAR2=YES\nlocate.exe [db=station.fds][sn=123456][form=label.fr3][show=YES][INT_VAR1=12345][STR_VAR2=YES][output=C:\\\\tmp\\\\mumu.pdf]\n\n@rem Print the same report on printer KYOCERA FS1900. Use INT_VAR1=12345 and STR_VAR2=YES\nlocate.exe [db=station.fds][sn=123456][form=label.fr3][show=YES][INT_VAR1=12345][STR_VAR2=YES][output=KYOCERA FS1900]\n</code></pre>","tags":["dataoutput"]},{"location":"dataoutput/printout/#lua-integration","title":"LUA integration","text":"","tags":["dataoutput"]},{"location":"dataoutput/printout/#automatically-execute-a-report-at-the-end-of-a-workflow","title":"Automatically execute a report at the end of a workflow","text":"<p>To automatically generate a report and save or print it at the end of a workflow, add the print.lua module to your projects <code>config.lua</code>. </p> <p>Info</p> <p>As the functionality for automatic printing is shared with the XML file output (see End-of-process (XML) file), make sure to add the <code>print</code> module to the end of the <code>requires = {}</code>-list in <code>config.lua</code>!</p> <p>Then add a <code>[PRINTER]</code> section to the projects <code>station.ini</code> as follows:</p> <pre><code>[PRINTER]\n; Set ENABLED=1 to automatically generate a report at the end of a workflow\nENABLED=1\n; Define the *.frx template file to use to generate the report\nFORM=\n; Set PDF=&lt;pdf output folder&gt; for pdf file generation\n;PDF=&lt;pdf output folder&gt;\n; Set PRINTER=&lt;name of printer&gt; for automatic printout\nPRINTER=&lt;name of printer&gt;\n</code></pre> <p>Info</p> <p>Note that you can define when a file/printout is generatesd by setting the  parameters <code>Result_OK</code>, <code>Result_Nok</code> and <code>Result_incomplete</code> in the <code>[GLOBAL]</code> section of <code>station.ini</code>. As automatic printout uses the same functionality as XML-file creation, see the documentation at End-of-process (XML) file - Define when a file is generated for more details.</p>","tags":["dataoutput"]},{"location":"dataoutput/printout/#typical-code-to-run-a-report","title":"Typical code to run a report","text":"<p>Typical LUA code to run a report (save pdf or print) is as follows:</p> <pre><code>-- prepare the command line\nlocal fmt = 'heLabelPrinter.exe [form=%s][show=NO][MN=%s][SN=%s][output=%s]'\nlocal cmd = string.format('label.fr3', 'MNum', 'SNum', 'output.pdf')\n\n-- execute the command (with a hidden window)\nlocal err = CreateProcess(cmd, 134217728) -- CREATE_NO_WINDOW flag 0x8000000\nif err then\n    SetLuaAlarm('PRINTER', 'Print failed! Error='..param_as_str(err))\nend \n</code></pre>","tags":["dataoutput"]},{"location":"dataoutput/printout/#hints","title":"Hints","text":"<p>When working with printers, a lot of errors can happen (paper jam, out of paper, printer shutdown or disconnected). As a lot of them cannot be detected through the Windows API, it is good practice to allow reptinting a label, when the operator notices, that the printout has failed.</p> <p>A simple way to implement this is to define a LUA tool, which does the actual printout, then use it as a pre-task aktion. Assign an acknowledge action as the final task. This will result in the following behaviour:</p> <ul> <li>If the tast is executed, it will first execute the print (through the pre-task LUA tool print action). </li> <li>It will then immediately show the acknowledge button - if the label printout was ok, this can be acknowledged \"ok\" by the operator. If there is some problem with the printout, then the operator shall use the \"nok\" acknowledge. </li> <li>If the \"nok\" acknowledge is selected, the default retry behavior kicks in - it deletes the current state of the task and restarts it - effectively executing the pre-task action again (and therefore printing another label).</li> </ul>","tags":["dataoutput"]},{"location":"dataoutput/traceability/","title":"Traceability","text":"","tags":["dataoutput"]},{"location":"dataoutput/traceability/#overview","title":"Overview","text":"<p>In OGS, the term <code>Traceability</code> refers to sending out tool results in JSON format, similar to  the Rexroth Nexo, CS351 and KE350 tools. This feature allows tools, which do not support their own detailed and buffered data output (e. g. most electronic torque wrenches), to  connect to common 3<sup>rd</sup> party data colletion and analysis systems in the same way as the  Rexroth tools do (including graph data, if the tool provides this).</p> <p>In addition to providing industry standard data output for 3<sup>rd</sup> party tools, OGS also generates traceability data for its inbuilt tools. Data can be generated for barcode scans, acknowledge actions and even for user logon/logoff in the same standardized JSON format.  </p> <p>The <code>Traceability</code> feature aims to provide all data in near-realtime and in a high data quality for 3<sup>rd</sup> party systems for full process documentation and insight. All data is buffered locally before sending it out over FTP/http to the consuming server to ensure guaranteed delivery of all process events.</p> <p>Here is an overview of the system setup:</p> <p></p>","tags":["dataoutput"]},{"location":"dataoutput/traceability/#usage","title":"Usage","text":"<p>Traceability is configured in <code>station.ini</code> in the <code>[FTP_CLIENT]</code> section. A typical setup is as follows:</p> <pre><code>[FTP_CLIENT] ; or [HTTP_CLIENT], see below\n; Set ENABLED=1 to enable traceability data output\nENABLED=1\n; Set ReportSkippedOperations=1, if you want to see operators skip actions\n; in the traceability data output, else set to =0\nReportSkippedOperations=1\n\n; Define the targets FTP (Sys3xxGateway) server IP-Address and port\nHostIP=10.80.59.252\nHostPort=21\n\n; In case of Sys3xxGateway(Qtrans) as FTP server use \"Username=sys3xx\" and\n; \"Password=sys3xx\". TargetFolderOnHost is not needed (ignored) then.\nUsername=sys3xx\nPassword=sys3xx\n\n; In case of standard FTP Server the \"TargetFolderOnHost\" parameter must \n; be set\nTargetFolderOnHost=\n\n; Temporary folder for storing result data files on local machine\nDIRECTORY=C:\\Bosch Rexroth AG\\tempData\n\n; Channel info in JSON format \nCHANNEL_99_INFO={ \"IP\": \"\", \"ChannelName\": \"WS010|CHANNEL_INFO\", \"tool serial\": 123456, \"location name\": [\"Tool\", \"Line 2\", \"WS010\", \"default\", \"\", \"\", \"\"] }\nCHANNEL_01_INFO={ \"IP\": \"10.80.59.231\",  \"ChannelName\": \"WS010|AC_PF6000\",  \"tool serial\":  \"B5780438\", \"location name\": [\"Tool\", \"Line 2\", \"WS010\", \"default\", \"\", \"\", \"\"] }\nCHANNEL_15_INFO={ \"IP\": \"10.80.59.141\",  \"ChannelName\": \"WS010|SIM\",        \"tool serial\":  0,          \"location name\": [\"Tool\", \"Line 2\", \"WS010\", \"default\", \"\", \"\", \"\"] }\nCHANNEL_27_INFO={ \"IP\": \"10.80.59.161\",  \"ChannelName\": \"WS010|P2L\",        \"tool serial\":  0,          \"location name\": [\"Tool\", \"Line 2\", \"WS010\", \"default\", \"\", \"\", \"\"] }\nCHANNEL_31_INFO={ \"IP\": \"10.80.59.141\",  \"ChannelName\": \"WS010|ACK\",        \"tool serial\":  0,          \"location name\": [\"Tool\", \"Line 2\", \"WS010\", \"default\", \"\", \"\", \"\"] }\n</code></pre> <p>The main parameters are explained inline above, the <code>CHANNEL_xx_INFO</code> parameters are used to enable reporting data for connected tools. There are basically two different <code>CHANNEL_xx_INFO</code> items here:</p> <ul> <li><code>CHANNEL_xx_INFO</code> with <code>xx</code> in the range of <code>01</code> to <code>98</code>: This is used to   generate and send traceability info for the tool <code>xx</code>. If used for virtual    tools, you can set the <code>IP</code> and <code>ChannelName</code> parameters to simulate these   parameters, if used for a physical tool, then <code>IP</code> and <code>ChannelName</code> are   used from the tools configuration (e.g. for an OpenProtocol torque wrench   from the <code>[OpenProtocol]</code> section, where the communication parameters for   the tool are defined)</li> <li><code>CHANNEL_99_INFO</code>: This is a special \"event\"-channel for OGS builtin events   like the barcode scanner, acknowledge button or other events (like OGS   start shutdown, user login, skip operation, etc.)</li> </ul> <p>The <code>CHANNEL_xx_INFO</code> parameter values are interpreted as a JSON string with the following elements:</p> <ul> <li><code>location name</code>: Array of location names [1..7] (of type string)</li> <li><code>IP</code>: IP address (or com port or the connection string) of the tool</li> <li><code>ChannelName</code>: The channel name used for building the result data file</li> <li><code>tool serial</code>: The tool serial number to use</li> </ul> <p>If the parameters are not given, they default to whatever the actual tool driver provides, the parameters give override the defaults.</p>","tags":["dataoutput"]},{"location":"dataoutput/traceability/#communication-settings-httpftp","title":"Communication settings (http/FTP)","text":"<p>The <code>Traceability</code> feature support sending the data to either a FTP server or posting it to a http server (but not both at the same time). The following sections show how to setup the communication parameters.</p>","tags":["dataoutput"]},{"location":"dataoutput/traceability/#http-output","title":"http output","text":"<p>To enable http output, the configuration section must be named <code>[HTTP_CLIENT]</code> and the communication settings given as follows:</p> <pre><code>[HTTP_CLIENT]\n; Set ENABLED=1 to enable traceability data output\nENABLED=1\n; Set ReportSkippedOperations=1, if you want to see operators skip actions\n; in the traceability data output, else set to =0\nReportSkippedOperations=1\n\n; Define the targets http (Sys3xxGateway) server URL endpoint\n; Note, that this also supports https!\nHostURL=http://myserver:8888/sys3xxgateway\n\n; Optionally set username/password for http basic authentication\n;Username=sys3xx\n;Password=sys3xx\n</code></pre>","tags":["dataoutput"]},{"location":"dataoutput/traceability/#ftp-output","title":"FTP output","text":"<p>To enable FTP output, the configuration section must be named <code>[FTP_CLIENT]</code> and the communication settings given as follows:</p> <pre><code>[FTP_CLIENT]\n; Set ENABLED=1 to enable traceability data output\nENABLED=1\n; Set ReportSkippedOperations=1, if you want to see operators skip actions\n; in the traceability data output, else set to =0\nReportSkippedOperations=1\n\n; Define the targets FTP (Sys3xxGateway) server IP-Address and port\nHostIP=10.80.59.252\nHostPort=21\n\n; In case of Sys3xxGateway(Qtrans) as FTP server use \"Username=sys3xx\" and\n; \"Password=sys3xx\". TargetFolderOnHost is not needed (ignored) then.\nUsername=sys3xx\nPassword=sys3xx\n\n; In case of standard FTP Server the \"TargetFolderOnHost\" parameter must \n; be set and is used as a base folder to store data.\nTargetFolderOnHost=\n</code></pre> <p>Note, that the FTP output supports two different server types:</p> <ul> <li>Standard FTP server: A standard FTP server allows (virtual) file system access. Therefore typically a username and password must be used for authentication and a target folder (<code>TargetFolderOnHost</code>) to indicate where the transmitted files are stored must be configured. Note, that due to security reasons nowadays unencrypted data (password) exchange should not be used.</li> <li><code>Sys3xxGateway</code> FTP server: This is a FTP server which only supports a subset of the standard FTP protocol. It does not require authentication (username/password) and also does not allow file system access. It handles all received data in-memory and validates it - only data which validates as a correct result data is accepted and processed. The parameters <code>Username</code>, <code>Password</code> and <code>TargetFolderOnHost</code> are therefore not used - so the security level is on par with the http transport.</li> </ul>","tags":["dataoutput"]},{"location":"dataoutput/traceability/#reference","title":"Reference","text":"","tags":["dataoutput"]},{"location":"dataoutput/traceability/#custom-file-name-generation","title":"Custom file name generation","text":"<p>By default, the file for transmitting to FTP is generated internally in the following form:</p> <pre><code>&lt;hostdir&gt;/&lt;YYYY-MM-DD_HH&gt;/&lt;YYYYMMDDHHmmSS&gt;_&lt;IPAddr&gt;_&lt;Channel&gt;_&lt;seq&gt;.json\n</code></pre> <p>Where:</p> <ul> <li><code>&lt;hostdir&gt;</code> as specified in the <code>[FTP_CLIENT]</code> section (Parameter <code>TargetFolderOnHost</code>)</li> <li><code>&lt;YYYY-MM-DD_HH&gt;</code> and <code>&lt;YYYYMMDDHHmmSS&gt;</code> date/time stamps</li> <li><code>&lt;IPAddr&gt;</code> the tools IP address (or connection string), maybe overridden in the <code>CHANNEL_xx_INFO</code> parameters</li> <li><code>&lt;Channel&gt;</code> channel number of the tool</li> <li><code>&lt;seq&gt;</code> result sequence counter value (if any) of the tool</li> </ul> <p>For custom tools, the generated file can be modified by overriding the LUA function <code>GetFTPFilename()</code>. </p> <p>The function has the following signature:</p> <pre><code>function GetFTPFilename(idcode, IP, Rack, Slot, Seq)\n\n    -- Your code to create a relative filename in the format \n    --    &lt;subfolder(s)&gt;/&lt;filename&gt;\n\n    return filename\nend\n</code></pre>","tags":["dataoutput"]},{"location":"dataoutput/traceability/#lua-tools-result-data","title":"LUA tools result data","text":"<p>A custom LUA tool can also generate a tracability result file. The low-level OGS API responsible to generate the actual data is the function <code>LUA_GetJSON()</code> - however, it is not recommended to override this function, as the LUA custom tool interface provides a more convenient wrapper (see LUA custom tools by calling the tool drivers <code>process_param_list()</code>, <code>get_tags()</code>, <code>extended_param_list()</code> and <code>extended_function_list()</code> interface functions.</p> <p>To get more info about custom tracebility output formatting for LUA tools, see the default implementation in <code>&lt;install dir&gt;\\lualib\\json_ftp.lua</code>. </p>","tags":["dataoutput"]},{"location":"dataoutput/xmlfile/","title":"End-of-process (XML) file","text":"","tags":["dataoutput"]},{"location":"dataoutput/xmlfile/#overview","title":"Overview","text":"<p>OGS records all process results and the resulting part state internally in its database, but it also provides interfaces to provide this data to other systems.</p> <p>The End-of-process (XML) file functionality (by default) automatically generates a XML file containing the  part staus at the moment, when OGS finishes a workflow (i.e. the part leaves the station). </p> <p>The mechanism used to generate the XML file allows overriding the file name (by default generated as <code>&lt;model&gt;&lt;serial&gt;-&lt;timestamp&gt;.xml</code>) as well as the file contents by implementing the LUA function <code>GetXMLFile()</code>.</p> <p>By setting the configuration options in <code>station.ini</code>, the destination folder to save the result files can be specified, as well as when a file shall be created (e.g. only if the part is completed, i.e. all tasks are finished or everytime, even if there are missing tasks).  </p>","tags":["dataoutput"]},{"location":"dataoutput/xmlfile/#usage","title":"Usage","text":"","tags":["dataoutput"]},{"location":"dataoutput/xmlfile/#enabling-the-xml-data-output","title":"Enabling the XML data output","text":"<p>To enable the XML data output, define the destination directory to use in the <code>[XML]</code> section in your projects <code>station.ini</code> as follows:</p> <pre><code>[GENERAL]\n; Define if the data output shall have all step results\n; or if only the final step results are used (default)\n; \n; Set SAVE_ONLY_LAST_STEP = 0 if you want all steps.\nSAVE_ONLY_LAST_STEP = 1\n\n[XML]\n; Define the workflow complete data output (save a result data file).\n; NOTES:\n; - If the DIRECTORY parameter is missing or empty, no file is generated.\n; - The [GENERAL] section RESULT_Ok=, RESULT_Nok=, RESULT_incomplete= define when a XML\n;   file is actually generated, e.g. if RESULT_incomplete=SKIP, no XML file will be\n;    generated, if a part is finished with incomplete status (like missing bolts).\n; - The generated file format/contents can be overriden by LUA code (see GetXMLFile())\n;\n; Define the output directory for generated part result reports (by default in XML format)\nDIRECTORY=C:\\Daten\n</code></pre> <p>XML data output is disabled, if the <code>DIRECTORY</code> parameter is missing or empty.</p>","tags":["dataoutput"]},{"location":"dataoutput/xmlfile/#define-when-a-file-is-generated","title":"Define when a file is generated","text":"<p>In general, the XML file is generated when a workflow is completed (i.e. when OGS switches from the process screen back to the idle screen). However, sometimes - depending on the parts result - one does not want to actually save a result data file (e.g. because the part is only partially completed, set aside and will be finished later).</p> <p>OGS uses the \"archive\" settings to decide, if the result file shall be generated - as this is conceptionally the same as for the \"archiving\" setting of the database. The parameters for this are in the <code>[GENERAL]</code> section of <code>station.ini</code> as follows:</p> <pre><code>;\n; If Operator finishes part processing, should be part result get archived in the Database?\n;  SKIP - (default) do not archive part result (keep it in database as not completed)\n;  SAVE - archive part result ((keep it in database as archived))\n;  ASK  - ask operator if part result shall be archived or not\n; Define the behaviour according to the part state as follows:\nResult_OK=SAVE\nResult_NOK=SAVE\nResult_incomplete=SKIP\n</code></pre> <p>The above sample will create a result file, if the part is completed, i. e. all tasks are either finished OK or NOK, but there will no file be created, if any of the tasks is noch completed (or not started).</p>","tags":["dataoutput"]},{"location":"dataoutput/xmlfile/#reference","title":"Reference","text":"<p>The default file naming and data format is implementend in <code>&lt;install dir&gt;\\lualib\\system.lua</code>. </p>","tags":["dataoutput"]},{"location":"dataoutput/xmlfile/#file-naming-conventions","title":"File Naming conventions","text":"<p>By default, OGS generates the filename of the result data file as follows:</p> <pre><code>&lt;idcode&gt;-&lt;timestamp&gt;.xml\n</code></pre> <p>where</p> <ul> <li><code>&lt;idcode&gt;</code> is the concatenation of the model code and serial number</li> <li><code>&lt;timestamp&gt;</code> is the current date/time in format <code>YYMMDD-HHmmss</code></li> </ul>","tags":["dataoutput"]},{"location":"dataoutput/xmlfile/#file-contents","title":"File contents","text":"<p>By default the generated file contains the results in the following XML format:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;\n&lt;prozess  id=\"M-061231231232\" typ=\"MODEL 06\" version=\"1.0\"&gt;\n    &lt;station name =\"[he-007] ST03\" host=\"nbhei7wx\" zeitstempel=\"04.07.2024 10:24:59\" kundeninfo=\"\" werker=\"red\" meister=\"\" ergebnis=\"NOK\"&gt;\n        &lt;bauteil name =\"Brake Caliper\" zeitstempel=\"04.07.2024 10:24:59\" ergebnis=\"nicht vorhanden\"&gt;\n            &lt;schrauben&gt;\n                &lt;schraube num=\"1\" name=\"S1\" werkzeug=\"Nexo\" prg=\"6\" moment=\"30.09\" mommin=\"28.00\" mommax=\"32.00\" winkel=\"782\" winmin=\"500.0\" winmax=\"1200.0\" ergebnis=\"OK\" comment=\"\"/&gt;\n                &lt;schraube num=\"2\" name=\"S2\" werkzeug=\"Nexo\" prg=\"6\" moment=\"30.13\" mommin=\"28.00\" mommax=\"32.00\" winkel=\"815\" winmin=\"500.0\" winmax=\"1200.0\" ergebnis=\"OK\" comment=\"\"/&gt;\n                &lt;schraube num=\"3\" name=\"S3\" werkzeug=\"Nexo\" prg=\"12\" moment=\"10.03\" mommin=\"8.00\" mommax=\"12.00\" winkel=\"43\" winmin=\"30\" winmax=\"60\" ergebnis=\"OK\" comment=\"\"/&gt;\n                &lt;schraube num=\"4\" name=\"S4\" werkzeug=\"Nexo\" prg=\"12\" moment=\"\" mommin=\"\" mommax=\"\" winkel=\"\" winmin=\"\" winmax=\"\" ergebnis=\"nicht vorhanden\" comment=\"\"/&gt;\n            &lt;/schrauben&gt;\n        &lt;/bauteil&gt;\n        &lt;bauteil name =\"Oil dipstick\" zeitstempel=\"04.07.2024 10:25:03\" ergebnis=\"NOK\"&gt;\n            &lt;schrauben&gt;\n                &lt;schraube num=\"1\" name=\"S1\" werkzeug=\"Ack\" prg=\"0\" moment=\"INF\" mommin=\"0.00\" mommax=\"0.00\" winkel=\"INF\" winmin=\"0.0\" winmax=\"0.0\" ergebnis=\"NOK\" comment=\"\"/&gt;\n            &lt;/schrauben&gt;\n        &lt;/bauteil&gt;\n        &lt;bauteil name =\"Oil dipstick popup\" zeitstempel=\"04.07.2024 10:25:04\" ergebnis=\"OK\"&gt;\n            &lt;schrauben&gt;\n                &lt;schraube num=\"1\" name=\"S1\" werkzeug=\"Ack\" prg=\"0\" moment=\"INF\" mommin=\"0.00\" mommax=\"0.00\" winkel=\"INF\" winmin=\"0.0\" winmax=\"0.0\" ergebnis=\"OK\" comment=\"\"/&gt;\n            &lt;/schrauben&gt;\n        &lt;/bauteil&gt;\n    &lt;/station&gt;\n&lt;/prozess&gt;\n</code></pre> <p>Note, that all jobs and tasks are listed - those not ran are tagged with the result attribute <code>ergebnis=\"nicht vorhanden\"</code>.</p>","tags":["dataoutput"]},{"location":"dataoutput/xmlfile/#lua-function-to-override-file-name-and-content","title":"Lua function to override file name and content","text":"<p>To override the file name or file content, implement the LUA function <code>GetXMLFile()</code> in your projects LUA code. The function is called with the <code>&lt;idcode&gt;</code> value and the <code>&lt;model&gt;</code> code. Before OGS calls the function, the current part state is saved into the <code>station_results</code> global variable. The function should use the contents of <code>station_results</code> to generate the actual file data and return it along with the file name.</p> <p>The function has the following signature:</p> <pre><code>function GetXMLFile(idcode, model)\n\n    -- Your code to create filename and filecontent\n    -- Use the global variable station_results to generate the file content.\n\n    return filename, filecontent\nend\n</code></pre> <p>To just change the generated file name, you can call the \"original\" function from your code and just change the filename. Here is a sample:</p> <pre><code>-- Store the original function in a local variable\nlocal old_GetXMLFile = GetXMLFile\n\n-- Define the new function (override the original one)\nfunction GetXMLFile(idcode, model)\n\n    -- Call the \"original\" function to get the XML data\n    local old_filename, old_filecontent = old_GetXMLFile(idcode, model)\n\n    -- Create a new filename as \"&lt;idcode&gt;-&lt;YYYY&gt;&lt;MM&gt;&lt;DD&gt;T&lt;HH&gt;&lt;mm&gt;&lt;ss&gt;.xml\"\n    local t = os.date('*t')\n    local t_as_str = string.format('%04d%02d%02dT%02d%02d%02d', t.year,t.month, t.day, t.hour,t.min,t.sec)\n    local new_filename = string.format('%s-%s.xml', idcode, t_as_str)\n\n    -- Return the \"new\" filename and the \"old\" file content\n    return new_filename, old_filecontent\nend\n</code></pre> <p>To get started quickly, see the default implementation in <code>&lt;install dir&gt;\\lualib\\system.lua</code>. </p>","tags":["dataoutput"]},{"location":"libs/_template_/","title":"Ability","text":"<p>Abilities are CoreObjects that can be added to Players and guide the Player's animation in sync with the Ability's state machine. Spawn an Ability with <code>World.SpawnAsset()</code> or add an Ability as a child of an Equipment/Weapon to have it be assigned to the Player automatically when that item is equipped.</p> <p>Abilities can be activated by association with an Action Binding. Their internal state machine flows through the phases: Ready, Cast, Execute, Recovery, and Cooldown. An Ability begins in the Ready state and transitions to Cast when its Binding (for example Left mouse click) is activated by the owning player. It then automatically flows from Cast to Execute, then Recovery and finally Cooldown. At each of these state transitions it fires a corresponding event.</p> <p>Only one ability can be active at a time. By default, activating an ability will interrupt the currently active ability. The <code>canBePrevented</code> and <code>preventsOtherAbilities</code> properties can be used to customize interruption rules for competing abilities.</p> <p>If an ability is interrupted during the Cast phase, it will immediately reset to the Ready state. If an ability is interrupted during the Execute or Recovery phase, the ability will immediately transition to the Cooldown phase.</p>","tags":["API"]},{"location":"libs/_template_/#properties","title":"Properties","text":"Property Name Return Type Description Tags <code>isEnabled</code> <code>boolean</code> Turns an Ability on/off. It stays on the Player but is interrupted if <code>isEnabled</code> is set to <code>false</code> during an active Ability. True by default. Read-Write <code>canActivateWhileDead</code> <code>boolean</code> Indicates if the Ability can be used while the owning Player is dead. False by default. Read-Only <code>name</code> <code>string</code> The name of the Ability. Read-Only <code>actionBinding</code> <code>string</code> This property is deprecated. Please use <code>actionName</code> instead, but note that <code>actionBinding</code> and <code>actionName</code> use different values.  Which action binding will cause the Ability to activate. Possible values of the bindings are listed on the Ability binding page. Read-Only, Deprecated <code>actionName</code> <code>string</code> Which binding set action name will cause the Ability to activate. See Binding Sets reference. Read-Only <code>owner</code> <code>Player</code> Assigning an owner applies the Ability to that Player. Read-Write <code>castPhaseSettings</code> <code>AbilityPhaseSettings</code> Config data for the Cast phase (see below). Read-Only <code>executePhaseSettings</code> <code>AbilityPhaseSettings</code> Config data for the Execute phase. Read-Only <code>recoveryPhaseSettings</code> <code>AbilityPhaseSettings</code> Config data for the Recovery phase. Read-Only <code>cooldownPhaseSettings</code> <code>AbilityPhaseSettings</code> Config data for the Cooldown phase. Read-Only <code>animation</code> <code>string</code> Name of the animation the Player will play when the Ability is activated. Possible values: See Ability Animation for strings and other info. Read-Only <code>canBePrevented</code> <code>boolean</code> Used in conjunction with the phase property <code>preventsOtherAbilities</code> so multiple abilities on the same Player can block each other during specific phases. True by default. Read-Only","tags":["API"]},{"location":"libs/_template_/#functions","title":"Functions","text":"Function Name Return Type Description Tags <code>Activate()</code> <code>None</code> Activates an Ability as if the button had been pressed. None <code>Interrupt()</code> <code>None</code> Changes an Ability from Cast phase to Ready phase. If the Ability is in either Execute or Recovery phases it instead goes to Cooldown phase. None <code>AdvancePhase()</code> <code>None</code> Advances a currently active Ability from its current phase to the next phase. For example, an ability in the Cast phase will begin the Execute phase, an ability on cooldown will become ready, etc. None <code>GetCurrentPhase()</code> <code>AbilityPhase</code> The current AbilityPhase for this Ability. These are returned as one of: AbilityPhase.READY, AbilityPhase.CAST, AbilityPhase.EXECUTE, AbilityPhase.RECOVERY and AbilityPhase.COOLDOWN. None <code>GetCurrentPhaseSettings()</code> <code>AbilityPhaseSettings</code> Returns the settings for the current phase of this Ability. Returns <code>nil</code> if the current phase is <code>AbilityPhase.READY</code>. None <code>GetPhaseTimeRemaining()</code> <code>number</code> Seconds left in the current phase. None <code>GetTargetData()</code> <code>AbilityTarget</code> Returns information about what the Player has targeted this phase. None <code>SetTargetData(AbilityTarget)</code> <code>None</code> Updates information about what the Player has targeted this phase. This can affect the execution of the Ability. None","tags":["API"]},{"location":"libs/_template_/#events","title":"Events","text":"Event Name Return Type Description Tags <code>readyEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability becomes ready. In this phase it is possible to activate it again. None <code>castEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability enters the Cast phase. None <code>executeEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability enters Execute phase. None <code>recoveryEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability enters Recovery. None <code>cooldownEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability enters Cooldown. None <code>interruptedEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability is interrupted. None <code>tickEvent</code> <code>Event</code>&lt;<code>Ability</code> ability, <code>number</code> deltaTime&gt; Fired every tick while the Ability is active (isEnabled = true and phase is not ready). None","tags":["API"]},{"location":"libs/_template_/#examples","title":"Examples","text":"<p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#castevent","title":"<code>castEvent</code>","text":"<p>The Cast phase begins as soon as an ability is activated. By checking if the player casting the ability <code>isGrounded</code> we can create an effect that propels you upwards, but it doesn't work if you are already jumping or flying. We detect this is the <code>castEvent</code>, which is early enough for an <code>Interrupt()</code> to reset the ability.</p> <pre><code>--Server script\nlocal ability = script.parent\n\nfunction OnCast(ability)\n    if ability.owner.isGrounded then\n        ability.owner:SetVelocity(Vector3.UP * 2000)\n    else\n        ability:Interrupt()\n    end\nend\n\nability.castEvent:Connect(OnCast)\n</code></pre> <p>See also: CoreObject.parent | Ability.owner | Player.isGrounded | Vector3.UP | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#cooldownevent","title":"<code>cooldownEvent</code>","text":"<p>In this example, a fighting game has an \"invincible\" mechanic where player attacks are not interrupted while they have this effect. Some powerful attacks make the player invincible during the entire active cycle of the ability. The effect is gained at the beginning of the cast phase and is removed at the end of the recovery phase, before the cooldown begins. The resource system is used in keeping track of the invincibility effect.</p> <pre><code>--Server script\nlocal ability = script.parent\n\nfunction OnCast(ability)\n    ability.owner:AddResource(\"invincible\", 1)\nend\n\nfunction OnCooldown(ability)\n    ability.owner:RemoveResource(\"invincible\", 1)\nend\n\nability.castEvent:Connect(OnCast)\nability.cooldownEvent:Connect(OnCooldown)\n</code></pre> <p>See also: CoreObject.parent | Player.owner | Ability.castEvent | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#executeevent","title":"<code>executeEvent</code>","text":"<p>Weapons implement lots of built-in gameplay that doesn't require any scripting, such as attack and reload abilities. However, they can be augmented with additional mechanics. In this example, a special sound effect is played when a weapon shoots while low on ammunition. The script expects to be a child of a weapon's \"Shoot\" ability.</p> <pre><code>--Server script\nlocal ability = script.parent\nlocal weapon = script:FindAncestorByType('Weapon')\nlocal lowAmmoSound = script:GetCustomProperty(\"LowAmmoSound\")\n\nlocal LOW_AMMO_PERCENTAGE = 0.2\n\nfunction OnExecute(ability)\n    if weapon.currentAmmo / weapon.maxAmmo &lt;= LOW_AMMO_PERCENTAGE then\n        World.SpawnAsset(lowAmmoSound, {position = weapon:GetWorldPosition()})\n    end\nend\n\nability.executeEvent:Connect(OnExecute)\n</code></pre> <p>See also: CoreObject.parent | Weapon.currentAmmo | World.SpawnAsset | Ability.executeEvent | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#interruptedevent","title":"<code>interruptedEvent</code>","text":"<p>The <code>interruptedEvent</code> fires when an ability is going through it's activation process and <code>Interrupt()</code> is called on it, or if it becomes disabled. In this example, interruption is a key part of the game design, so a visual effect is spawned at the player's position to help communicate the interaction between players.</p> <pre><code>--Server script\nlocal ability = script.parent\nlocal interruptedVfx = script:GetCustomProperty(\"InterruptedVfx\")\n\nfunction OnInterrupted(ability)\n    if Object.IsValid(ability.owner) then\n        World.SpawnAsset(interruptedVfx, {position = ability.owner:GetWorldPosition()})\n    end\nend\n\nability.interruptedEvent:Connect(OnInterrupted)\n</code></pre> <p>See also: CoreObject.parent | Object.IsValid | Ability.owner | World.SpawnAsset | Player.GetWorldPosition | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#readyevent","title":"<code>readyEvent</code>","text":"<p>The Ready phase begins when an ability comes off cooldown and is \"ready\" to be used again. In this example, we create an invisibility effect that takes advantage of the <code>readyEvent</code>, leveraging the cooldown duration of the ability as a clock to determine when to make the player visible again.</p> <pre><code>-- Server script\nlocal ability = script.parent\n\nfunction OnExecute(ability)\n    -- Hide the player\n    ability.owner:SetVisibility(false)\nend\n\nfunction OnReady(ability)\n    -- Show the player\n    ability.owner:SetVisibility(true)\nend\n\nability.readyEvent:Connect(OnReady)\nability.executeEvent:Connect(OnExecute)\n</code></pre> <p>See also: CoreObject.parent | Ability.owner | Player.SetVisibility | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#recoveryevent","title":"<code>recoveryEvent</code>","text":"<p>The <code>recoveryEvent</code> marks the end of an ability's Execute phase and the beginning of its Recovery phase. In this example, a melee punch ability has a trigger that causes damage to enemies who overlap it. For it to work the trigger is only enabled for a brief moment, during the Execute phase.</p> <pre><code>--Server script\nlocal ability = script.parent\nlocal trigger = script:GetCustomProperty(\"ImpactTrigger\"):WaitForObject()\ntrigger.collision = Collision.FORCE_OFF\n\nlocal DAMAGE_AMOUNT = 10\n\nfunction OnExecute(ability)\n    trigger.collision = Collision.FORCE_ON\nend\n\nfunction OnRecovery(ability)\n    trigger.collision = Collision.FORCE_OFF\nend\n\nability.executeEvent:Connect(OnExecute)\nability.recoveryEvent:Connect(OnRecovery)\n\nfunction OnBeginOverlap(trigger, other)\n    -- Only damage enemy players\n    if other:IsA(\"Player\") and other.team ~= ability.owner.team then\n        other:ApplyDamage(Damage.New(DAMAGE_AMOUNT))\n    end\nend\n\ntrigger.beginOverlapEvent:Connect(OnBeginOverlap)\n</code></pre> <p>See also: CoreObject.parent | CoreObjectReference.WaitForObject | Ability.executeEvent | Event.Connect | other.IsA | Player.team | Damage.New | Trigger.beginOverlapEvent</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#tickevent","title":"<code>tickEvent</code>","text":"<p>Abilities fire the <code>tickEvent</code> while they are active or on cooldown (not on Ready state). In this example, a piece of equipment carries several abilities, but we want to do a common update logic on all of them. Note: <code>Ability.tickEvent</code> works somewhat differently from a <code>Tick()</code> function - <code>tickEvent</code> is an actual event that just happens to fire once per tick. Each invocation of the callback runs on its own task. This means that, unlike <code>Tick()</code>, there is no guarantee that it will wait for the previous <code>tickEvent</code> to finish before starting the next one. This means you can't use things like <code>Task.Wait()</code> to add time between ticks.</p> <pre><code>local equipment = script.parent\nlocal allAbilities = equipment:GetAbilities()\n\nfunction OnTick(ability, deltaTime)\n    print(\"Updating ability \" .. ability.name)\nend\n\nfor _, ability in ipairs(allAbilities) do\n    ability.tickEvent:Connect(OnTick)\nend\n</code></pre> <p>See also: CoreObject.parent | Equipment.GetAbilities | Event.Connect | CoreLua.print</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#activate","title":"<code>Activate</code>","text":"<p>The Ability <code>Activate()</code> function behaves as if the player had pressed the key binding. In order for a server gameplay decision to result in an ability activation, it must be communicated over the network somehow. In this example, a trigger overlap is representative of an arbitrary gameplay decision on the server. A broadcast message is sent to the client, who receives the event and activates the ability.</p> <pre><code>--Server script\nlocal trigger = script.parent\nlocal function OnBeginOverlap(trigger, other)\n    if other:IsA(\"Player\") then\n        Events.BroadcastToPlayer(other, \"SteppedOnObject\")\n    end\nend\n\ntrigger.beginOverlapEvent(OnBeginOverlap)\n\n--[[#description\n    Client context script under the ability:\n]]\nlocal ability = script:FindAncestorByType(\"Ability\")\n\nfunction OnPlayAnimation()\n    if ability.owner and ability.owner == Game.GetLocalPlayer() then\n        ability:Activate()\n    end\nend\n\nEvents.Connect(\"SteppedOnObject\", OnPlayAnimation)\n</code></pre> <p>See also: CoreObject.parent | Trigger.beginOverlapEvent | other.IsA | Events.BroadcastToPlayer | Ability.owner | Game.GetLocalPlayer()</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#advancephase","title":"<code>AdvancePhase</code>","text":"","tags":["API"]},{"location":"libs/_template_/#getcurrentphase","title":"<code>GetCurrentPhase</code>","text":"<p>In this example an ability is on cooldown, but can be set back to <code>Ready</code> by calling <code>AdvancePhase()</code>.</p> <pre><code>function EndAbilityCooldown(ability)\n    if ability:GetCurrentPhase() == AbilityPhase.COOLDOWN then\n        ability:AdvancePhase()\n    end\nend\n</code></pre> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#getcurrentphase_1","title":"<code>GetCurrentPhase</code>","text":"","tags":["API"]},{"location":"libs/_template_/#getphasetimeremaining","title":"<code>GetPhaseTimeRemaining</code>","text":"<p>In this example, while the ability is on cooldown, the percentage completion of the cooldown is calculated. This could be useful, for instance, in displaying user interface.</p> <pre><code>local ability = script:FindAncestorByType(\"Ability\")\n\nfunction Tick()\n    if ability:GetCurrentPhase() == AbilityPhase.COOLDOWN then\n        local duration = ability.cooldownPhaseSettings.duration\n        local remaining = ability:GetPhaseTimeRemaining()\n        local percent = 100 * (1 - remaining / duration)\n\n        print(\"Cooldown remaining: %\" .. string.format(\"%.2f\",percent))\n    end\nend\n</code></pre> <p>See also: CoreObject.FindAncestorByType | Ability.GetCurrentPhase | AbilityPhaseSettings.duration | CoreLua.print</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#gettargetdata","title":"<code>GetTargetData</code>","text":"","tags":["API"]},{"location":"libs/_template_/#settargetdata","title":"<code>SetTargetData</code>","text":"<p>The ability's targeting data gives a lot of information about where and what the player is aiming at. If setup correctly, it can also be modified programmatically. In this example, the Z position of the target is flattened horizontally. Useful, for example, in a top-down shooter. For this to work it should be placed in a client context under the ability. The ability should also have the option \"Is Target Data Update\" turned off for the Execute phase, otherwise any data set programmatically will be overwritten when the phase changes.</p> <pre><code>--Server script\nlocal ability = script:FindAncestorByType(\"Ability\")\n\nfunction OnCast(ability)\n    local abilityTarget = ability:GetTargetData()\n    local pos = abilityTarget:GetHitPosition()\n\n    pos.z = ability.owner:GetWorldPosition().z + 50\n\n    abilityTarget:SetHitPosition(pos)\n    ability:SetTargetData(abilityTarget)\nend\n\nability.castEvent:Connect(OnCast)\n</code></pre> <p>See also: CoreObject.FindAncestorByType | AbilityTarget.GetHitPosition | Ability.owner | Player.GetWorldPosition | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#interrupt","title":"<code>Interrupt</code>","text":"<p>Interrupting an ability either sends it back into ready state (if it was still in the Cast phase) or puts it on cooldown. In this example, we have an ability that searches for all enemies in a 10 meter radius and interrupts their abilities.</p> <pre><code>--Server script\nlocal ability = script.parent\nlocal RADIUS = 1000 -- 10 meters\n\nfunction OnExecute(ability)\n    local center = ability.owner:GetWorldPosition()\n    -- Search for enemies\n    local enemies = Game.FindPlayersInCylinder(center, RADIUS, {ignoreTeams = ability.owner.team})\n    for _, enemy in ipairs(enemies) do\n        -- Interrupt all their abilities\n        local enemyAbilities = enemy:GetAbilities()\n        for _,a in ipairs(enemyAbilities) do\n            a:Interrupt()\n        end\n    end\nend\n\nability.executeEvent:Connect(OnExecute)\n</code></pre> <p>See also: CoreObject.parent | Ability.owner | Player.GetWorldPosition | Game.FindPlayersInCylinder | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#actionname","title":"<code>actionName</code>","text":"<p>Even though some API properties are read-only, they are useful is solutions such as user interface. In this example, a client context script searches the local player's list of abilities to find one that matches the action name (input) designated for this UI component. When it's found, the ability's name is written to the UI Text object.</p> <pre><code>--Client script\nlocal ACTION_NAME = script:GetCustomProperty(\"ActionName\")\nlocal NAME_UI = script:GetCustomProperty(\"NameUIText\"):WaitForObject()\n\nfunction GetLocalPlayerAbilityWithActionName()\n    local player = Game.GetLocalPlayer()\n    local abilities = player:GetAbilities()\n\n    for _, ability in pairs(abilities) do\n        if ability.actionName == ACTION_NAME then\n            return ability\n        end\n    end\n\n    return nil\nend\n\nfunction Tick()\n    local ability = GetLocalPlayerAbilityWithActionName()\n    if ability then\n        NAME_UI.text = ability.name\n    end\nend\n</code></pre> <p>See also: CoreObject.name | CoreObjectReference.WaitForObject | Game.GetLocalPlayer | Player.GetAbilities | UIText.text</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#animation","title":"<code>animation</code>","text":"<p>In this example, the <code>ProcessAbilities()</code> function can be called once, such as at the beginning of a round, to take inventory of a player's abilities and classify them based on animation. This example also demonstrates how to disconnect event listeners so that we don't listen for the same event multiple times.</p> <pre><code>--Server script\nfunction OnMelee1HandCast(ability)\n    print(\"One-handed melee attack\")\nend\n\nfunction OnMelee2HandCast(ability)\n    print(\"Two-handed melee attack\")\nend\n\nlocal abilityEventListeners = {}\n\nfunction CleanupListeners(player)\n    -- If we have previously processed this player, cleanup all listeners\n    if abilityEventListeners[player] then\n        for i, eventListener in ipairs(abilityEventListeners[player]) do\n            eventListener:Disconnect()\n        end\n        abilityEventListeners[player] = nil\n    end\nend\n\nfunction ProcessAbilities(player)\n    CleanupListeners(player)\n\n    local allAbilities = player:GetAbilities()\n\n    for _, ability in ipairs(allAbilities) do\n        if string.match(ability.animation, \"melee\") then\n            local eventListener\n            if string.match(ability.animation, \"1h\") then\n                eventListener = ability.castEvent:Connect(OnMelee1HandCast)\n            else\n                eventListener = ability.castEvent:Connect(OnMelee2HandCast)\n            end\n            table.insert(abilityEventListeners[player], eventListener)\n        end\n    end\nend\n\n-- Lets also cleanup when a player leaves the game, as perhaps their ability objects might stay in the game.\nGame.playerLeftEvent:Connect(CleanupListeners)\n</code></pre> <p>See also: EventListener.Disconnect | Player.GetAbilities | Ability.castEvent | Event.Connect | Game.playerLeftEvent | CoreLua.print</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#canactivatewhiledead","title":"<code>canActivateWhileDead</code>","text":"<p>Some games may have abilities that can be used while the player is dead. In this example, we have abilities that can only be activated while dead. If not dead, then it's interrupted.</p> <pre><code>--Server script\nlocal ability = script:FindAncestorByType(\"Ability\")\n\nfunction OnCast(ability)\n    if ability.canActivateWhileDead and not ability.owner.isDead then\n        ability:Interrupt()\n    end\nend\n\nability.castEvent:Connect(OnCast)\n\n--[[#description\n    On the client context, a user interface component that displays ability details is hidden until the player dies:\n]]\nlocal abilityCanvas = script:GetCustomProperty(\"Canvas\")\nlocal ACTION_NAME = script:GetCustomProperty(\"ActionName\")\n\nfunction Tick(deltaTime)\n    local ability = GetLocalPlayerAbilityWithActionName()\n\n    if ability\n    and ability.isEnabled\n    and ability.canActivateWhileDead\n    and ability.owner\n    and ability.owner.isDead then\n\n        abilityCanvas.visibility = Visibility.INHERIT\n    else\n        abilityCanvas.visibility = Visibility.FORCE_OFF\n    end\nend\n\n-- Searches the local player's abilities until one with a matching action name is found\n-- The ACTION_NAME search criteria should be set in the custom property\nfunction GetLocalPlayerAbilityWithActionName()\n    local abilities = Game.GetLocalPlayer():GetAbilities()\n    for _, ability in pairs(abilities) do\n        if ability.actionName == ACTION_NAME then\n            return ability\n        end\n    end\n\n    return nil\nend\n</code></pre> <p>See also: CoreObject.FindAncestorByType | Ability.owner | Player.isDead | Event.Connect | CoreLua.Tick</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#canbeprevented","title":"<code>canBePrevented</code>","text":"<p>In this example, an ability recognizes that it has been interrupted by the activation of another, special ability, that is setup to serve for animation cancelling. The <code>canBePrevented</code> property is usually true in this game, but in this special case it has been configured as false so that it can be activated at any time. The player gains vertical impulse as result of the synergy and hears a small audio cue that helps communicate the mechanic.</p> <pre><code>--Server script\nlocal ability = script.parent\nlocal cancelSound = script:GetCustomProperty(\"CancelSound\")\n\nfunction OnInterrupted(ability)\n    local player = ability.owner\n    if not Object.IsValid(player) then return end\n\n    for _, a in ipairs(player:GetAbilities()) do\n        if a:GetCurrentPhase() ~= AbilityPhase.READY and not a.canBePrevented then\n            player:AddImpulse(Vector3.UP * 1000)\n            World.SpawnAsset(cancelSound, {position = player:GetWorldPosition()})\n            return\n        end\n    end\nend\n\nability.interruptedEvent:Connect(OnInterrupted)\n</code></pre> <p>See also: CoreObject.parent | Ability.owner | Object.IsValid | Player.GetAbilities | Vector3.UP | World.SpawnAsset | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#castphasesettings","title":"<code>castPhaseSettings</code>","text":"","tags":["API"]},{"location":"libs/_template_/#executephasesettings","title":"<code>executePhaseSettings</code>","text":"","tags":["API"]},{"location":"libs/_template_/#recoveryphasesettings","title":"<code>recoveryPhaseSettings</code>","text":"","tags":["API"]},{"location":"libs/_template_/#cooldownphasesettings","title":"<code>cooldownPhaseSettings</code>","text":"<p>In this example, a function in a client context script can be called to show the elapsed times for an ability. The UI Text it controls displays how many seconds are remaining in the current phase, and the color of the text blends from black to white to indicate the percentage of completion. Although the Execute and Recovery phases are actually separate, they are here presented to the player as a single phase.</p> <pre><code>--Client script\nlocal COUNTDOWN_TEXT = script:GetCustomProperty(\"CountdownText\"):WaitForObject()\n\nfunction UpdateForAbility(ability)\n    local currentPhase = ability:GetCurrentPhase()\n\n    local percent = 1\n    local cooldownText = \"Ready\"\n\n    if currentPhase ~= AbilityPhase.READY then\n        local phaseDuration\n        local timeRemaining = ability:GetPhaseTimeRemaining()\n\n        if currentPhase == AbilityPhase.CAST then\n            phaseDuration = ability.castPhaseSettings.duration\n        elseif currentPhase == AbilityPhase.EXECUTE then\n            -- In the case of Execute and Recovery phases, we can show those as a single one\n            local recoveryD = ability.recoveryPhaseSettings.duration\n            phaseDuration = ability.executePhaseSettings.duration + recoveryD\n            timeRemaining = timeRemaining + recoveryD\n        elseif currentPhase == AbilityPhase.RECOVERY then\n            phaseDuration = ability.recoveryPhaseSettings.duration\n        else --currentPhase == AbilityPhase.COOLDOWN\n            phaseDuration = ability.cooldownPhaseSettings.duration\n        end\n\n        if phaseDuration &gt; 0 then\n            percent = 1 - timeRemaining / phaseDuration\n        end\n        cooldownText = string.format(\"%.1f\", timeRemaining)\n    end\n\n    COUNTDOWN_TEXT.text = cooldownText\n\n    local c = Color.Lerp(Color.BLACK, Color.WHITE, percent)\n    COUNTDOWN_TEXT:SetColor(c)\nend\n</code></pre> <p>See also: CoreObject.GetCustomProperty | CoreObjectReference.WaitForObject | Ability.GetCurrentPhase | AbilityPhaseSettings.duration | UIText.text | Color.Lerp</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#isenabled","title":"<code>isEnabled</code>","text":"<p>In this example, an equipment is setup with multiple abilities that all use the same action binding. This script cycles through the abilities, making sure only one is enabled at a time. The <code>owner</code> property is cleared for the previous ability and set for the next one, as part of ensuring the correct one activates when the binding is pressed.</p> <pre><code>--Server script\nlocal equipment = script:FindAncestorByType(\"Equipment\")\nlocal abilities = {}\nlocal abilityIndex = 1\n\nfunction OnAbilityRecovery(ability)\n    if (#abilities &gt; 1) then\n        abilities[abilityIndex].isEnabled = false\n        abilities[abilityIndex].owner = nil\n\n        abilityIndex = abilityIndex + 1\n        if (abilityIndex &gt; #abilities) then\n            abilityIndex = 1\n        end\n\n        abilities[abilityIndex].isEnabled = true\n        abilities[abilityIndex].owner = equipment.owner\n    end\nend\n\nfor _, child in pairs(equipment:FindDescendantsByType(\"Ability\")) do\n    table.insert(abilities, child)\n\n    child.isEnabled = (#abilities == 1)\n\n    child.recoveryEvent:Connect(OnAbilityRecovery)\nend\n</code></pre> <p>See also: CoreObject.FindAncestorByType | Ability.owner | Equipment.owner | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#owner","title":"<code>owner</code>","text":"<p>Usually, abilities are presented as part of an equipment, but that isn't a requirement. In this example, when new players join the game they are assigned an ability through the use of the <code>owner</code> property.</p> <pre><code>--Server script\nlocal abilityTemplate = script:GetCustomProperty(\"AbilityTemplate\")\n\nfunction OnPlayerJoined(player)\n    local ability = World.SpawnAsset(abilityTemplate)\n    ability.owner = player\nend\n\nGame.playerJoinedEvent:Connect(OnPlayerJoined)\n</code></pre> <p>See also: CoreObject.GetCustomProperty | World.SpawnAsset | Player.owner | Game.playerJoinedEvent | Event.Connect</p>","tags":["API"]},{"location":"libs/_template_/#tutorials","title":"Tutorials","text":"<p>Abilities in Core</p>","tags":["API"]},{"location":"libs/lua-dpapi/","title":"LuaDPApi","text":"<p>LuaDPApi provides an interface to the Microsoft Data Protection API. It implements a thin LUA wrapper interface over the <code>CryptProtectData</code> and <code>CryptUnprotectData</code> API calls. </p> <p>The main purpose is to store secrets (like passwords, or API token etc.) in a configuration file (like to OGS <code>station.ini</code>) without exposing the sensitive data to the world (e.g. if storing backups of these configuration files or versioning these files through git). This works by encrypting the secret data and writing the encrypted string into the configuration file. The application reading the configuration file can the decrypt the data and use it.</p> <p>In the background, the Microsoft Data Protection API encrypts/decrypts data by deriving an encryption key based on either the unique machine-id or a user-specific id:</p> <ul> <li>If the scope during the encryption is the machine-id, then all users, who are able to log on to this machine, will be able to decrypt the data. </li> <li>If the scope during the encryption is the user-id, then only the user, who encrypted the data will be able to decrypt later. Changes top the user password are tracked internally, so even after a password change, the user will be able to decrypt. If a users password is reset, then no access to the encrypted data is possible anymore.</li> </ul> <p>Note, that in an ActiveDirectory environment, backup keys are stored on the domain controller - allowing the domain administrator to decrypt, too. </p> <p>In addition to the user/machine-scope, an additional <code>enthropy</code> parameter can be used during encryption. In this case, the <code>enthropy</code>-data is added as part of the encryption key - effectively allowing successful decryption only, if the very same <code>enthropy</code>-data is added during decryption. This is e.g. used by the Edge browser to encrypt website passwords - the <code>entropy</code> data is the website URL, so without knowng the actual URL, no password can be decrypted.</p>","tags":["API"]},{"location":"libs/lua-dpapi/#module","title":"Module","text":"<p>The LuaDPApi module provides global functions to access the Microsoft Data Protection API.</p>","tags":["API"]},{"location":"libs/lua-dpapi/#functions","title":"Functions","text":"Function Name Return Type Description Tags <code>protect(data: string, scope: string = 'machine' entropy: string = nil)</code> <code>data: string</code> or <code>nil, win32error: integer</code> Encrypts the given data (binary string) using the given scope (one of 'maschine' or 'user') and entropy. Returns the encrypted data (as a binary string) or nil and the Win32 API error code. None <code>unprotect(data: string, entropy: string = nil)</code> <code>data: string</code> or <code>nil, win32error: integer</code> Dencrypts the given data (binary string) using the given entropy. Returns the decrypted data (as a binary string) or nil and the Win32 API error code. None <p>Info</p> <p>Note that the LUA functions pass raw data strings to the underlying Microsoft Data Protection API functions. Encoding and decoding text strings (e.g. to read/write the encrypted binary data from/to a configuration file) must be handled by additional code.</p> <p>Tip</p> <p>As encrypted data is binary, for configuration files, it is usually stored as a base64 encoded string. Use the LUA <code>mime</code> library (part of the <code>luasocket</code> library) to encode and decode a base64 string (see below for sample code). Also make sure to use the same text encoding for encryption and decryption (LUA uses UTF8-strings)!</p>","tags":["API"]},{"location":"libs/lua-dpapi/#examples","title":"Examples","text":"","tags":["API"]},{"location":"libs/lua-dpapi/#encrypt-a-string","title":"Encrypt a string","text":"<p>This sample shows how to encrypt a given plaintext string (LUA string, UTF8-encoded) and encode the encrypted data into a base64 string.</p> <pre><code>local dpapi = require('luadpapi')  -- load the DPAPI\nlocal mime = require('mime')       -- load luasocket/mime (base64)\n\n-- Sample plaintext password (or connection string, etc)\nlocal plaintext = 'MySuperSecretPassword' \n\n-- Encrypt the plaintext for the 'machine' scope. All users logged \n-- into the same machine will be able to decrypt the data later.\n-- encrypt (usually done at the commandline through powershell):\nlocal encrypted_data, err = dpapi.protect(plaintext, 'machine') \nif encrypted_data == nil then\n    print(\"ERROR: encrypt failed, err=\", err)\n    os.exit(-1)\nend\n\n-- Do a base64 encode of the encrypted data for storing in *.ini file:\nlocal encrypted_b64 = mime.b64(encrypted_data)     \n\n-- TODO: save to some text file, but for now just print it\nprint(\"encrypted, base64 encoded data: \", encrypted_b64)\n</code></pre>","tags":["API"]},{"location":"libs/lua-dpapi/#decrypt-base64-encoded-data","title":"Decrypt base64-encoded data","text":"<p>This sample shows how to decrypt previously encrypted and base64 encoded data. </p> <pre><code>local dpapi = require('luadpapi')   -- load the DPAPI\nlocal mime = require('mime')        -- load luasocket/mime (base64)\n\n-- Sample plaintext password (or connection string, etc)\n-- !!! Make sure to paste the data generated from the previous sample!\nlocal encrypted_b64 = 'AQAAANCMnd8BFdERjHoAwE/Cl+'...'ylQ=' \n\n-- Convert from base64 to raw data\nlocal encrypted = mime.unb64(encrypted_b64)\n\n-- Decrypt the raw data.\nlocal decrypted_data, err = dpapi.unprotect(encrypted) \nif decrypted_data == nil then\n    print(\"ERROR: decrypt failed, err=\", err)\n    os.exit(-1)\nend\n\n-- TODO: use the decrypted data - assume this is a string and print it:\nprint(\"decrypted data: \", decrypted_data)\n</code></pre>","tags":["API"]},{"location":"libs/lua-dpapi/#encryptdecrypt-using-powershell","title":"Encrypt/decrypt using Powershell","text":"<p>The DPAPI is also implemented in the [Security.Cryptography.ProtectedData] DotNET assembly, so  these functions can be also be used from Powershell.</p> <p>Warning</p> <p>In contrast to LUA, Powershell by default uses Unicode encodiung (16-Bit characters)!  For interoperability with LUA, make sure to encode/decode all strings to UTF8 (as shown  in the samples below)!</p> <p>The following samples are based on https://stackoverflow.com/questions/46400234/encrypt-string-with-the-machine-key-in-powershell.</p> <pre><code>Function Decrypt-WithMachineKey($s) {\n    Add-Type -AssemblyName System.Security\n\n    $SecureStr = [System.Convert]::FromBase64String($s)\n    $bytes = [Security.Cryptography.ProtectedData]::Unprotect($SecureStr, $null, [Security.Cryptography.DataProtectionScope]::LocalMachine)\n    $Password = [System.Text.Encoding]::UTF8.GetString($bytes)\n    return $Password\n}\n\nFunction Encrypt-WithMachineKey($s) {\n    Add-Type -AssemblyName System.Security\n\n    $bytes = [System.Text.Encoding]::UTF8.GetBytes($s)\n    $SecureStr = [Security.Cryptography.ProtectedData]::Protect($bytes, $null, [Security.Cryptography.DataProtectionScope]::LocalMachine)\n    $SecureStrBase64 = [System.Convert]::ToBase64String($SecureStr)\n    return $SecureStrBase64\n}\n\n# Encrypt\n$plaintext = \"MySuperSecretPassword\"\n$encrypted_b64 = Encrypt-WithMachineKey($plaintext)\n\n# Show the base64-string\n$encrypted_b64\n\n# Decrypt again\n$decrypted = Decrypt-WithMachineKey($encrypted_b64)\n\n# Show the decrypted string\n$decrypted\n</code></pre>","tags":["API"]},{"location":"libs/lua-dpapi/#sample-powershell-commandlet-for-encryption","title":"Sample powershell commandlet for encryption","text":"<p>The following script is a sample for a commandlet to encrypt sensitive data from the commandline. Use this as follows:</p> <pre><code>powershell -file myscript.ps1 -data \"MySuperSecretPassword\"\n</code></pre> <p>Warning</p> <p>Powershell uses the <code>$</code> (dollar) sign as a special character. If your plaintext password contains a dollar sign, then insert a backtick character plus the dollar sign instead of the original <code>$</code>.</p> <p>Here is the sample:</p> <pre><code># Encrypt a given text using DPAPI (machine key)\n# \n#   powershell -file myscript.ps1 -data \"MySuperSecretPassword\"\n#\nparam(\n    [Parameter(Mandatory=$True, Position=0)]\n    [System.String]\n    $data\n)\n\nFunction Encrypt-WithMachineKey($s) {\n    Add-Type -AssemblyName System.Security\n\n    $bytes = [System.Text.Encoding]::UTF8.GetBytes($s)\n    $SecureStr = [Security.Cryptography.ProtectedData]::Protect($bytes, $null, [Security.Cryptography.DataProtectionScope]::LocalMachine)\n    $SecureStrBase64 = [System.Convert]::ToBase64String($SecureStr)\n    return $SecureStrBase64\n}\n\n# Encrypt\n$encrypted_b64 = Encrypt-WithMachineKey($data)\n\n# Show the base64-string\n$encrypted_b64\n</code></pre>","tags":["API"]},{"location":"libs/lua-hid/","title":"LuaHID","text":"<p>LuaHID provides an interface to access USB devices over the <code>HID</code> (human input device) protocol. It implements a thin LUA wrapper interface over the  cross platform hidapi library (hidapi.dll, see  signal11/hidapi (github.com), licensed under BSD License). The code is derived from ynezz/luahidapi (github.com) (MIT License) and adopted to OGS.</p> <p>Note, that although USB mice and keyboards are technically HID devices, the Windows API does not allow to access these through the HID API (for security reasons). All other (custom) USB HID devices should work.</p>","tags":["API"]},{"location":"libs/lua-hid/#module","title":"Module","text":"<p>The LuaHID module provides global functions to access the systems HID API. Before calling any other function of the module, the <code>init()</code> function must be called. </p> <p>To actually connect to a physical device, an instance of the <code>HidDevice</code> object must be created (see #class_hiddevice below) by calling the <code>open()</code> function. This requires specifying the VID (vendor ID) and PID (device id) and (optionally) the SN (serial number). If the parameters are not known beforehand, they may be listed through calling the module level <code>enumerate()</code> function. This returns a table of all currently connected devices. Specific device actions (like reading/writing) can then be executed on the object returned from the <code>open()</code> call.</p>","tags":["API"]},{"location":"libs/lua-hid/#properties","title":"Properties","text":"Property Name Return Type Description Tags <code>_VERSION</code> <code>string</code> Current version of the LuaHID module. See also the <code>version_mod()</code> function to get more details about the DLL module version. Read-Only <code>_TIMESTAMP</code> <code>string</code> Timestamp of the last build of the LuaHID module. Read-Only","tags":["API"]},{"location":"libs/lua-hid/#functions","title":"Functions","text":"Function Name Return Type Description Tags <code>init()</code> <code>boolean</code> Initializes the LuaHID library. Returns true on success, nil on failure. None <code>exit()</code> <code>boolean</code> Cleans up and terminates the LuaHID library. Returns true on success, nil on failure. None <code>enumerate(integer vid, integer pid)</code><code>enumerate()</code> <code>hidenum</code> Returns a HID device enumeration object for HID devices that matches given vid, pid pair. Enumerates all HID devices if no arguments provided or (0,0) used.IMPORTANT: Mouse and keyboard devices are not visible on WindowsReturns nil if failed. None <code>open(string path)</code><code>open(number vid, number pid)</code> <code>HidDevice</code> Opens a HID device using a path name or a vid,pid pair. Returns a HID device object on success - specifying a serial number is currently not implemented. Returns nil on failure. None <code>write(HidDevice dev, string report)</code><code>write(HidDevice dev, integer report_id, string report)</code> <code>integer</code> Writes the given <code>report</code> data string to the <code>report_id</code> (0 by default). Returns number of bytes actually sent on success, nil on failure. None <code>read(HidDevice dev, integer report_size [, timeout_msec])</code> <code>string</code> Reads data from the given device. If a device has multiple reports, the first byte indicates the report ID and one extra byte needs to be allocated via report_size. For a normal call, <code>timeout_msec</code> can be omitted and blocking will depend on the selected option setting. Passing <code>timeout_msec</code> == -1 will always block. Returns the report data (as string) on success, nil on failure. None <code>set(HidDevice dev, string option)</code> <code>integer</code> Set the read blocking option, allowed parameters are <code>noblock</code> and <code>block</code>. Returns true on success, nil on failure. None <code>getstring(HidDevice dev, string option)</code> <code>string</code> Reads the given option property from the device. Currently known option names are <code>manufacturer</code>, <code>product</code> and <code>serial</code>. Returns the option value on success, nil on failure. None <code>setfeature(HidDevice dev, integer feature_id, string data)</code> <code>integer</code> Send a feature report for the given <code>feature_id</code> with the given <code>feature_data</code>. Returns the number of bytes actually sent on success, nil on failure. None <code>getfeature(HidDevice dev, integer feature_id, integer feature_size)</code> <code>string</code> Get (read) a feature report for the given <code>feature_id</code>. A 0 is used for a single feature report. Returns the feature data (as a string) on success, nil on failure. None <code>error(HidDevice dev)</code> <code>string</code> Returns a string (as ASCII) describing the last error occurred for the device or nil if there was no error. None <code>close(HidDevice dev)</code> <code>None</code> Closes the given HidDevice object. None <code>msleep(integer milliseconds)</code> <code>None</code> Convenience function to sleep a number of milliseconds. None <code>version_mod()</code> <code>string, table</code> Returns the file version info of the LuaHID DLL (as a string in the from \"major.minor.build-hi,build-low\" and a table with the same values. None","tags":["API"]},{"location":"libs/lua-hid/#class-hiddeviceinfo","title":"Class HidDeviceInfo","text":"<p>The HidDeviceInfo table provides information about a USB HID device connected to the system. The HidDeviceInfo is retrieved by calling the <code>enumerate()</code> function and iterating the result by calling the <code>next()</code> member. </p>","tags":["API"]},{"location":"libs/lua-hid/#properties_1","title":"Properties","text":"Property Name Return Type Description Tags <code>path</code> <code>string</code> System specific device path. Read-Only <code>vid</code> <code>integer</code> Vendor ID of the device. Read-Only <code>pid</code> <code>integer</code> Product ID of the device. Read-Only <code>serial_number</code> <code>string</code> Device serial number. Read-Only <code>release</code> <code>integer</code> Release number (version) of the device. Read-Only <code>manufacturer_string</code> <code>string</code> Manufacturer name. Read-Only <code>product_ _string</code> <code>string</code> Product name. Read-Only <code>usage_page</code> <code>integer</code> HID usage page of the device. Read-Only <code>usage</code> <code>integer</code> HID usage of the device. Read-Only <code>interface</code> <code>integer</code> Interface number of the device. Read-Only","tags":["API"]},{"location":"libs/lua-hid/#class-hidenum","title":"Class HidEnum","text":"<p>The HidEnum class is actually an iterator and represents the list returned from calling the <code>enumerate</code> module function. Each element of the list represents a connected USB HID device and has the properties shown in the following section.  To iterate the list, call the <code>next()</code> instance function - each call to next returns a <code>HidDeviceInfo</code> table and internally advances to the next item.</p>","tags":["API"]},{"location":"libs/lua-hid/#functions_1","title":"Functions","text":"Function Name Return Type Description Tags <code>next()</code> <code>HidDevice</code> Returns the current device info data and steps on to the next element in the list. None <code>close()</code> <code>None</code> Closes the iterator and frees any resources. There is normally no need to call this, as the object is garbage collected automatically. None","tags":["API"]},{"location":"libs/lua-hid/#class-hiddevice","title":"Class HidDevice","text":"","tags":["API"]},{"location":"libs/lua-hid/#functions_2","title":"Functions","text":"<p>The member functions of HidDevice are wrapped functions of the module. The following lines are identical:</p> <pre><code>local hidapi = require('luahid')\n-- ...\n-- assume dev is a HidDevice object returned from calling open()\n-- The following are identical:\nhidapi.write(dev, report_id, report_data)\ndev:write(report_id, report_data)\n</code></pre> Function Name Return Type Description Tags <code>write(string report)</code><code>write(HidDevice dev, integer report_id, string report)</code> <code>integer</code> See <code>LuaHID.write(...)</code> None <code>read(integer report_size [, timeout_msec])</code> <code>string</code> See <code>LuaHID.read(...)</code> None <code>set(HidDevice dev, integer option)</code> <code>integer</code> See <code>LuaHID.set(...)</code> None <code>getstring(HidDevice dev, string option)</code> <code>string</code> See <code>LuaHID.getstring(...)</code> None <code>setfeature(HidDevice dev, integer feature_id, string data)</code> <code>integer</code> See <code>LuaHID.setfeature(...)</code> None <code>getfeature(HidDevice dev, integer feature_id, integer feature_size)</code> <code>string</code> See <code>LuaHID.getfeature(...)</code> None <code>error()</code> <code>string</code> See <code>LuaHID.error(...)</code> None <code>close(HidDevice dev)</code> <code>None</code> See <code>LuaHID.close(...)</code> None","tags":["API"]},{"location":"libs/lua-hid/#examples","title":"Examples","text":"","tags":["API"]},{"location":"libs/lua-hid/#enumerate-connected-devices","title":"Enumerate connected devices","text":"<p>This sample lists all connected HID devices and shows some of their properties. <pre><code>-- Load the LuaHID module\nlocal hidapi = require('luahid')\nprint(string.format(\"Lib VERSION %s build on %s\", hid._VERSION, hid._TIMESTAMP))\n\n-- Initialize the library\nif hidapi.init() then\n    print(\"hid library: init\")\nelse\n    print(\"hid library: init error\")\n    return\nend\n\n-- Enumerate the currently connected devices and print some information\nlocal enum = hidapi.enumerate()\nif not enum then\n    print(\"Enumeration: no device found or enumeration failed!\")\n    return\nelse\n    while true do\n        local dev = enum:next()\n        if not dev then break end\n            print(\"Device found:\")\n            print(string.format(\"path = '%s'\", dev.path))\n            print(string.format(\"vid = 0x%04X\", dev.vid))\n            print(string.format(\"pid = 0x%04X\", dev.pid))\n            print(string.format(\"serial_number = '%s'\", dev.serial_number))\n        end\n    end\nend\n\n-- Do a clean shutdown\nif hidapi.exit() then\n    print(\"hid library: exit\")\nelse\n    print(\"hid library: exit error\")\n    return\nend\n</code></pre></p>","tags":["API"]},{"location":"libs/lua-hid/#readwrite-device-report-data","title":"Read/write device report data","text":"<p>This sample tries to connect to a specific device using a given VID/PID and writes/reads some data in non-blocking mode.  <pre><code>-- Load the LuaHID module\nlocal hidapi = require('luahid')\nprint(string.format(\"Lib VERSION %s build on %s\", hid._VERSION, hid._TIMESTAMP))\n\n-- Initialize the library\nif hid.init() then\n    print(\"hid library: init\")\nelse\n    print(\"hid library: init error\")\n    return\nend\n\n-- Open a device by VID/PID\nUSB_DEVICE_VID = 0x04D8\nUSB_DEVICE_PID = 0x8ABC\nUSB_REPORT_SIZE = 4\nlocal dev = hidapi.open(USB_DEVICE_VID, USB_DEVICE_PID)\nif not dev then\n    print(\"Open: unable to open test device\")\n    return\nend\nprint(\"Open: opened test device\")\n\n-- Read the serial number\nlocal sn = dev:getstring(\"serial\")\nif sn then\n    print(\"Product String: \"..sn)\nelse\n    print(\"Unable to read product string\")\n    return\nend\n\n-- set non-blocking reads\nif not dev:set(\"noblock\") then\n    print(\"Failed to set non-blocking option\")\n    return\nend\n\n-- Try to read from the device. There shoud be no\n-- data here, but execution should not block.\nlocal rx = dev:read(USB_REPORT_SIZE)\nif rx then\n    print(\"Done non-blocking read test\")\n    print(\"Size of report read = \"..#rx)\nelse\n    print(\"Read error during non-blocking read test\")\n    return\nend\n\n-- Prepare and write report; report 0 is implied\nlocal tx = string.char(0x12, 0x34, 0x56, 0x78)\nlocal res = dev:write(tx)\nif not res then\n    print(\"Unable to write()\")\n    print(\"Error: \"..dev:error())\n    return\nend\n\n-- Try reading data\nlocal rx\nfor i = 1, 10 do\n    -- a non-infinite read loop\n    -- since we read immediately right after writing, the device buffer\n    -- will be empty, it will NAK, and an empty string is returned\n    rx = dev:read(USB_REPORT_SIZE)\n    if not rx then\n        print(\"Unable to read()\")\n        print(\"Error: \"..dev:error())\n        return\n    elseif rx == \"\" then\n        print(\"Waiting...\")\n    else\n        break\n    end\n    for j = 1,200000 do end -- short delay\nend\nif #rx &gt; 0 then\n    print(\"Successfully read data from device!\")\nend\n\n-- Close the device\ndev:close()\nprint(\"Close: closed test device\")\n\n-- Do a clean shutdown\nif hidapi.exit() then\n    print(\"hid library: exit\")\nelse\n    print(\"hid library: exit error\")\n    return\nend\n</code></pre></p>","tags":["API"]},{"location":"libs/lua-hid/#more-samples","title":"More samples","text":"<p>More samples can be found in then <code>examples</code>-folder in the GitHub repository at luahidapi/doc/examples at master \u00b7 ynezz/luahidapi (github.com).</p>","tags":["API"]},{"location":"libs/lua-modbus/","title":"LuaModbus","text":"<p>LuaModbus provides a wrapper over libModbus (see libmodbus (github.com), LGPL-2.1) to access Modbus-TCP/UDP-Devices from LUA. In addition to wrapping the libModbus library, LuaModbus also adds a background thread to cyclically read/write a set of registers and automatically reconnect the connection. Using this thread, after the connection is (re)established, a register can automatically be set to a given value (e.g. for setting a \"startup\" bit as seen in the Rexroth/Phoenix Contact I/O modules). The actual LUA wrapper is based on the etactica/lua-libmodbus (github.com) LUA bindings (MIT-License), but heavily modified for use with OGS.</p> <p>Unless otherwise noted, LuaModbus implements the same set of features as the original lua-libmodbus, so the library documentation (Reference (etactica.github.io)) is a very good source of information.</p> <p>Content will follow soon...</p>","tags":["API"]},{"location":"libs/lua-net/","title":"LuaNet","text":"<p>LuaNet provides simple to use functions for REST/OpenAPI calls using http and https protocols. Compared to luasocket and luassl, it uses the the Windows infrastructure and therefore correctly works with system proxies. Feature-wise it is not as flexible as luasocket/luassl at the moment (e.g. no direct access to all headers), but it is good enough for OAuth and SAP endpoints (like the SAP Digital Manufacturing Cloud).</p> <p>The basic functions work in a blocking mode, i.e. the process calling the function is blocked until a response from the endpoint is received. However, there are also asynchronous functions for starting a (post) request and polling for the completion. This is especially useful for long-running OpenAPI calls (like some SAP digital manufacturing cloud endpoints).</p> <p>Info</p> <p>All functions in LuaNet work transparently, i. e. use raw text strings (binary) for request and response body texts. For OpenAPI/REST services typically JSON encoded objects are used. From the large number of lua json libraries (e. g. see Awesome Lua), we recommend to use Lua CJSON. If you use another library, make sure it support UTF8 correctly! </p>","tags":["API"]},{"location":"libs/lua-net/#module","title":"Module","text":"<p>The LuaNet module provides global functions to execute http/https requests.</p>","tags":["API"]},{"location":"libs/lua-net/#functions","title":"Functions","text":"<p>Info</p> <p>For authentication, currently two options are supported: basic authentication through username/password (if user/pass parameters are non-empty) or OAuth2 client credentials (use the <code>token</code> parameter to pass data received from the <code>get_oauth_token</code> function). </p> <p>The following table lists blocking functions: </p> Function Name Return Type Description Tags <code>get(url: string, user: string = nil, pass: string = nil)</code> <code>data: string, status: number, statustext: string, data: string</code> or <code>nil, status: number, statustext: number</code> Executes a blocking get request for the given URL. If the server returns (http) status = 200, then the response is considered valid. In any case, <code>status</code> and <code>statustext</code> will receive the http response header status data. If a response body is available, then this is returned in the <code>data</code> return value (even if status ~= 200). None <code>get_oauth_token(url: string, user: string = nil, pass: string = nil)</code> <code>status: number, data: string</code> or <code>nil, status: number, statustext: string</code> Requests client credentials from an OAuth2 server (granttype = client_credentials). None <code>post(url: string, body: string = nil, auth_bearer_token: string = nil, user: string = nil, pass: string = nil)</code> <code>status: number, data: string, statustext: string</code> Send a post request to the given endpoint <code>URL</code>, with post <code>data</code> in the request body, optinally adding the <code>auth_bearer_token</code> value to the <code>Authorization</code> header. None <code>put(url: string, body: string = nil, auth_bearer_token: string = nil, user: string = nil, pass: string = nil)</code> <code>status: number, data: string, statustext: string</code> Send a put request to the given endpoint <code>URL</code>, with put <code>data</code> in the request body, optinally adding the <code>auth_bearer_token</code> value to the <code>Authorization</code> header. None <p>The following table lists the non-blocking functions:</p> Function Name Return Type Description Tags <code>post_async(url: string, body: string = nil, auth_bearer_token: string = nil, user: string = nil, pass: string = nil)</code> <code>handle: number</code> or <code>nil</code> Starts an async post request (see the blocking <code>post</code> above for parameter descriptions). On success a <code>handle</code> is returned, which can be used for polling the request status or aborting the request. None <code>put_async(url: string, body: string = nil, auth_bearer_token: string = nil, user: string = nil, pass: string = nil)</code> <code>handle: number</code> or <code>nil</code> Starts an async put request (see the blocking <code>put</code> above for parameter descriptions). On success a <code>handle</code> is returned, which can be used for polling the request status or aborting the request. None <code>abort_async_request(handle: number)</code> (no return value) Tries to abort a currently active request identified by the <code>handle</code> value (as returned from <code>post_async()</code>. If the request is currently active, it might block for a short time - until the request is actually cancelled. If a request was cancelled, then further calls to <code>poll_async_request()</code> will return <code>nil</code>, as the internal request object for the given handle was deleted and does not exist anymore. None <code>poll_async_request(handle: number)</code> <code>requeststate: number, status: number, data: string, statustext: string</code>  or <code>nil, errorcode: number, errortext: string</code> Checks the request state of a pending request and returns the current state in <code>requeststate</code>. If the 'handle' was not found, nil is returned for <code>requeststae</code>, else the current (internal) process step. A value of &gt;= 100 indicates, that the request has completed and the other return values are valid (see the blocking <code>post</code> above for result value descriptions). Note, that the internal request object is automatically deleted after <code>poll_async_request()</code> returns a status of &gt;= 100. None <p>Warning</p> <p>A request started through <code>post_async()</code> must be completed by either aborting the request through <code>abort_async_request()</code> or by polling the request (by using <code>poll_async_request</code>) until a state of &gt;= 100 is returned. If not, then the internal request object will not get deleted thus consuming more and more resource.</p>","tags":["API"]},{"location":"libs/lua-net/#examples","title":"Examples","text":"","tags":["API"]},{"location":"libs/lua-net/#simple-get-request","title":"Simple get request","text":"<p>This sample shows how to execute a simple https get request with basic authentication (e.g. typical surveillance camera).</p> <pre><code>local mime = require('mime')       -- load luasocket/mime (base64)\n\n-- Sample plaintext password (or connection string, etc)\nlocal plaintext = 'MySuperSecretPassword' \n\n-- Encrypt the plaintext for the 'machine' scope. All users logged \n-- into the same machine will be able to decrypt the data later.\n-- encrypt (usually done at the commandline through powershell):\nlocal encrypted_data, err = dpapi.protect(plaintext, 'machine') \nif encrypted_data == nil then\n    print(\"ERROR: encrypt failed, err=\", err)\n    os.exit(-1)\nend\n\n-- Do a base64 encode of the encrypted data for storing in *.ini file:\nlocal encrypted_b64 = mime.b64(encrypted_data)     \n\n-- TODO: save to some text file, but for now just print it\nprint(\"encrypted, base64 encoded data: \", encrypted_b64)\n</code></pre>","tags":["API"]},{"location":"libs/lua-net/#decrypt-base64-encoded-data","title":"Decrypt base64-encoded data","text":"<p>This sample shows how to decrypt previously encrypted and base64 encoded data. </p> <pre><code>local dpapi = require('luadpapi')   -- load the DPAPI\nlocal mime = require('mime')        -- load luasocket/mime (base64)\n\n-- Sample plaintext password (or connection string, etc)\n-- !!! Make sure to paste the data generated from the previous sample!\nlocal encrypted_b64 = 'AQAAANCMnd8BFdERjHoAwE/Cl+'...'ylQ=' \n\n-- Convert from base64 to raw data\nlocal encrypted = mime.unb64(encrypted_b64)\n\n-- Decrypt the raw data.\nlocal decrypted_data, err = dpapi.unprotect(encrypted) \nif decrypted_data == nil then\n    print(\"ERROR: decrypt failed, err=\", err)\n    os.exit(-1)\nend\n\n-- TODO: use the decrypted data - assume this is a string and print it:\nprint(\"decrypted data: \", decrypted_data)\n</code></pre>","tags":["API"]},{"location":"tools/","title":"Tool configuration","text":""},{"location":"tools/#overview","title":"Overview","text":""},{"location":"tools/#stationini","title":"station.ini","text":""},{"location":"tools/doga-wifi/","title":"Doga BM/BMH/BMT-series wireless tools","text":"<p>The Doga BM/BMH/BMT-series wireless tools use Modbus/TCP for controlling tightening operations and reporting events, data and graphs. Also PSet modification are possible over Modbus/TCP.</p> <p></p> <p>OGS provides the <code>heDogaTool.dll</code> to implement the Doga communication protocol.</p>","tags":["tool","tightening"]},{"location":"tools/doga-wifi/#installation-and-configuration","title":"Installation and configuration","text":"","tags":["tool","tightening"]},{"location":"tools/doga-wifi/#installation","title":"Installation","text":"<p>For OGS versions &lt; V3.0.9, the Doga tool driver is not included in the OGS installer, so the <code>heDogaTool.dll</code> must be copied manually into the OGS installation folder (usually <code>c:\\program files(x86)\\Bosch Rexroth AG\\OGS V3.0</code>). </p>","tags":["tool","tightening"]},{"location":"tools/doga-wifi/#ogs-project-configuration","title":"OGS project configuration","text":"<p>The <code>Doga</code> driver is implemented in <code>heDogaTool.dll</code>. To use it with OGS, the driver must be loaded in the <code>[TOOL_DLL]</code> section of the projects <code>station.ini</code> configuration file (see also Tool configuration).</p> <p>A typical configuration of the <code>[TOOL_DLL]</code> section looks like the following:</p> <pre><code>[TOOL_DLL]\n; Load and enable the Doga tool interface DLL:\nheDogaTool.dll=1\n; ... other tool drivers ...\n</code></pre>","tags":["tool","tightening"]},{"location":"tools/doga-wifi/#tool-registration-and-configuration","title":"Tool registration and configuration","text":"<p>All <code>Doga</code>-tools are registered in the <code>[DOGA]</code> section of the projects <code>station.ini</code> file.</p> <p>The <code>[DOGA]</code> section mixes the tool parameters and the channel mapping (due to historic reasons) by combining the channel number and the parameter name/value in the <code>station.ini</code> entry. </p> <p>Each parameter is prefixed with the channel number and followed by parameter name as follows:</p> <pre><code>CHANNEL_&lt;two-digit channel&gt;_&lt;param name&gt;=&lt;param value&gt;\n</code></pre> <p>Where - <code>&lt;two-digit channel&gt;</code> is the channel number in the range 01...99 (the channel number maps 1:1 to the tool number from the workflow configuration)  - <code>&lt;param name&gt;</code> is the parameter name (see below) - <code>&lt;param value&gt;</code> is the actual parameter value for the given parameter</p> <p>Valid parameters (<code>&lt;param name&gt;</code>) are:</p> <ul> <li><code>CHANNEL_&lt;channel&gt;</code>: Define the IP address used to communicate with the tool.</li> <li><code>CHANNEL_&lt;channel&gt;_PORT</code>: Define the Modbus/TCP port number (note, Doga uses port 5000 instead of the default 502) for Doga communication.</li> </ul> <p>A sample <code>OpenProtocol</code> tool configuration (channel 01) would therefore look similar to the following:</p> <pre><code>; Setup Doga tool channels\n[DOGA]\n; Define communication parameters for OGS tool #6\nCHANNEL_06=10.10.2.112\nCHANNEL_06_PORT=5000\n; ... more tools ...\n</code></pre>","tags":["tool","tightening"]},{"location":"tools/doga-wifi/#tool-data-output","title":"Tool data output","text":"<p>Like other tools, the Doga tools can use the OGS buit-in connectivity options to send out data and curves (<code>Traceability</code> data) to backend data management systems (like ToolsNet, CSP I-P.M., Sciemetric QualityWorX, QualityR, etc.). </p> <p>To understand the system architecture and details on how to use data output in general, please see OGS Traceability. To setup <code>Traceability</code> for Doga tools, enable <code>Traceability</code> and add the Doga tools channel to the list of channels in the <code>[FTP_CLIENT]</code> section.</p> <p>Here is a sample setup:</p> <pre><code>[FTP_CLIENT]\nEnabled=1\n;... \n; (more settings)\n;...\n; Parameters for each channel:\nCHANNEL_06_INFO={ \"ChannelName\": \"WS010|AC_PF6000\", \"location name\": [\"Tool\", \"Line 2\", \"WS010\", \"default\", \"\", \"\", \"\"] }\n</code></pre> <p>The following parameters are required for the Doga tools, as the tool does not provide them through its interface:</p> <ul> <li><code>ChannelName</code>: Defines the station and channel name seperated by a pipe symbol (<code>&lt;station&gt;|&lt;channel&gt;</code>).</li> <li><code>location name</code>: Defines the location name values to use. Note that this setting depends on the Sys3xxGateway settings for processing the tightening results. Make sure to add the relevant information (like data link name, building, line name, etc.), so the tool can be registered in the correct organizational unit.</li> </ul> <p>NOTE: Currently documentation for curve output of the tool is not available from Doga. Therefore curve/graph output is not available in the traceability output yet.</p>","tags":["tool","tightening"]},{"location":"tools/doga-wifi/#tool-configuration","title":"Tool configuration","text":"","tags":["tool","tightening"]},{"location":"tools/doga-wifi/#prerequisites","title":"Prerequisites","text":"<p>The BM/BMH/BMT-series wireless tools are configured using the <code>ParaMonEx</code> software (available on request from the Doga support).  The firmware version of the tool must be &gt;= V4.00.2. </p> <p>WARNING: Firmware versions &lt; V4.00.2 are not supported by OGS, as they use an incompatible Modbus register mapping! This also applies to the Doga configuration software: DO NOT USE ParaMon or ParaMon III to configure the tools, only use ParaMonEx!</p>","tags":["tool","tightening"]},{"location":"tools/doga-wifi/#control-parameters","title":"Control parameters","text":"<p>The recommended settings for the tool using ParaMonEx are:</p> <p></p> <p>The following parameters should be set in the <code>Controller</code> section (please note, that due to translation issues, the term <code>driver</code> is used instead of <code>tool</code>):</p> <ul> <li>Event data select: Only enable <code>Fastening Ok</code> and <code>Fastening Nok</code> to prevent overwriting the result buffer with other data</li> <li>Driver auto lock: Set to <code>ON</code> to automatically disable the tool after a rundown.</li> <li>Initial Preset/model # when power on: Set to zero to prevent the tool after reeboot to operate without control.</li> <li>Error display reset time: Set to zero to block the tool until the error has been acknowledged. As the tool throws an error also for a NOK tightening, this would else allow unacknowledged NOK rundown to slip through without notice. </li> <li>Auto data output: Set to <code>OFF</code> to disable spontaneous data output (as this violates the Modbus protocol and can interfere with other communication).</li> <li>Driver lock after Wifi disconnect: Set to <code>ON</code> to disable the tool automatically, if the Wifi communication gets lost.</li> </ul>","tags":["tool","tightening"]},{"location":"tools/remote-tool/","title":"RemoteTool","text":"<p>OGS supports connecting tools over a <code>ToolGateway</code>. This enables advanced  tool management scenarios, e.g. \"roaming\" tools between multiple stations.</p> <p>Using the <code>RemoteTool</code> driver requires a <code>ToolGateway</code> running on a server - the server then actually controls the tool, whereas the OGS stations only communication with the <code>ToolGateway</code>. This allows delegating tool management to the central <code>ToolGateway</code>. </p> <p>For each tool managed through the <code>ToolGateway</code>, OGS only uses a generic <code>RemoteTool</code> type channel in its local configuration, the <code>ToolGateway</code> then has the actual tool-specific configuration (like e.g. OpenProtocol tools).</p>"},{"location":"tools/remote-tool/#installation","title":"Installation","text":"<p>The <code>RemoteTool</code> driver is implemented in <code>RemoteTool.dll</code>. To use any <code>RemoteTool</code> tool, the driver must be loaded in the <code>[TOOL_DLL]</code> section of the projects <code>station.ini</code> configuration file (see also Tool configuration).</p> <p>To enable the driver in station.ini, set it as follows:</p> <pre><code>[TOOL_DLL]\nRemoteTool.dll=1\n</code></pre> <p>The overall parameters for the <code>RemoteTool</code> driver are configured in the \u00b4[RemoteTool]<code>section. This is basically used to configure the</code>ToolGateway` connection parameters, here is a sample setup:</p> <pre><code>[RemoteTool]\nToolGateway_Addr=mytoolgateway.mycompany.com\nToolGateway_Port=\n</code></pre> <p>For more information about the driver parameters, see Driver Parameters below.</p>"},{"location":"tools/remote-tool/#tool-registration-and-configuration","title":"Tool registration and configuration","text":"<p>All <code>RemoteTool</code>-tools are registered in the <code>[CHANNELS]</code> section of the projects <code>station.ini</code> file.</p> <p>The <code>[CHANNELS]</code> section only defines a channel number to channel name mapping - the channel/tool specific settings are then configured in a seperate section defined by the channel name. Inside the section, a reference to the <code>RemoteTool</code> driver then links driver and channel accordingly.</p> <p>The overall layout is therefore as follows (sample is for channel 2):</p> <pre><code>[CHANNELS]\n# Map the channel/tool 2 to the 'RemoteTool_Nexo1'-section\n2=RemoteTool_Nexo1\n\n[RemoteTool_Nexo1]\n# link to the RemoteTool driver\nDRIVER=RemoteTool\n# more channel/tool specific parameters for this tool/driver\n</code></pre> <p>Please see Channel/tool parameter reference below for more information about the available parameters.</p>"},{"location":"tools/remote-tool/#channeltool-parameter-reference","title":"Channel/tool parameter reference","text":"<p>Currently, there are no channel/tool-specific parameters needed (other than specifying the <code>DRIVER=RemoteTool</code>) to use this driver. All concrete tool communication settings are to be configured on the <code>ToolGateway</code> server side. </p>"},{"location":"tools/remote-tool/#driver-parameter-reference","title":"Driver parameter reference","text":"<p>The driver parameters are defined in the <code>[RemoteTool]</code> section in the projects <code>station.ini</code>.</p> <p>The following parameters are available:</p>"},{"location":"tools/remote-tool/#toolgateway_addr","title":"ToolGateway_Addr","text":"<p>IP address or hostname of the tool gateway.</p>"},{"location":"tools/remote-tool/#toolgateway_port","title":"ToolGateway_Port","text":"<p>(optional)</p> <p>Port number to use for connecting to the tool gateway. If not given, the driver tries to use the RPC endpoint mapper using the service UUID to resolve the connection endpoint (might require additional firewall settings).</p>"},{"location":"tools/misc/aioi-pick2light/","title":"AIOI Pick2Light tool","text":"<p>The AIOI Pick2Light tools are interactive communication devices associated with each shelf location, guiding the operator by clearly indicating the exact position and, if necessary, the quantity of units to be picked or placed. The hardware comes in multiple models, each featuring colored LEDs integrated into a single confirmation button. This design allows for various operational configurations, offering more flexible ways to manage tasks. For example, it enables multiple workers to operate simultaneously in the same area, with each worker assigned a unique color. It also supports preparing multiple orders at once by a single operator, with different colors assigned to each order. (links? to aioi H/W setup )</p>","tags":["tool","pick2light"]},{"location":"tools/misc/aioi-pick2light/#installation-and-configuration","title":"Installation and configuration","text":"","tags":["tool","pick2light"]},{"location":"tools/misc/aioi-pick2light/#ogs-project-configuration","title":"OGS project configuration","text":"<p>OGS has an interface to add additional tool drivers by adding Windows-DLLs to the <code>[TOOL_DLL]</code> section in <code>station.ini</code>. To simplify the creation of custom tool drivers, OGS offers the heLuaTool.dll, which enables the development of tool drivers using pure LUA. With this functionality, the AIOI Pick2Light tool is seamlessly integrated into OGS, see Lua custom tools.</p>","tags":["tool","pick2light"]},{"location":"tools/misc/aioi-pick2light/#tool-registration-and-configuration","title":"Tool registration and configuration","text":"<p>According to the instructions provided in the Lua custom tools, a standard configuration for the <code>[LuaTool_Pick2Light]</code> section in <code>station.ini</code> is as follows:</p> <pre><code>[TOOL_DLL]\nheLuaTool.dll=1 \n\n[CHANNELS]\n20=LuaTool_Pick2Light \n\n[LuaTool_Pick2Light]\nDRIVER=heLuaTool\nTYPE=LUA_FLOWLIGHT\nIPADDR=controller_IPADDR\nIPPORT=controller_IPPORT\n</code></pre> <p>The typical parameters are:</p> <ul> <li><code>DRIVER</code>: The name of the windows dll that implements tool drivers.</li> <li><code>TYPE</code>: The name of the tool driver specified in your custom LUA tool driver.</li> <li><code>IPADDR</code>: Specify the IP address used for communication with the controller.</li> <li><code>IPPORT</code>: Specify the port number used for communication with the controller.</li> </ul>","tags":["tool","pick2light"]},{"location":"tools/misc/aioi-pick2light/#editor-configuration","title":"Editor configuration","text":"","tags":["tool","pick2light"]},{"location":"tools/misc/aioi-pick2light/#configuring-the-tool","title":"Configuring the tool","text":"<p>In the Tools section of the Editor, add a new tool named Pick2light and assign it to the appropriate channel (ensure the channel number matches the one specified in the <code>station.ini</code> file). Provide a name for the tool and, under the Task &amp; Action properties section, define the following properties: - <code>text</code>: The text to be displayed on the display - <code>farbe</code>: The color of the confirm button - <code>buzzer</code>: The buzzer sound setting, which can be set to 'OFF', 'ON', 'BLINK', or 'FAST_BLINK' - <code>segment</code>: The property of the display segment</p> <p>Assign a tool number to each property, as shown in the reference image below. You may also indicate the \"type\" for each property and provide a brief description.</p> <p></p>","tags":["tool","pick2light"]},{"location":"tools/misc/aioi-pick2light/#creating-a-job","title":"Creating a job","text":"<p>To set up a job and task with the appropriate operations and tools, follow the steps below:</p> <ol> <li>In the Jobs catalog, create a new job and then add a new task. In the operation section below, add an operation by selecting \"new operation.\"</li> <li>To assign an existing operation along with its tool, click the three dots next to the operation and select from the window that opens.</li> <li>To add a new operation, provide a name for the operation and assign a tool by clicking the three dots next to the tool, which will open the tools window. From there, select the \"Pick2Light\" tool. It is crucial to set the program (Prg) value to the Pick2Light tool address (also known as the bin number). </li> <li>Afterward, assign the newly created operation to the task, as shown in the image below. </li> <li>Finally, ensure that the correct values are assigned to the properties for each task. The values for each of the properties are discussed in the next section.</li> </ol> <p></p> <p>AIOI color, buzzer, segment properties</p>","tags":["tool","pick2light"]},{"location":"tools/misc/gui-input/","title":"GUI Input","text":"<p>The GUI Input tool is a custom interface that allows the operator to input values for a set of predefined parameters. It validates the entered values against their allowed ranges, and once the operator clicks the \"Accept\" button, the result is displayed, indicating whether the values are within the valid range or not. The GUI can accommodate up to 6 parameters for value entry.</p>","tags":["tool","guiInput"]},{"location":"tools/misc/gui-input/#installation-and-configuration","title":"Installation and configuration","text":"","tags":["tool","guiInput"]},{"location":"tools/misc/gui-input/#ogs-project-configuration","title":"OGS project configuration","text":"<p>OGS has an interface to add additional tool drivers by adding Windows-DLLs to the <code>[TOOL_DLL]</code> section in <code>station.ini</code>. To simplify the creation of custom tool drivers, OGS offers the heLuaTool.dll, which enables the development of tool drivers using pure LUA. With this functionality, the GUI Input tool is seamlessly integrated into OGS, see Lua custom tools.</p>","tags":["tool","guiInput"]},{"location":"tools/misc/gui-input/#tool-registration-and-configuration","title":"Tool registration and configuration","text":"<p>According to the instructions provided in the Lua custom tools, a standard configuration for the <code>[LuaTool_GUI_Input]</code> section in <code>station.ini</code> is as follows:</p> <pre><code>[TOOL_DLL]\nheLuaTool.dll=1 \n\n[CHANNELS]\n2=LuaTool_GUI_Input \n\n[LuaTool_GUI_Input]\nDRIVER=heLuaTool\nTYPE=GUI_INP\nParam1 = { \"name\": \"Param 1 m2:\", \"type\": 'float', \"default\": '250', \"min\": '0', \"max\": '' }\nParam2 = { \"name\": \"Param 2 m2:\", \"type\": 'float', \"default\": '0', \"min\": '-2000', \"max\": '2000' }\nParam3 = { \"name\": \"Param 3 deg:\", \"type\": 'int', \"default\": '0', \"min\": '0.0', \"max\": '' }\nParam4 = { \"name\": \"Speed Km/h:\", \"type\": 'int', \"default\": '0', \"min\": '0', \"max\": '' }\nParam5 = { \"name\": \"Resistence Om:\", \"type\": 'float', \"default\": '300', \"min\": '0.0', \"max\": '' }\nParam6 = { \"name\": \"Height sm.:\", \"type\": 'float', \"default\": '0', \"min\": '0.0', \"max\": '2000' }\n</code></pre> <p>The typical parameters are:</p> <ul> <li><code>DRIVER</code>: The name of the windows dll that implements tool drivers.</li> <li><code>TYPE</code>: The name of the tool driver specified in your custom LUA tool driver.</li> <li><code>Param</code>: When creating parameters, ensure that only 6 parameters are defined. For each parameter, specify the type (e.g., float or int), min and max values (if applicable), and a default value. These defined properties will be displayed on the GUI for the user to input their values accordingly. The type will determine the format of the value (e.g., numeric or integer), while the min and max values define the valid range for the input. The default value will be pre-filled if no user input is provided.</li> </ul>","tags":["tool","guiInput"]},{"location":"tools/misc/gui-input/#editor-configuration","title":"Editor configuration","text":"","tags":["tool","guiInput"]},{"location":"tools/misc/gui-input/#configuring-the-tool","title":"Configuring the tool","text":"","tags":["tool","guiInput"]},{"location":"tools/misc/gui-input/#creating-a-job","title":"Creating a job","text":"","tags":["tool","guiInput"]},{"location":"tools/openprotocol/","title":"OpenProtocol tools","text":""},{"location":"tools/openprotocol/#overview","title":"Overview","text":"<p>OGS supports connecting tools with <code>OpenProtocol</code> interface. As tools differ in functionality and also different tool vendors implement the <code>OpenProtocol</code> specification in slightly different ways, OGS has special protocol handlers for the following tools:</p> <ul> <li>Rexroth Nexo and Nexo 2 wireless tools (for more information, see Nexo OpenProtocol)</li> <li>Rexroth CS351 and KE350 system tools (for more information, see KE350 OpenProtocol and CS351 OpenProtocol)</li> <li>Rexroth OPEXplus (for more information, see OPEXplus OpenProtocol)</li> <li>GWK Operator+ torque wrenches (for more information, see GWK Operator+ OpenProtocol)</li> <li>Crane TCI torque wrenches (for more information, see Crane OpenProtocol)</li> <li>Gehmeyr Exact Wifi tools (for more information, see Gehmeyr OpenProtocol)</li> <li>Sturtevant Richmont Global 400 MP connected Exacta 2 digital torque wrenches (for more information, see Sturtevant Richmond OpenProtocol)</li> <li>HS-Technik riveting tool</li> </ul> <p>The overall configuration for these tools is similar and the actual driver has the same set of configuration parameters - described on this page.</p> <p>To workaround various glitches in the tools concrete OpenProtocol implementation, the tools are identified by their MID0002 vendor string and their tool type name. For more details, see the CHANNEL TYPE Parameter description in the Channel parameter reference below. </p> <p>The supported tool types and vendor codes are:</p> Tool type Vendor code Vendor Comments NEXO BRC Bosch Rexroth Wireless Nexo Tool CS351 BRC Bosch Rexroth Single channel Compact Box KE350 BRC Bosch Rexroth Multispindle system OPEX REX Bosch Rexroth OPEXplus torque wrench CRANE CEL Crane Electronics TCI Multi, Wrenchstar GHM GHM Gehmeyr GF-ION-EXACT GWK GWK GWK Operator+, Operator22 CET CET Sturtevant Richmond Global 400mt controller BTC BTC HS-Technik NutBee riveting tool ATG ATG Cleco Cleco wifi battery tool"},{"location":"tools/openprotocol/#installation","title":"Installation","text":"<p>The <code>OpenProtocol</code> driver is implemented in <code>OpConn.dll</code>. To use any <code>OpenProtocol</code> tool, the driver must be loaded in the <code>[TOOL_DLL]</code> section of the projects <code>station.ini</code> configuration file (see also Tool configuration).</p>"},{"location":"tools/openprotocol/#tool-registration-and-configuration","title":"Tool registration and configuration","text":"<p>All <code>OpenProtocol</code>-tools are registered in the <code>[OPENPROTO]</code> section of the projects <code>station.ini</code> file.</p> <p>The <code>[OPENPROTO]</code> section mixes the tool parameters and the channel mapping (due to historic reasons) by combining the channel number and the parameter name/value in the <code>station.ini</code> entry. </p> <p>Each parameter is prefixed with the channel number and followed by parameter name as follows:</p> <pre><code>CHANNEL_&lt;two-digit channel&gt;_&lt;param name&gt;=&lt;param value&gt;\n</code></pre> <p>Where - <code>&lt;two-digit channel&gt;</code> is the channel number in the range 01...99 (the channel number maps 1:1 to the tool number from the workflow configuration)  - <code>&lt;param name&gt;</code> is the parameter name (see Channel parameter reference) - <code>&lt;param value&gt;</code> is the actual parameter value for the given parameter</p> <p>In addition to the channel-specific parameters, there are also shared parameters. These act as default parameters for the channel-specific settings and can be overridden by the channel specific values.</p> <p>For more details on the shared parameters, see Shared parameter reference) below .</p> <p>A sample <code>OpenProtocol</code> tool configuration (channel 01) would therefore look similar to the following:</p> <pre><code>[OPENPROTO]\n# Shared/default parameters\nPORT=4545\n# Channel/Tool 1 parameters\nCHANNEL_01=10.10.2.163\nCHANNEL_01_TYPE=NEXO\nCHANNEL_01_CHECK_TIME_ENABLED=1\nCHANNEL_01_CURVE_REQUEST=1\n</code></pre>"},{"location":"tools/openprotocol/#loosen-modes","title":"Loosen modes","text":"<p>Typically tightening tools support tightening and loosening processes - often (for most tools except torque wrenches) by having an additional direction selection switch on the tool. The direction switch typically allows selecting between two differen PSets, which are used for running the tool when the start button on the tool is pushed:</p> <ul> <li>\"primary\" PSet (used for tightening)</li> <li>\"secondary\" PSet (used for loosening)</li> </ul> <p>However, OpenProtocol has no support for this functionality bult-in natively -   it only supports selecting an \"active\" PSet (for the \"primary\" PSet). Depending on the tool type and vendor, there are different ways how the direction switch can be used with OGS, so OGS can control/prevent loosening:</p> <ul> <li>Tool reports direction switch position over OpenProtocol I/O signals (using MID500 or MID210MID241)</li> <li>Tool allows blocking the loosening switch \"secondary\" position over OpenProtocol I/O signals (using MID504 or MID200/240)</li> <li>Tool forcibly selecting a PSet, if the direction switch is set to the \"secondary\" position</li> <li>Tool automatically selectiong a different PSet after NOK rundowns on the primary PSet</li> <li>...</li> </ul> <p>By default, OGS selects a specific PSet (using MID0018) for loosen as defined in the tools configuration in the heOpCfg editor:</p> <p></p> <p>For tools which support OpenProtocol I/O signals, OGS also provides an additional I/O signal which is set to true while the OGS is in tightening mode (and false while in loosening mode), which allows tailoring the behaviour even more (e.g. allow loosen with the direction switch set to CW, etc.). Also OGS can read an additional input signal reporting the state of the tools CW/CCW switch, so it can act accordingly and show a warning to the user eventually. See also below CHANNEL__CCW_ACK for enforcing the direction switch setting. <p>Note, that OGS can also be configured to block loosening in general (see user rights for loosen below)!</p>"},{"location":"tools/openprotocol/#nok-behaviour-and-rework-parameters","title":"NOK behaviour and rework parameters","text":"<p>To undestand NOK behaviour, it is important to understand that each <code>Task</code> (for tightening this is tightening a bolt) configured and executed in OGS consists of (up to) four different operations:</p> <ul> <li><code>main process</code>: This is the main operation defined in the configuration database. For a tightening task, this is tightening with a given PSet and eventually socket. This is the operation, which is normally executed, if the task state is \"new\" (untightened).</li> <li><code>rework</code>: This is the operation, if the main operation failed or if the task state was \"nok\". For tightening this is typically using a loosen PSet to loosen the bolt.</li> <li><code>undo</code>: Only used for special cases, by default the same as rework.</li> <li><code>alternative tool</code>: Only used in alternative tool mode, by default this is not available.</li> </ul> <p>For tightening tools, the <code>rework</code> operation is implicitely defined by the tool configuration in the configuration database and the projects <code>station.ini</code> file (but can be overridden by defining a seperate <code>rework</code> operation in the configuration database) - see the screenshot in the previous section. </p> <p>OGS has tree different basic NOK behaviours (set in the <code>[GENERAL]</code> section in <code>station.ini</code> in the <code>NOK_STRATEGIE</code> parameter):</p> <ul> <li> <p>0 (default): Stay on the task/bolt and automatically select the <code>rework</code> operation after a NOK      rundown. In this case OGS automatically selects the configured loosening program     after a NOK rundown. This allows the operator to immediately loosen a bolt after NOK     without the need to enable CCW operations (and optionally without the operator switching      the CW/CCW switch to CCW). </p> <p>Note that the operator still needs to acknowledge the NOK rundown (if enabled in the tools  configuration) before he can start the loosening operation. Note also that the program used for the loosening operation must be defined in the tool configuration section of the  configuration editor</p> <p>Note that manual loosen on the tool (by using the CCW switch) is disabled in this mode by default (if <code>CHANNEL_&lt;tool&gt;_CCW_ACK</code> not set or = 0). </p> </li> <li> <p>1: Skip task after a NOK rundown. In this case the current bolt is marked NOK and the job      automatically continues immediately with the next bolt.</p> </li> <li> <p>2: Stay on task after NOK rundown. In this case the job does not execute the <code>rework</code>operation,     but restarts the <code>main process</code>. It therefore re-enables the tool after a NOK rundown, but stays     on the current bolt. The next bolt is only selected after a OK rundown. </p> </li> </ul> <p>Note that this behaviour can be overridden by implementing the LUA function <code>GetNokBehaviour(...)</code>.</p>"},{"location":"tools/openprotocol/#sequence-interlock-between-tightening-and-loosening","title":"Sequence interlock between tightening and loosening","text":"<p>In a typical sequence of operations, there is a risk, that the operator does not recognize a NOK result. Typically after a NOK rundown, a loosen operation is required - if the operator does not notice the NOK, he might move on to the next bolt and start the tool - then with a loosen operation. This will lead to  confusion and possibly corrupt the sequence of operations, even tightening on the wrong bolt.</p> <p>To prevent this to happen, the tool is typically blocked after NOK and requires additional interaction from the operator, so the NOK will not pass unnoticed. OGS provides the following options:</p> <ul> <li>Block the tool after a NOK rundown and require a supervisor to continue (four eye witness process)</li> <li>Block the tool and wait for the operator to switch to loosen (<code>CHANNEL_&lt;tool&gt;_CCW_ACK</code> set to 1 and   CCWSel supported)</li> <li>Configure the tool to require a NOK acknowledge (tool configuration). Most tools support this by an    additional acknowledge button, which must be pressed after a NOK rundown to re-enable the tool</li> </ul> <p>Note</p> <p>As a general rule for tightening tools, make sure to setup the parameters of the tightening programs to detect running the tool on a already fastened bolt and report this as a NOK rundown. This ensures OGS can stay in sync with the actual sequence and cannot easily be manipulated.</p> <p>Note</p> <p>For higher level requirements, OGS suports tool position tracking - this ensures that a bolt cannot run twice and the operator cannot work on the \"wrong\" bolt.</p> <p>Danger</p> <p>For hand held tools it is very important to enable the <code>CHANNEL_&lt;tool&gt;_CCW_ACK</code> feature and require the operator to switch to loosen before running the tool. Otherwise he might get suprised by the reaction force and could get injured!</p>"},{"location":"tools/openprotocol/#wait-for-ccwsel-input","title":"Wait for CCWSel input","text":"<p>If <code>CHANNEL_&lt;tool&gt;_CCW_ACK</code> is set to a non-zero value in the <code>station.ini</code> configuration for the tool, then OGS requires the tools direction switch position to be in the correct position according to the processes currently requested tightening mode (tighten/loosen). If not, an alert message will be shown to indicate that the operator should change the direction switch accordingly and the enable signal for the tool is inactive.</p> <p>Note that this behaviour can be overridden by implementing the LUA function <code>GetNokBehaviour(...)</code>.</p> <p>Please see the tool specific documentation on the available loosening modes and recommendations on how to setup the tool for use with OGS.</p>"},{"location":"tools/openprotocol/#ccwlockccwignore-output","title":"CCWLock/CCWIgnore output","text":"<p>For tools which support OpenProtocol I/O signals, OGS also provides an additional I/O signal which is set to true while the OGS is in tightening mode (and false while in loosening mode). This signal can be used to block a CCW start while OGS expects tightening by assigning a corresponding controller signal (e.g. CCWLock or CCWIgnore for KE350 or CS351 ). </p> <p>Note, that the signal is set to high (block loosen) only, if the current logged on user does not have the user right <code>CCW</code> assigned (see OGS user rights for more information).</p> <p>Warning</p> <p>Without proper support for CCWLock/CCWIgnore, OGS cannot prevent the tool running a loosen program. In this case, tools which select an internally defined lossen program when the start switch is set to CCW should be configured such that the tool won't start (if the direction switch is set to CCW and the operator presses the start switch)! In addition, a on-tool NOK acknowledge should be configured and OGS must be set to select the loosen program (<code>CHANNEL_&lt;tool&gt;_CCW_ACK</code> mujst be set to 0). </p>"},{"location":"tools/openprotocol/#user-rights-for-loosen","title":"User rights for loosen","text":"<p>OGS has two sepperate user rights related to loosen (see also OGS user rights and NOK behaviour):</p> <ul> <li><code>processNOK</code>: This right defines, if an operator is allowed to execute the rework operation after a failed primary process operation. If this right is not given, then the operator is not allowed to execute the rework operation - in case of a tightening tool, this means he is not allowed to loosen (by default, a warning message is shown in this case, indicating to call a supervisor).</li> <li><code>CCW</code>:  This right defines, if an operator is allowed to switch to CCW mode on the tool. If this right is given, the operator    is allowed to loosen regardless of the OGS current process state. </li> </ul>"},{"location":"tools/openprotocol/#openprotocol-driver-parameters-reference","title":"OpenProtocol driver parameters reference","text":""},{"location":"tools/openprotocol/#shared-parameter-reference","title":"Shared parameter reference","text":"<p>The shared parameters are used to change the global defaults for all OpenProtocol tools. If assigned, then these settings will override the built-in defaults. Note, that a channel-specific setting will take priority anyways.</p>"},{"location":"tools/openprotocol/#port","title":"PORT","text":"<p>(optional, defaults to 4545)</p> <p>Defines the TCP port used for OpenProtocol communication. By default uses the standard OpenProtocol port 4545. If the controller supports multiple tools through a single IP address, then typically this setting must be changed to correctly connect to the individual tool.</p>"},{"location":"tools/openprotocol/#check_time_interval","title":"CHECK_TIME_INTERVAL","text":"<p>(optional, defaults to 5 [minutes])</p> <p>Defines the time [in minutes] when OGS shall check the tools clock. This setting is only used, if time synchronization is enabled for the tool (see CHANNEL_[TOOL]_CHECK_TIME_ENABLED below).</p>"},{"location":"tools/openprotocol/#time_tolerance","title":"TIME_TOLERANCE","text":"<p>(optional, defaults to 5 [seconds])</p> <p>Defines the maximum allowed time difference [in seconds] before OGS corrects the tools realtime clock. This setting is only used, if time synchronization is enabled for the tool (see CHECK_TIME_ENABLED below).</p>"},{"location":"tools/openprotocol/#external_io_offset","title":"EXTERNAL_IO_OFFSET","text":"<p>(optional, defaults to 0)</p> <p>This setting enables custom IO access (through LUA) over the OpenProtocol interface. This can be used to read physical inputs and set physical outputs connected to the controller over OpenProtocol.</p> <p>Depending on the tool, different MIDs are used - to enable this for CS351 and KE350, set it to 2.</p>"},{"location":"tools/openprotocol/#channel-parameter-reference","title":"Channel parameter reference","text":"<p>For specific information about a tools settings or the tools configuration needed (on the tool side), please see the tool-specific information.</p> <p>The parameter names are composed of the channel prefix <code>CHANNEL_</code> followed by the channel/tool number (1-32) and the actual parameter name (e.g. <code>TYPE</code>). - see the detailed description above. </p> <p>In general, the following parameters are available for a <code>OpenProtocol</code>-tool:</p>"},{"location":"tools/openprotocol/#channel_tool_ip","title":"CHANNEL_[tool]_IP","text":"<p>(mandatory)</p> <p>This setting defines the IP address to use for communication with the tool.</p>"},{"location":"tools/openprotocol/#channel_tool_port","title":"CHANNEL_[tool]_PORT","text":"<p>(optional, defaults to the shared parameter value)</p> <p>See PORT in the shared parameter reference.</p>"},{"location":"tools/openprotocol/#channel_tool_type","title":"CHANNEL_[tool]_TYPE","text":"<p>(mandatory)</p> <p>The allowed tool types and their default parameters are listed in the following table (see the overview section above for tool details):</p> Tool type Alive send rate Response Timeout Comments NEXO 2 5 CS351 5 15 OPEX 2 5 No MID0040 support, use MID0061 tool SN KE350 5 15 CRANE 1 5 GHM 2 5 MID0060 Rev 999 only, no alarms GWK 2 5 No MID0040 support, use MID0061 tool SN CET 2 5 no alarms, incorrect (+1) result ID sequence BTC 2 5 ATG 2 5 <p>NOTES: - The Alive send rate and Response timeout default parameter values can be overridden by the CHANNEL_[tool]_ALIVEXMTT and CHANNEL_[tool]_RSPTIMEOUT parameters.  - All tools use a slightly different set of MIDs to control operation, e.g. some do support alarms, others don't or allow different revisions of the MID commands. - For Nexo with firmware &lt; V1500, a Alive send rate of 1000ms or less is recommended to ensure stable WiFi operation - For CS351 and KE350, do not use a Alive send rate less than 5 second, else the controller may become unresponsive </p>"},{"location":"tools/openprotocol/#channel_tool_ccw_ack","title":"CHANNEL_[tool]_CCW_ACK","text":"<p>(optional, default = 0 (disabled))</p> <p>Defines, if the operator must select a loosen operation on the tool to start a loosen process (for tools having a CW/CCW switch which is accessible over OpenProtocol). Currently only Rexroth Nexo, CS351 and KE350 support this feature, but other tools supporting I/O signals over OpenProtocol are possible.</p> <p>The following settings are available:</p> <ul> <li>0: Disabled. OGS select a CCW program automatically</li> <li>1: Enabled. Operator must switch to CCW manually (possibly selecting the tools builtin loosen program instead of     the loosen program defined in the configuration database)</li> </ul>"},{"location":"tools/openprotocol/#channel_tool_alivexmtt","title":"CHANNEL_[tool]_ALIVEXMTT","text":"<p>(optional, default defined by tool type (see above))</p> <p>Defines how often OGS shall send an <code>ALIVE</code> data packet (<code>MID9999</code>) to the tool to check for connectivity. The value is given in milliseconds.</p> <p>If OpenProtocol communication is received from the tool within 3 times of this time setting, then the connection with the tool is considered disconnected. In this case, OGS shuts down the connection and tries to reconnect. </p>"},{"location":"tools/openprotocol/#channel_tool_rsptimeout","title":"CHANNEL_[tool]_RSPTIMEOUT","text":"<p>(optional, default defined by tool type (see above))</p> <p>Defines how long OGS shall wait for an OpenProtocol command response from  the tool before considering the connection as disconnected. The value is  given in milliseconds.</p> <p>If no answer for a command sent by OGS to the tool is received within this time setting, then the connection with the tool is considered disconnected.  In this case, OGS shuts down the connection and tries to reconnect.</p>"},{"location":"tools/openprotocol/#channel_tool_barcode_mid0051_rev","title":"CHANNEL_[tool]_BARCODE_MID0051_REV","text":"<p>(optional, default = 0 (disabled))</p> <p>If set to a nonzero value, the <code>MID0051</code> (ID-Code change) subscription is  enabled. This can be used to read ID-Codes through a barcode scanner built into the tool (instead of using a seperate scanner).</p> <p>See the tool-specific documentation about how to enable barcode scanning with ID-Code forwarding.</p>"},{"location":"tools/openprotocol/#channel_tool_check_ext_cond","title":"CHANNEL_[tool]_CHECK_EXT_COND","text":"<p>(optional, default = 0 (disabled))</p> <p>Defines, how the tool enable shall follow the OGS enable signal. The following  options are available:</p> <ul> <li>0: Only check the enable once for each tool operation. </li> <li>1: Cyclically check the enable while a tool operation is active. </li> </ul>"},{"location":"tools/openprotocol/#channel_tool_appl_start","title":"CHANNEL_[tool]_APPL_START","text":"<p>(optional, default = 0 (single channel mode))</p> <p>If set to a nonzero value, OGS uses multispindle (fastening application) mode  to control the tool. This also changes other behaviour for the communication, e.g. uses <code>MID0100</code> to subscribe for results instead of <code>MID0060</code> (for single channel results).</p> <p>See System 350 OpenProtocol for more info about multi-spindle mode and how to set it up.</p>"},{"location":"tools/openprotocol/#channel_tool_curve_request","title":"CHANNEL_[tool]_CURVE_REQUEST","text":"<p>(optional, default = 0 (disabled))</p> <p>If set to a nonzero value, OGS requests the tightening curve data after a  rundown has completed. </p> <p>NOTES: </p> <ul> <li>Depending on the tool type, this introduces significant delays for the tightening operation!</li> <li>If curves are only needed for validation purposes, then Tool mirroring/twins can be set up with different parameters for the main and the mirrored tool!</li> </ul>"},{"location":"tools/openprotocol/#channel_tool_check_time_enabled","title":"CHANNEL_[tool]_CHECK_TIME_ENABLED","text":"<p>(optional, default = 0 (disabled))</p> <p>If set to a nonzero value, OGS checks the tools realtime clock and adjusts it, if the time delta between the OGS system time and the tools system time is tool large.</p> <p>See the shared parameter section for more parameters related to time synchronization.</p>"},{"location":"tools/openprotocol/#channel_tool_ignore_id","title":"CHANNEL_[tool]_IGNORE_ID","text":"<p>(optional, default to the tool type)</p> <p>Set to a nonzero value to ignore the tightening result ID returned in the tightening results from the tool. OGS expects and validates, that each rundown of a tool uses an incrementing tightening result ID to ensure no lost or out of sync tightening results. However, some tools have a flaky implementation so there is an option to disable these checks.</p>"},{"location":"tools/openprotocol/#debugging-settings","title":"Debugging settings","text":""},{"location":"tools/openprotocol/#channel_tool_showalive","title":"CHANNEL_[tool]_SHOWALIVE","text":"<p>(optional, default = 0 (disabled))</p> <p>Set to nonzero to log <code>MID9999</code> (alive) messages in the OGS ETW logs.</p>"},{"location":"tools/openprotocol/#channel_tool_params","title":"CHANNEL_[tool]_PARAMS","text":"<p>(internal, default depending on tool type)</p>"},{"location":"tools/openprotocol/#lua-settings","title":"LUA settings","text":"<p>Please note, that other drivers can also access the <code>[OPENPROTO]</code> section, so additional tool specific parameters might be added here, e.g.</p> <ul> <li>`CHANNEL_[tool]_NEXONAR_CHANNEL=</li> <li>`CHANNEL_[tool]_POSITIONING=</li> </ul>"},{"location":"tools/openprotocol/#tool-mirroringtwins","title":"Tool mirroring/twins","text":"<p>(tbd).</p>"},{"location":"tools/openprotocol/gwk/","title":"GWK Operator 22 and Operator+ electronic torque wrench","text":"<p>The GWK electronic torque wrench family is a series of electronic torque wrenches with builtin WiFi communications. They support multiple communication protocols, one of them is OpenProtocol which is used by OGS to communicate with the tools. </p> <p></p>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/gwk/#installation-and-configuration","title":"Installation and configuration","text":"","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/gwk/#ogs-project-configuration","title":"OGS project configuration","text":"<p>For generic information about how to configure OGS with OpenProtocol tools, see  OpenProtocol documentation.</p>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/gwk/#tool-registration-and-configuration","title":"Tool registration and configuration","text":"<p>The <code>GWK</code> tools are identified by specifying the tool type <code>GWK</code> in the <code>[OPENPROTO]</code> section of <code>station.ini</code>. </p> <p>A typical configuration of the <code>[OPENPROTO]</code> section looks like the following :</p> <pre><code>[OPENPROTO]\n# Channel/Tool 1 parameters\nCHANNEL_01=10.10.2.184\nCHANNEL_01_PORT=4002\nCHANNEL_01_TYPE=GWK\n; to enable curve transmission, set to 1:\nCHANNEL_01_CURVE_REQUEST=1\n</code></pre> <p>The typical parameters are (for more details about the possible parameters, see OpenProtocol documentation):</p> <ul> <li><code>CHANNEL_&lt;channel&gt;</code>: Define the IP address used to communicate with the tool.</li> <li><code>CHANNEL_&lt;channel&gt;_PORT</code>: Define the TCP port number used for OpenProtocol(typically 4002).</li> <li><code>CHANNEL_&lt;channel&gt;_TYPE</code>: Defines the OpenProtocol communication variant, must be set to <code>GWK</code>.</li> <li><code>CHANNEL_&lt;channel&gt;_CURVE_REQUEST</code>: Set to 1 to enable curve transmission, set to 0 to disable curve transmission. Set to 1, if you have tracebility output enabled and want to get the tightening graph included in the data output. Disable (set to zero), if you don't need it (for performance reasons). In general, the new <code>Operator 22</code> tools are much faster in curve transmission, the older <code>Operator+</code> tools might cause delays up to a few seconds. Contact GWK-Gerlach for recent firmware versions with improved performance!</li> </ul>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/gwk/#tool-data-output","title":"Tool data output","text":"<p>Like other tools, the <code>GWK</code> tools can use the OGS buit-in connectivity options to send out data and curves (<code>Traceability</code> data) to backend data management systems (like ToolsNet, CSP I-P.M., Sciemetric QualityWorX, QualityR, etc.). </p> <p>To understand the system architecture and details on how to use data output in general, please see OGS Traceability. To setup <code>Traceability</code> for <code>OPEXplus</code> tools, enable <code>Traceability</code> and add the <code>OPEXplus</code> tools channel to the list of channels in the <code>[FTP_CLIENT]</code> section.</p> <p>Here is a sample setup:</p> <pre><code>[FTP_CLIENT]\nEnabled=1\n;... \n; (more settings)\n;...\n; Parameters for each channel:\nCHANNEL_06_INFO={ \"ChannelName\": \"WS010|AC_PF6000\", \"location name\": [\"Tool\", \"Line 2\", \"WS010\", \"default\", \"\", \"\", \"\"] }\n</code></pre> <p>The following parameters are required for the <code>GWK</code> tools, as the tool does not provide them through its interface:</p> <ul> <li><code>ChannelName</code>: Defines the station and channel name seperated by a pipe symbol (<code>&lt;station&gt;|&lt;channel&gt;</code>).</li> <li><code>location name</code>: Defines the location name values to use. Note that this setting depends on the Sys3xxGateway settings for processing the tightening results. Make sure to add the relevant information (like data link name, building, line name, etc.), so the tool can be registered in the correct organizational unit.</li> </ul>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/gwk/#tool-configuration","title":"Tool configuration","text":"","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/gwk/#firmware-version","title":"Firmware version","text":"<p>Please contact GWK-Gerlach for information about current firmware versions - it is recommended to use up-to-date firmware for compatibility, performance and security!</p>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/gwk/#openprotocol-operation-mode","title":"OpenProtocol operation mode","text":"<p>To check, if the correct operation mode is selected (OpenProtocol), do the following:</p> <ul> <li>for <code>Operator+</code>: while the tool is switched off, press and hold the left and right arrow buttons until the service menu appears. Enter a invalid password to get to the status page. The current protocol is shown in the last line - for use with OGS (OpenProtocol), it should read <code>BA59_OPP_EXP_STD_OPENPROTOCOL_WLAN_CB_MODE</code>. For <code>Operator 22</code>: while the tool is switched off, press and hold the right arrow button until the display lights up, then enter a wrong password to get to the status screen. The current protocol is shown in the fourth line - for use with OGS (OpenProtocol), it should read <code>Open Protocol TCP</code>.</li> </ul>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/gwk/#tightening-programs","title":"Tightening programs","text":"<p>To upload and manage tightening programs, use the <code>EasyWin</code> software. The PSET number to select a tightening program is generated in EasyWin automatically besed on the inserting sequence (first column (labeled \"No.\") in the tool configuration list). To change the order, use the buttons with the green arrow on the bottom of the pane.</p> <p></p>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/gwk.old/","title":"GWK Operator+","text":"<p>The GWK Operator+ OpenProtocol implementation (currently, as of June 2023) has quite some quirks. OGS tries to workaround most of them, but the following parameters needs to be tweaked:</p> <ul> <li>The GWK tool only supports a single OpenProtocol session (even if multiple TCP connections are allowed). Make sure to disable multiple connections in the GWK xPico Web settings (under the \"Tunnel\"\u2192\"Accept\" category)</li> <li>The GWK tool seems to never actively disconnect a TCP session and does not close an OpenProtcol session, if the TCP connection gets dropped. According to the GWK development, the internal session is only closed, if no message is received within 15 seconds (the MID9999 alive timeout) - irregardless of the state of the TCP connection. As a workaround, OGS therefore always waits for 30 seconds to reconnect to the tool in case of network communication errors. Faster reconnects are not recommended, as the tool replies with MID0004 (error 96) for the next MID0001 (which makes any OpenProtocol client disconnect). Having a reconnect time of less than 15 seconds therefore will lead to a reconnect loop, where never a good connection to the tool can be established.</li> </ul> <p>see Bosch Rexroth OPEXplus for information about the tool.</p> <p></p>"},{"location":"tools/openprotocol/nexo/","title":"Bosch Rexroth Nexo and Nexo 2 wireless battery tools","text":"<p>The Nexo cordless nutrunners are advanced battery powered tightening tools with high accuracy and reliability. They are certified for safety-critical tightening connections according to VDI/VDE 2862. The tools feature built-in controllers with WiFi communications. They use the OpenProtocol communication protocol to communicate with the heOGS software. They also support traceability data and curve output, see tool data http output.</p> <p></p> <p>Note, that the Rexroth product site and catalog do not list the Nexo 2 tools at the time of writing this article, but there is a marketing site with information about Nexo 2.</p>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/nexo/#installation-and-configuration","title":"Installation and configuration","text":"","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/nexo/#ogs-project-configuration","title":"OGS project configuration","text":"<p>For generic information about how to configure OGS with OpenProtocol tools, see  OpenProtocol documentation.</p>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/nexo/#tool-registration-and-configuration","title":"Tool registration and configuration","text":"<p>The Nexo and Nexo 2 tools are identified by specifying the tool type <code>NEXO</code> in the <code>[OPENPROTO]</code> section of <code>station.ini</code>. </p> <p>A typical configuration of the <code>[OPENPROTO]</code> section looks like the following :</p> <pre><code>[OPENPROTO]\n; Channel/Tool 1 parameters\nCHANNEL_01=10.10.2.184\nCHANNEL_01_PORT=4545\nCHANNEL_01_TYPE=NEXO\n; Enable time synchronization \nCHANNEL_01_CHECK_TIME_ENABLED=1\n; Force CCW switch selection for rework/loosen\nCHANNEL_01_CCW_ACK=1\n; to enable curve transmission, set to 1:\nCHANNEL_01_CURVE_REQUEST=1\n</code></pre> <p>The typical parameters are (for more details about the possible parameters, see OpenProtocol documentation):</p> <ul> <li><code>CHANNEL_&lt;channel&gt;</code>: Define the IP address used to communicate with the tool.</li> <li><code>CHANNEL_&lt;channel&gt;_TYPE</code>: Defines the OpenProtocol communication variant, must be set to <code>NEXO</code>.</li> <li><code>CHANNEL_&lt;channel&gt;_PORT</code>: (optional) Define the TCP port number used for OpenProtocol(typically 4545).</li> <li><code>CHANNEL_&lt;channel&gt;_CHECK_TIME_ENABLED</code>: (recommended) If set to a nonzero value, then the tools internal time is synchronized with the OGS date and time. For Nexo 1 this is highly recommended due to issues with the firmware NTP time sync.</li> <li><code>CHANNEL_&lt;channel&gt;_CCW_ACK</code>: (optional) If set to a nonzero value, then the CCWSel switch is monitored for the correct position - i.e. if OGS expects loosen, the switch must be set to the CCW position.</li> <li><code>CHANNEL_&lt;channel&gt;_CURVE_REQUEST</code>: Set to 1 to enable curve transmission over OpenProtocol, set to 0 to disable. Set to 1, if you need the curve data in OGS (e.g. for display or dynamic curve analysis with LUA scripting). Disable (set to zero), if you don't need it (for performance reasons). As Nexo and Nexo 2 have built-in data output protocols, it is only needed in special setups, where OGS needs the curve data.</li> </ul>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/nexo/#tool-data-output","title":"Tool data output","text":"<p>As Nexo and Nexo 2 have built-in features to send out data and curves (<code>Traceability</code> data) to backend data management systems, there is typically no support from OGS needed. </p> <p>See Tool data http output for more information about how to configure the tools built-in data output drivers.</p>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/nexo/#tool-configuration","title":"Tool configuration","text":"","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/nexo/#firmware-version","title":"Firmware version","text":"<p>Please contact Bosch Rexroth for information about current firmware versions - it is recommended to use up-to-date firmware for compatibility, performance and security!</p>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/nexo/#tool-mode","title":"Tool mode","text":"<p>The Nexo tools can operate in manual or automatic mode. For OGS to be able to control the tool, automatic mode is required. Depending on your requirements, you can configure the tool to enable switching modes through the tool display (not recommended).</p> <p>The mode must be setup as follows:</p> Nexo 2Nexo <p></p> <p>The relevant settings are:</p> <ul> <li><code>ID code source</code>: must be set to OpenProtocol, so OGS can send the ID</li> <li><code>Operation mode settings</code>: set operation mode to <code>auto</code></li> </ul> <p>Make sure the set the <code>active column</code> to <code>A</code>!</p> <p></p> <p>The relevant settings are:</p> <ul> <li><code>ID code source</code>: must be set to OpenProtocol, so OGS can send the ID</li> <li><code>Operation mode settings</code>: set operation mode to <code>auto</code></li> </ul> <p>Make sure the set the <code>active column</code> to <code>A</code>!</p>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/nexo/#openprotocol-configuration","title":"OpenProtocol configuration","text":"<p>As OGS needs OpenProtocol to control the tool, the OpenProtocol (Data \u2192 OpenProtocol) must be configured as follows:</p> Nexo 2Nexo <p></p> <p></p> <p> </p> <p></p> <p> </p> <p>Nexo 1: Wifi notes</p> <p></p>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/nexo/#openprotocol-operation-mode","title":"OpenProtocol operation mode","text":"<p>To check, if the correct operation mode is selected (OpenProtocol), do the following:</p> <ul> <li>for <code>Operator+</code>: while the tool is switched off, press and hold the left and right arrow buttons until the service menu appears. Enter a invalid password to get to the status page. The current protocol is shown in the last line - for use with OGS (OpenProtocol), it should read <code>BA59_OPP_EXP_STD_OPENPROTOCOL_WLAN_CB_MODE</code>. For <code>Operator 22</code>: while the tool is switched off, press and hold the right arrow button until the display lights up, then enter a wrong password to get to the status screen. The current protocol is shown in the fourth line - for use with OGS (OpenProtocol), it should read <code>Open Protocol TCP</code>.</li> </ul>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/nexo/#tightening-programs","title":"Tightening programs","text":"<p>To upload and manage tightening programs, use the <code>EasyWin</code> software. The PSET number to select a tightening program is generated in EasyWin automatically besed on the inserting sequence (first column (labeled \"No.\") in the tool configuration list). To change the order, use the buttons with the green arrow on the bottom of the pane.</p> <p></p>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/nexo/#tool-data-http-output","title":"Tool data http output","text":"<p>To make Nexo and Nexo 2 to send out data and curves (<code>Traceability</code> data) to backend data management systems (like ToolsNet, CSP I-P.M., Sciemetric QualityWorX, QualityR, etc.), the builtin data output interfaces can be used. </p> <p>To understand the system architecture and details on how to use data output in general, please see OGS Traceability. To setup <code>Traceability</code> for <code>OPEXplus</code> tools, enable <code>Traceability</code> and add the <code>OPEXplus</code> tools channel to the list of channels in the <code>[FTP_CLIENT]</code> section.</p> <p>Here is a sample setup:</p> <pre><code>[FTP_CLIENT]\nEnabled=1\n;... \n; (more settings)\n;...\n; Parameters for each channel:\nCHANNEL_06_INFO={ \"ChannelName\": \"WS010|AC_PF6000\", \"location name\": [\"Tool\", \"Line 2\", \"WS010\", \"default\", \"\", \"\", \"\"] }\n</code></pre> <p>The following parameters are required for the <code>GWK</code> tools, as the tool does not provide them through its interface:</p> <ul> <li><code>ChannelName</code>: Defines the station and channel name seperated by a pipe symbol (<code>&lt;station&gt;|&lt;channel&gt;</code>).</li> <li><code>location name</code>: Defines the location name values to use. Note that this setting depends on the Sys3xxGateway settings for processing the tightening results. Make sure to add the relevant information (like data link name, building, line name, etc.), so the tool can be registered in the correct organizational unit.</li> </ul>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/opexplus/","title":"Rexroth OPEXplus electronic torque wrench","text":"<p>The Rexroth OPEXplus electronic torque wrench family is a family of electronic torque wrenches with builtin WiFi communications. They use the OpenProtocol communication protocol to communicate with the heOGS software.</p> <p></p>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/opexplus/#installation-and-configuration","title":"Installation and configuration","text":"","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/opexplus/#ogs-project-configuration","title":"OGS project configuration","text":"<p>For generic information about how to configure OGS with OpenProtocol tools, see  OpenProtocol documentation.</p>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/opexplus/#tool-registration-and-configuration","title":"Tool registration and configuration","text":"<p>The <code>OPEXplus</code> tool is identified by specifying the tool type <code>OPEX</code> in the <code>[OPENPROTO]</code> section of <code>station.ini</code>. </p> <p>A typical configuration of the <code>[OPENPROTO]</code> section looks like the following :</p> <pre><code>[OPENPROTO]\n# Channel/Tool 1 parameters\nCHANNEL_01=10.10.2.184\nCHANNEL_01_PORT=4002\nCHANNEL_01_TYPE=OPEX\n; to enable curve transmission, set to 1:\nCHANNEL_01_CURVE_REQUEST=1\n</code></pre> <p>The typical parameters are (for more details about the possible parameters, see OpenProtocol documentation):</p> <ul> <li><code>CHANNEL_&lt;channel&gt;</code>: Define the IP address used to communicate with the tool.</li> <li><code>CHANNEL_&lt;channel&gt;_PORT</code>: Define the TCP port number used for OpenProtocol(typically 4002).</li> <li><code>CHANNEL_&lt;channel&gt;_TYPE</code>: Defines the OpenProtocol communication variant, must be set to <code>OPEX</code>.</li> <li><code>CHANNEL_&lt;channel&gt;_CURVE_REQUEST</code>: Set to 1 to enable curve transmission, set to 0 to disable curve transmission. Set to 1, if you have tracebility output enabled and want to get the tightening graph included in the data output. Disable (set to zero), if you don't need it (for performance reasons).</li> </ul>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/opexplus/#tool-data-output","title":"Tool data output","text":"<p>Like other tools, the <code>OPEXplus</code> tools can use the OGS buit-in connectivity options to send out data and curves (<code>Traceability</code> data) to backend data management systems (like ToolsNet, CSP I-P.M., Sciemetric QualityWorX, QualityR, etc.). </p> <p>To understand the system architecture and details on how to use data output in general, please see OGS Traceability. To setup <code>Traceability</code> for <code>OPEXplus</code> tools, enable <code>Traceability</code> and add the <code>OPEXplus</code> tools channel to the list of channels in the <code>[FTP_CLIENT]</code> section.</p> <p>Here is a sample setup:</p> <pre><code>[FTP_CLIENT]\nEnabled=1\n;... \n; (more settings)\n;...\n; Parameters for each channel:\nCHANNEL_06_INFO={ \"ChannelName\": \"WS010|AC_PF6000\", \"location name\": [\"Tool\", \"Line 2\", \"WS010\", \"default\", \"\", \"\", \"\"] }\n</code></pre> <p>The following parameters are required for the <code>OPEX</code> tools, as the tool does not provide them through its interface:</p> <ul> <li><code>ChannelName</code>: Defines the station and channel name seperated by a pipe symbol (<code>&lt;station&gt;|&lt;channel&gt;</code>).</li> <li><code>location name</code>: Defines the location name values to use. Note that this setting depends on the Sys3xxGateway settings for processing the tightening results. Make sure to add the relevant information (like data link name, building, line name, etc.), so the tool can be registered in the correct organizational unit.</li> </ul>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/opexplus/#tool-configuration","title":"Tool configuration","text":"","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/opexplus/#firmware-version","title":"Firmware version","text":"<p>The officially required firmware version to use the <code>OPEXplus</code> tools with OGS is as follows (while the tool is switched off, press and hold the right arrow button until the display lights up, then enter a wrong password to get to the info screen):</p> <p></p> <p>Things to check here:</p> <ul> <li>Controller firmware version &gt;= <code>24.26.00</code></li> <li>Wifi module firmware version &gt;= <code>5.4.0.C102</code></li> <li>Operation mode set to <code>OpenProtocol TCP</code> (see the <code>OPEXplus</code> manual on how to change operation mode using the USB cable)</li> </ul> <p>To check the firmware parameters, open a webbrowser and go to the <code>Status</code> page of the <code>OPEXplus</code> tool (see the tools manual on how to connect it over wifi):</p> <p></p> <p>Things to check here:</p> <ul> <li>Wifi module firmware version &gt;= <code>5.4.0.C102</code> </li> <li>Line 1 settings: Protocol == <code>DUB</code>, line speed == <code>230400</code></li> </ul> <p>Older firmware versions will likely work, but might show issues especially with curve transmission.</p>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/opexplus/#tightening-programs","title":"Tightening programs","text":"<p>To upload and manage tightening programs, use the <code>EasyWin</code> software. The PSET number to select a tightening program is generated in EasyWin automatically besed on the inserting sequence (first column (labeled \"No.\") in the tool configuration list). To change the order, use the buttons with the green arrow on the bottom of the pane.</p> <p></p>","tags":["tool","tightening","openprotocol"]},{"location":"tools/openprotocol/sturtevant/","title":"Sturtevant Richmond Global 400mp","text":"<p>The Sturtevant Richmond controller allows </p> <p>see Global 400mp Torque Controller</p> <p></p>"},{"location":"tools/openprotocol/sys350-cs351/","title":"CS351","text":""},{"location":"tools/openprotocol/sys350-cs351/#single-channel-tool","title":"Single channel tool","text":"<p>The signals used in this scenario are:</p> <ul> <li>CW</li> <li>CCW</li> <li>CcwSel</li> <li>CwLock, CcwLock</li> <li>CwAnd, CcwAnd</li> </ul>"},{"location":"tools/openprotocol/sys350-ke350/","title":"KE350 Multi-spindle tightening system","text":"<p>Info</p> <p>This page describes the specifics for configuring the Rexroth KE350 multi-spindle tightening system with OGS, for general information about the OGS OpenProtocol configuration, see  OpenProtocol Tools. </p>"},{"location":"tools/openprotocol/sys350-ke350/#overview","title":"Overview","text":"<p>System350 based tools mainly fall into two categories:</p> <ul> <li>Single spindle tools and ErgoSpin tools used in spindle mode</li> <li>Multi-spindle tools</li> <li>ErgoSpin tools (used in ErgoSpin hand-tool mode) - these are not considered here, as typically a CS351 controller is used in this case, please see CS351 OpenProtocol.</li> </ul> <p>Spindle tools (and ErgoSpin in spindle mode) use externally connected start switches (for start CW, start CCW). All tools are controlled over OpenProtocol using the \"Ford OpenProtocol\" protocol type and are started in application mode (using fasterning operation FO 1).</p> <p>Additional notes:</p> <ul> <li>Check the PSet start step parameter setting \"play with start switch\"</li> <li>Check the <code>CHANNEL_&lt;tool&gt;_CCW_ACK</code> setting for the tool in <code>station.ini</code>.</li> <li>See below on how to configure the PLC assignment table for <code>FO 1 SSWLock</code> and the external <code>CCWSel</code> signals</li> </ul> <p>For the <code>CHANNEL_&lt;tool&gt;_CCW_ACK</code> setting, the following is recommended:</p> <ul> <li>If you use a spindle tool with seperately wired CW/CCW and start signals, then set <code>CHANNEL_&lt;tool&gt;_CCW_ACK=1</code> and connect the direction switch output to the <code>CCWSel</code>-Signal</li> <li>If you use a spindle tool with only CW start and CCW start signals, then set <code>CHANNEL_&lt;tool&gt;_CCW_ACK=0</code>, but make sure to configure the <code>FO 1 CCWLock</code> signal</li> <li>Follow the plc signal assignment setup  and check the configuration for loosen below.</li> </ul> <p>Note</p> <p>To reliably prevent loosen it is recommended to use a seperate direction switch connected to the <code>CCWSel</code> signal and also connect the <code>FO 1 CCWLock</code>-Signal (see below).</p>"},{"location":"tools/openprotocol/sys350-ke350/#openprotocol-configuration","title":"OpenProtocol configuration","text":""},{"location":"tools/openprotocol/sys350-ke350/#overview_1","title":"Overview","text":"<p>OGS uses the KE350 <code>Rexroth OP-Ford R1.0</code> protocol version. This maps the OpenProtool commands to the application start (fastening operation) <code>FO 1</code> signals, so multiple spindles can work in a synchronized way and report the spindle groups result status. </p> <p></p> <p>KE350 OpenProtocol settings</p>"},{"location":"tools/openprotocol/sys350-ke350/#plc-signal-assignment-for-openprotocol","title":"PLC signal assignment for OpenProtocol","text":"<p>The PLC signals OGS uses to control the tool are as follows:</p> Inputs Signal Assignment Comments OP0.1-OP0.7 FO 1 Seq0-7 Mandatory Application number, must be assigned OP1.0 FO 1 Enabled Optional True, if the application was enabled by OGS, typically connected to the yellow LED on the tool handle (use internal signal routing <code>KE AppIn 0</code> \u2192 <code>B1:KE AppOut 0</code> for IM24V output) OP1.1-3.0 Custom I/O See below Signals controlled by OGS OP1.1 (unused) OP1.2 FO 1 CCWLock Optional The signal is set by OGS whenever a normal tightening process is expected to run - it is released, if loosening/rework is active instead. If assigned to <code>FO 1 CCWLock</code>, this effectively prevents a CCW-Start if OGS expectes a CW-Start (prevent unauthorized loosen). Note, that a user with right <code>lossen by CCW</code> always is allowed to loosen, i.e. this signal is then always set to false! OP1.3-3.0 (unused) OP3.1-5.0 (unused) OP5.1 FO 1 Disable Mandatory This signal enables/disables the tool OP5.2-5.7 (unused) <p>The PLC signals OGS receives from the tool are as follows:</p> Outputs Signal Assignment Comments OP0.1-OP0.7 (unused) Not used for KE application mode OP1.0-2.7 Custom I/O See below Signals sent to OGS OP1.0 CCWSel Optional If set, indicates, that the start switch on the tool is set to CCW. Typically connected to the external start switch direction selector on the tool handle (use internal signal routing <code>KE AppOut 1</code> \u2190 <code>B1:KE AppIn 1</code> for IM24V output OP1.1-1.4 (unused) OP1.5 FC NF Mandatory If false, OGS shows a KE system error message OP1.6-2.7 (unused) OP3.0-5.7 (unused) <p>The following screenshot shows a typical PLC assignment table setup for the OpenProtocol signals:</p> <p></p> <p>Please note, that <code>Input OP1.0</code> (FO 1 Enabled) is connected to the <code>KE AppIn 0</code> signal and the <code>Output OP1.0</code> (CCWSel) to the <code>KE AppOut 1</code> signal. These are then bridged (<code>KE AppIn X</code> and <code>KE AppOut X</code> are internally bridged) to the IM24V I/O-Card in slot B1:</p> <p></p> <p>This basically then implements the following (Signals <code>FO 1 CW</code> and <code>FO 1 CCW</code> also connected):</p> <ul> <li>The tool can be started clockwise with im24V digital input 0.0</li> <li>The tool can be started counter-clockwise with im24V digital input 0.1</li> <li>The direction selection switch is connected to im24V digital input 0.2 \u2192 routed to <code>CCWSel</code> at <code>Output OP1.0</code>, so OGS can read the state of the direction switch (don't get confused with the naming output vs. input)</li> <li>The tool enable state is connected to the handles yellow LED at the im24V digital output 0.0</li> <li>CCW start is locked by OGS to prevent invalid loosen without proper rights (using the <code>FO 1 CCWLock</code> signal)</li> </ul> <p>Note</p> <p>Make sure to assign and set the <code>FC EN</code> signal (should be fixed to 1), else the tightening cell will not be enabled and thightening will not work (see above, <code>FC EN</code> set to im24V B1 1.7).</p> <p>Note</p> <p>Not shown in the above signal table is the NOK acknowledge functionality. If there is no CCWSel signal available, it is highly recommended to connect the <code>FO 1 NokAc</code> signal to an external NOK acknowledge button. This will  automatically disable the tool after a NOK rundown and requires pushing the NOK acknowledge button to re-enable the tool for the next run. This basically makes the operator aware of an NOK result and prevents false position tightening/loosening.</p>"},{"location":"tools/openprotocol/sys350-ke350/#ogs-configuration","title":"OGS configuration","text":""},{"location":"tools/openprotocol/sys350-ke350/#overview_2","title":"Overview","text":"<p>Configuring OGS for use with KE350 application start (fastening operation) requires the following: - Configure the tool connection parameters in <code>station.ini</code> - Database setup, workflow and tool configuration in the heOpCfg workflow editor</p>"},{"location":"tools/openprotocol/sys350-ke350/#stationini-configuration","title":"station.ini configuration","text":"<p>Station.ini configuration uses the standard parameters of the OpenProtocol driver (see OpenProtocol Tools). To work with the <code>Rexroth OP-Ford R1.0</code> protocol in the KE350, the channel TYPE parameter must be set to <code>KE350</code>.</p> <p>Here is a sample configuration for tool/channel 1:</p> <pre><code>[OPENPROTO]\n# Channel/Tool 1 parameters\nCHANNEL_01=10.10.2.163\nCHANNEL_01_PORT=4545\nCHANNEL_01_TYPE=KE350\nCHANNEL_01_CCW_ACK=0\nCHANNEL_01_CHECK_TIME_ENABLED=1\nCHANNEL_01_CURVE_REQUEST=1\n</code></pre>"},{"location":"tools/openprotocol/sys350-ke350/#tool-configuration","title":"Tool configuration","text":"<p>To add a KE350 tool, add it as any other tool to the tool configuration and define the default loosen program:</p> <p></p>"},{"location":"tools/openprotocol/sys350-ke350/#multi-spindle-configuration","title":"Multi-Spindle configuration","text":"<p>For KE350, OGS uses application start (fastening operations), where a single start command can start a group of spindles. If more than a single spindle is started, OGS needs to know which bolt is mapped to which spindle. This is done by assigning  a group (this defines which bolts belong to a single application start) and a sequence number (which actually maps the bolt to the spindle). The Both parameters are set in the <code>appl_start</code> task parameter.</p> <p>The <code>appl_start</code> task parameter can be enabled in the workflow editor in <code>database --&gt; settings</code> as follows (check the \"Application start\" parameter): </p> <p>The <code>appl_start</code> parameter is then found in the task properties: </p> <p>The screenshot also shows how the spindles of the fastening operation is mapped: the <code>appl_start</code> property consists of the following two parts:</p> <pre><code>appl_start = &lt;group&gt;&lt;sequence&gt;\n</code></pre> <p>where</p> <ul> <li><code>&lt;group&gt;</code> is a unique name to group the spindles of a single rundown. All bolts of a spindle group started through a single fastening operation must have the same <code>&lt;group&gt;</code> name.</li> <li><code>&lt;sequence&gt;</code> is the sequential number of the spindle as configured in the BS350 application. </li> </ul> <p>The following screenshot shows a sample mapping:</p> <p></p> <p>Here application number 11 (fastening operation) is defined in BS350 and selected on OGS (operation \"20Nm\"). The application consists of two bolts:</p> <ul> <li>Sequence #1: Name=\"Pos1\", Channel 4.3, Program 5</li> <li>Sequence #2: Name=\"Pos2\", Channel 4.4, Program 5</li> </ul> <p>The fastening operation in OGS is named <code>GRP1_B</code> (the <code>&lt;group&gt;</code> name)</p> <p>Note</p> <p>If a fastening operation is used multiple times in an OGS job, then a unique group name must be used for each fastening operation.</p> <p>If e.g. 3 times the dual-spindle application from the screenshot above shall be used, then the following six tasks can be  configured:</p> Application start OGS Task appl_start Group Sequence FO start #1 S1 GRP1_A1 GRP1_A 1 S2 GRP1_A2 2 FO start #2 S3 GRP1_B1 GRP1_B 1 S4 GRP1_B2 2 FO start #3 S5 GRP1_C1 GRP1_C 1 S6 GRP1_C2 2"},{"location":"tools/openprotocol/sys350-ke350/#loosen-behaviour","title":"Loosen behaviour","text":"<p>Even though there are more option (see the general discussion in OpenProtocol Tools - Loosen modes), the following section shows the common and recommended configurations.</p>"},{"location":"tools/openprotocol/sys350-ke350/#ccwsel-used","title":"CCWSel used","text":"<p>This is the preferred configuration, as the user-experience is most intuitive. Unfortunately the most often used start grip handles do not provide the neccessary signals, as a start grip handle with two outputs as follows is needed:</p> <ul> <li>CW: start signal for tightening</li> <li>CCWSel: state of the direction switch, true, if CCW selected</li> </ul> <p>With this configuration, the following settings are recommended:</p> <ul> <li><code>CHANNEL_&lt;tool&gt;_CCW_ACK</code> = 1</li> <li>Connect <code>OP1.1 Input</code> to <code>FO 1 CCWLock</code> </li> <li>Connect <code>OP1.0 Output</code> to the CCWSel signal of the handle (using AppIn/AppOut signals to bridge to IM24V/fieldbus)</li> <li>Usually <code>FO 1 NokAck</code> is not connected</li> </ul> <p>This forces the operator to switch the CW/CCW selection switch to CCW every time a loosen process is needed. Please note, that only the custom loosen program number can be used for loosen, as the CCW start signal is not assigned.</p>"},{"location":"tools/openprotocol/sys350-ke350/#no-ccwsel-but-nokack","title":"No CCWSel, but NokAck","text":"<p>As most start handles only provide seperate start CW and start CCW signals (without a signal for indicating the CW/CCW position), CCWSel often cannot be used. To ensure sequence interlock between tightening and loosening,  the <code>FO 1 NokAck</code> signal is connected to an external pushbutton (typically the start handle provides this). In this case, the following signals are typically used:</p> <ul> <li>CW: start signal for tightening</li> <li>CCW: start signal for loosening</li> <li>NOKAck: A normally closed (high) signal to acknowledge NOK, re-enable the tool</li> </ul> <p>With this configuration, the following settings are recommended:</p> <ul> <li><code>CHANNEL_&lt;tool&gt;_CCW_ACK</code> = 0</li> <li>Connect <code>OP1.1 Input</code> to <code>FO 1 CCWLock</code> </li> <li>Connect <code>FO 1 NokAck</code> to the external NokAck pushbutton</li> </ul> <p>This blocks the tool after an NOK until the NokAck button is pressed. The <code>FO 1 CCWLock</code> signal ensures that loosen is blocked, if it is not allowed. </p> <p>Note that loosening now uses the given application number set  in the tool configuration and uses the CW start. If applications with a different number of spindles are used, then an explicit rework operation must be defined, matching the tightening operation spindle set.</p>"},{"location":"tools/openprotocol/sys350-ke350/#no-ccwsel-no-nokack","title":"No CCWSel, no NokAck","text":"<p>See above, but interlock is now not possible. After a NOK rundown OGS immediately selects the loosen operation, which is started with the next start (CW) signal...</p>"},{"location":"tools/openprotocol/sys350-ke350/#hints","title":"Hints","text":""},{"location":"tools/openprotocol/sys350-ke350/#start-grip-handles","title":"Start grip handles","text":"<p>J\u00e4ger Handling provides start a large range of start grip handles. Most e-Handle models except the <code>SD</code>-series provide a seperate start signal as well as a CWSel signal with the position of the direction selection ring. All e-Handle models provide LEDs for enable, ok and nok results, some models also provide additional buttons for custom use  (e.g. NOK acknowledge). </p> <p></p> <p>When choosing a handle, check the following: - Models <code>EHHRRSD</code> and <code>EHARRSD</code> do not provide the CCWSel signal - Models without the <code>SD</code>-extension provide seperate start and CCWSel signals, e.g. <code>EHHRR</code></p>"},{"location":"tools/openprotocol/sys350-ke350/#possible-combinations","title":"Possible combinations","text":"<p>Please see the following document for the behaviour of the options depending on the selected configuration:  OGS Rexroth EC tools configuration behaviour for OGS.</p>"},{"location":"v3/lua/customtools/","title":"Lua custom tools","text":"","tags":["API"]},{"location":"v3/lua/customtools/#overview","title":"Overview","text":"<p>OGS has an interface to add additional tool drivers by adding Windows-DLLs to the <code>[TOOL_DLL]</code> section in <code>station.ini</code>. To make it easier to implement custom tool drivers, OGS provides <code>heLuaTool.dll</code> - this allows implementing tool drivers in pure LUA. </p> <p>To implement a tool driver in LUA, usually the following steps are required:</p> <ul> <li>Add/enable <code>heLuaTool.dll</code> in the <code>[TOOL_DLL]</code>-section in <code>station.ini</code></li> <li>Create a custom LUA tool driver file (see bvelow) and add it to your projects configuration (add the file name to the <code>requires = {}</code>-list in <code>config.lua</code>)</li> <li>Add one or more channels to <code>station.ini</code> (in the <code>[CHANNELS]</code>-section in <code>station.ini</code>). Note, that the section name assigned to the tool number must start with <code>LuaTool_</code>!</li> <li>Add the specified section to <code>station.ini</code> and set <code>Driver=heLuaTool</code> and <code>TYPE=</code> to the tool driver name as defined in your custom LUA tool driver</li> <li>Also add the tool/channel parameters as required by your LUA driver in the specified section.</li> <li>To allow using the custom tools, add then to the <code>custom</code> section in the heOpCfg tools editor tab. Also add new tool/action properties as required. Make sure to use the same tool/channel numbers as defined in your <code>station.ini</code>. </li> </ul> <p>Here is an excerpt from <code>station.ini</code> showing the relevant entries:</p> station.ini<pre><code>[TOOL_DLL]\nheLuaTool.dll=1 ; (1)!\n\n[CHANNELS]\n20=LuaTool_MyCustomTool ; (2)!\n\n[LuaTool_MyCustomTool]\nDriver=heLuaTool\nTYPE=MyCustomTool\n; additional LUA too specific parameters can follow\n</code></pre> <ol> <li> <p>Load and enable the generic LUA tool interface DLL</p> </li> <li> <p>Create the channel/tool 20 and assign the configuration section <code>LuaTool_MyCustomTool</code>. Make sure to start the section name with <code>LuaTool_</code>, else the Lua tool DLL will not get loaded for this section!</p> </li> </ol> <p>To implement a tool driver using LUA, there are basically two options:</p> <ol> <li>Use the low-level API provided by <code>heLuaTool.dll</code>.</li> <li>Use the Simplified API </li> </ol> <p>Info</p> <p>It is highly recommended to use the Simplified API described below to implement custom tool drivers - using the low-level API requires in-depth knowledge of the API to not break other drivers!</p>","tags":["API"]},{"location":"v3/lua/customtools/#lua-driver-anatomy-and-driver-registration","title":"LUA driver anatomy and driver registration","text":"<p>The LUA tool driver must be implemented as LUA module, returning the module table. Another requirement is to have the tool driver type as member <code>type</code> in the module table (this is how <code>station.ini</code> and the actual LUA driver is linked). </p> <p>In addition to this, it is required to register the driver module with OGS by adding the tool driver type and its module to the global <code>lua_known_tool_types</code> table - best practice is to use the function <code>register_tool</code> from the <code>lua_tool_helpers</code>-module.</p> <p>Here is a skeleton of a driver module:</p> my_custom__driver.lua<pre><code>-- My custom LUA tool driver\nlocal _M = {\n    type = 'MyCustomTool',     -- type id (must match the DRIVER= in INI file)\n}\n\n-- register this tool with OGS (heLuaTool.dll)\nlocal helpers = require('lua_tool_helpers')\nhelpers.register_tool(_M)\n\n-- return the module\nreturn _M\n</code></pre>","tags":["API"]},{"location":"v3/lua/customtools/#simplified-api","title":"Simplified API","text":"<p>The simplified custom tool driver API uses five states and associated transitions to implement the tool behaviour. Each transitions can be implemented in the custom tool LUA code to provide the custom functionality - if not implemented, the transition is executed without a custom action.</p> <p>Here is the state diagram for the behaviour:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; active: init()\n    inactive --&gt; active: activate()\n    active --&gt; inactive: deactivate()\n    active --&gt; enabled: enable()\n    enabled --&gt; enabled: execute()\n    enabled --&gt; disabled: disable()\n    disabled --&gt; enabled: enable()\n    disabled --&gt; inactive: deactivate()</code></pre> <p>The <code>active</code> state is entered whenever OGS has an active operation for this tool. While the tool is <code>active</code>, it might switch back and forth between <code>disabled</code> and <code>enabled</code> (e.g. depending on any external enable/release condition).  After a tool result has been received, the state typically switches back to <code>inactive</code> (another tool is active or workflow has finished). </p> <p>Info</p> <p>Use the <code>lua_tool_helpers.lua</code> in your code - this provides helpers for registering the tool driver, flexible default formatting functions and a few handy helpers!</p>","tags":["API"]},{"location":"v3/lua/customtools/#tool-driver-interface-functions","title":"Tool driver interface functions","text":"<p>The actual tool driver implementation is provided by implementing the tool driver interface functions - and return them as members of the module table. Note that each interface has a <code>channel</code> parameter with</p> <p>A typical implementation would look like the following (adding the <code>_M.init()</code>, the <code>_M.enable()</code> and the the <code>_M.execute()</code> functions):</p> my_custom__driver.lua<pre><code>-- My custom LUA tool driver\nlocal _M = {\n    type = 'MyCustomTool',     -- type id (must match the DRIVER= in INI file)\n}\nlocal helpers = require('lua_tool_helpers')\n\n-------------------------------------------------------------\n-- Tool event: Initialize tool - called once during OGS init \n-- return 'OK' or some error text if the initialization failes.\nfunction _M.init(channel)\n    -- Decode/get my configuration (from station.ini)\n    local cfg = {\n        ComPort = channel.ini_params.COM_PORT,      -- COM port\n    }\n    -- Do whatever is needed to initialize your driver\n    -- ...\n    channel.cfg = cfg         -- store the channels config data\n    return 'OK'               -- init successfully done\nend\n\n----------------------------------------------------------------------------\n-- Tool event: Cyclically called while the tool is enabled\n-- return the tool task state\nfunction _M.execute(channel)\n    -- Check for tool finished\n    local ResultData = _M.GetResultData() -- must be implemented!\n    if ResultData == nil then       -- no data available from the tool\n        return channel.task_state   -- wait more.\n    end\n    if ResultData.Error then        -- some error occurred\n        return lua_task_fault       -- return an error code\n    end\n    if ResultData.Data then         -- received data\n        -- Build a result data table and notify the OGS core \n        local values = {\n            ResultData.torque,          -- M1 actual value\n            ResultData.angle,           -- M2 actual value\n            ResultData.t_min,           -- M1 min\n            ResultData.t_max,           -- M1 max\n            0.0,                        -- M2 min\n            0.0                         -- M2 max\n        }\n        local error_code = helpers.get_code_from_limits(ResultData.torque, ResultData.t_min, ResultData.t_max)\n        lua_tool_result_response(channel.tool, error_code, 0, '2A', values)\n        return lua_task_completed\n    end\n    return channel.task_state       -- wait more.\nend\n\n-------------------------------------------------------------\n-- Tool event: Called whenever the tool is to be enabled\n-- @ output: true|false  - tool enabled/not enabled \n--                         (will be called again until enabled!)\nfunction _M.enable(channel)\n    local cfg = channel.cfg     -- access the channel config data\n    -- Do whatever is needed\n    return true                 -- tool is enabled\nend\n\n-------------------------------------------------------------\n-- register this tool with OGS (heLuaTool.dll)\nhelpers.register_tool(_M)\n-- return the module\nreturn _M\n</code></pre> <p>The following functions can be implemented as part of the <code>simple</code> LUA tool driver interface:</p> Function Name Return Type Description Tags <code>init(channel: table)</code> <code>result: string</code> Is called once for each tool (channel) registered in <code>station.ini</code> for this driver. The <code>channel</code> table parameter has the <code>channel.tool</code> entry set to the channel/tool number defined in <code>[CHANNELS]</code> (from <code>station.ini</code>) and the <code>channel.ini_params</code> as a table of strings with the complete <code>LuaTool_...</code>-section from <code>station.ini</code>. Return <code>'OK'</code> on successful initialization, else an error message string. Hint: The driver can add its own instance data to the <code>channel</code> table for later use. None <code>activate(channel: table)</code> <code>result: boolean</code> Is called whenever OGS activates a tool (i.e. the workflow switches to an action/operation where this tool is needed). The function is called cyclically until it returns <code>true</code> None <code>deactivate(channel: table)</code> <code>result: boolean</code> Is called whenever OGS deactivates a tool (i.e. the workflow switches to another action/operation). The function is called cyclically until it returns <code>true</code> None <code>enable(channel: table)</code> <code>result: boolean</code> Is called whenever the tool is active and OGS needs to enable a tool. The function is called cyclically until it returns <code>true</code> None <code>disable(channel: table)</code> <code>result: boolean</code> Is called whenever the tool is active and OGS needs to disable a tool (e.g. if some external condition is removed like an external enable signal). The function is called cyclically until it returns <code>true</code> None <code>execute(channel: table)</code> <code>result: number</code> Is called while the tool is enabled to check the tool, if it has finished. If so, the global function <code>lua_tool_result_response</code> should be called (to send result data to the OGS core) and a value of <code>lua_task_completed</code> should be returned. If the function should be called again (tool not yet finished), return <code>channel.task_state</code>. In case of an error, return <code>lua_task_fault</code> or some of the other error codes (see <code>lua_tool.lua</code> in the <code>lualibs</code> folder for details) None <p>Note</p> <p>To cyclically poll a tool driver (e.g. to implement network communication), implement the modules <code>_M.poll()</code> function (low-level API) or register a global StatePoll function (use <code>StatePollFunctions.add()</code> and use the (low-level API) _M.channels table to iterate your drivers registered channels).</p>","tags":["API"]},{"location":"v3/lua/customtools/#tool-driver-formatting-functions","title":"Tool driver formatting functions","text":"<p>To allow the LUA tool drivers to correctly present their values on the OGS user interface screen, the following module interface functions can be used:</p> <ul> <li>_M.get_tool_units(): Defines the unit texts and number of digits used for formatting the tool results in the action/operation list pane. </li> <li>_M.get_tool_result_string(): Defines the main (large) result text shown in the bottom right corner result pane.</li> <li>_M.get_footer_string(): Defines the footer string shown in the bottom right corner result pane.</li> <li>_M.get_prg_string(): Defines the program string shown in the upper right corner of the bottom right corner result pane.</li> </ul> <p>As the functions are part of the low-level API, they are passed the the tool number instead of the channel table (as with the simple API interface). As the LUA tool driver infrastructure keeps a list of registered channels in each tool drivers module table, this can be used to access the channel table from a given tool as follows:</p> <pre><code>-- Get the channel table from a given tool number\n_M.get_channel_from_tool = function(tool)\n    local channel = _M.channels[tool]\n    return channel\nend\n</code></pre> <p>The following functions can be implemented for formatting:</p> Function Name Return Type Description Tags <code>get_tool_units(tool: number)</code> <code>unit1: string, unit2: string, decimals1: number, decimals2: number</code> Returns the unit text and number of decimals used for showing the result values in the result list. None <code>get_tool_result_string(tool: number)</code> <code>text: string</code> Returns the center text shown in the result pane. None <code>get_footer_string(tool: number)</code> <code>text: string</code> Returns the footer text for the result pane. None <code>get_prg_string(tool: number)</code> <code>text: string</code> Returns the program name/number text for the result pane (the top right text). None <p>The <code>lua_tool_helpers</code> module provides a reusable implementation for formatting text by specifying a format string - and a helper function to read the format strings from the <code>station.ini</code> tool driver sections.</p> <p>Here is some sample code on how to use it:</p> <pre><code>local helpers = require('lua_tool_helpers')\nlocal _M = {\n    type = 'MyLuaTool',     -- type identifier (as in INI file)\n}\n\n-------------------------------------------------------------\n-- Initialize the driver and read the parameter section\nfunction _M.init(channel)\n    -- local (tool instance specific) parameters\n    local cfg = {\n        -- Initialize the parameters for formatting\n        fmt = helpers.read_fmt_config(channel)\n    }\n    channel.cfg = cfg\n    return 'OK'\nend\n\n-------------------------------------------------------------\n-- Get the tool specific measurement units \n-- @param tool: channel number as configured in station.ini\n-- @return:  applicable only for the first two values (from 6)\n_M.get_tool_units = function(tool)\n    local channel = _M.channels[tool]\n    return helpers.get_tool_units(channel, channel.cfg.fmt)\nend\n-- Get the tool specific result string\n_M.get_tool_result_string = function(tool)\n    local channel = _M.channels[tool]\n    return helpers.get_tool_result_string(channel, channel.cfg.fmt)\nend\n-- Get the tool specific footer string\n_M.get_footer_string = function(tool)\n    local channel = _M.channels[tool]\n    return helpers.get_footer_string(channel, channel.cfg.fmt)\nend\n-- Get the tool specific program name\n_M.get_prg_string = function(tool)\n    local channel = _M.channels[tool]\n    return helpers.get_prg_string(channel, channel.cfg.fmt)\nend\n</code></pre>","tags":["API"]},{"location":"v3/lua/customtools/#tool-driver-miscelaneous-functions","title":"Tool driver miscelaneous functions","text":"<p>tbd.</p>","tags":["API"]},{"location":"v3/lua/eventlog/","title":"Workflow and interaction events","text":""},{"location":"v3/lua/eventlog/#overview","title":"Overview","text":"<p>The OGS core allows to subscribe for various events from the kernel. The main use case is to log all actions to allow full traceability or to measure event timings.</p> <p>The LUA eventlog interface consists of the single global table <code>EventLog</code> - and a few functions which are called by OGS. The <code>EventLog</code> table must be created by the LUA code during startup, as <code>EventLog.Init()</code> is only called once during the OGS startup sequence.</p> <p>The following functions should be defined to use the EventLog-Interface:</p> <ul> <li><code>EventLog.Init()</code>: Is called during OGS startup. To enable the EventLog events, the function must return true.</li> <li><code>EventLog.Stop()</code>: Is called before OGS shuts down. </li> <li><code>EventLog.Write(EventType, ...)</code>: Is called whenever a new event is emitted by the OGS core.</li> </ul> <p>The following <code>EventType</code> values are currently supported:</p> <ul> <li><code>COMMON</code> (= 0): </li> <li><code>BARCODE</code> (= 1): </li> <li><code>INTERACTION</code> (= 2):</li> <li><code>USER_LOGON</code> (= 3):</li> <li><code>ALARM</code> (= 4):</li> <li><code>WORKFLOW</code> (= 5): </li> <li><code>RESULT</code> (= 6): Called whenever the current tool result is updated.</li> <li><code>SOFTWARE_ERROR</code> (= 7):  -- configuration( ini)  errors</li> </ul>"},{"location":"v3/lua/eventlog/#events","title":"Events","text":"<p>The <code>EventLog.Write(EventType, ...)</code> function is called with different parameters, depending on the actual <code>EventType</code>. If the event is related to a user action, then the parameters <code>User1</code> and <code>User2</code> provide information about the users logged on when the event occurred. The parameters are as follows:</p> <ul> <li><code>User1</code>: The operator-level user</li> <li><code>User1</code>: The supervisor-level user (if logged on)</li> </ul>"},{"location":"v3/lua/eventlog/#common-event","title":"Common event","text":"<p>The common event is currently not used by the OGS core, but reserved as a general status/text event placeholder. It can be used e.g. from the LUA side to inject custom events. The function signature is as follows:</p> <pre><code>EventLog.Write(BARCOMMON, Status, Text)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li>Status (int): Custom status code</li> <li>Text (string): Custom event message</li> </ul>"},{"location":"v3/lua/eventlog/#barcode-event","title":"Barcode event","text":"<p>The barcode event is fired, whenever a new barcode is received. The function signature is as follows:</p> <pre><code>EventLog.Write(BARCODE, FieldNo, User1, User2, Code, Source, Tag)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li>FieldNo: Barcode field number (reference into the barcode table)</li> <li>Code: The actual ID-Code value</li> <li>Source: The ID code source (<code>Barcode</code>, <code>RFID</code>, ... whatever is configured in <code>station.ini</code> or added through <code>barcode.lua</code>)</li> <li>Tag: The barcode table tag name - typically used to identify the type of the scanned bar code. This has a 1:1 relation to the FieldNo value and is defined in the projects barcode table (see <code>barcode.lua</code>).</li> </ul>"},{"location":"v3/lua/eventlog/#interaction-event","title":"Interaction event","text":"<p>The interaction event is fired, whenever one of the operator buttons is pressed on the GUI. The function signature is as follows:</p> <pre><code>EventLog.Write(INTERACTION, Request, User1, User2, Text, JobSeq, OpSeq, Field)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li> <p>Request: The actual request code, one of the following:</p> <ul> <li> <p>noReq (0x0000=: no request</p> </li> <li> <p>finishProcess (0x0001): finish assembly processing</p> </li> <li>clearProcess (0x0002): clear all tightening results on assembly go to first Job</li> <li>startJob (0x0004): start current Job (is available only in WorkflowState::WaitJobStart)</li> <li>finishJob (0x0008): finish current Job processing and set WorkflowState::WaitJobStart</li> <li>skipJob (0x0010): finish current Job processing and go to next Job</li> <li>clearJob (0x0020): clear all tightening results on current Job and set WorkflowState::WaitJobStart</li> <li>skipRundown (0x0040): set current operation to NOK and go to next operation</li> <li>clearBolt (0x0080): set current Bolt to NOT_PROCESSED</li> <li>startDiag (0x0100): enable start diagnostic job</li> <li>selectRundown (0x0200): select Job / Bolt in view or on image</li> <li>userLogon (0x0400): user logon</li> <li>pauseJob (0x0800): pause Job</li> <li>processNOK (0x1000): continue processing after NOK result</li> <li>CCW (0x2000): CCW</li> <li>manualInput (0x4000): manual input in start view (added for LUA trace log only)</li> <li>unmountJob (0x8000): unmount Job</li> <li>switchTool (0x10000): switch between alternative and standard tool</li> <li>teachToolPos (0x20000): enable teach mode for teaching a new tool position (only if positioning mode is enabled)</li> </ul> </li> <li> <p>Text: Usually empty, except for the <code>manualInput</code> request - in this case provides the actual manual input value.</p> </li> <li>JobSeq: Current job sequence</li> <li>OpSeq: Current task/operation sequence</li> <li>Field: Used for the <code>manualInput</code> request - has the field name for which data was entered.</li> </ul>"},{"location":"v3/lua/eventlog/#logon-event","title":"Logon event","text":"<p>The logon event is fired, whenever a user logs on or off. The function signature is as follows:</p> <pre><code>EventLog.Write(LOGON, Status, User1, User2, Text, Level)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li> <p>Status: Logon result status, one of the following values</p> <ul> <li>0 = Success (user is logged on)</li> <li>-1 = Username not found (unknown username or database connection error)</li> <li>-2 = Invalid password (or password check failed)</li> <li>-3 = No priviledges (user is known, password is correct, but missing rights for actual logon - might happen, if e.g. certification check or trainig checks fail for the user (or are outdated))</li> <li>1 = Logoff (user has successfully logged off)</li> <li>2 = Autologon (the autologon user is now logged on)</li> </ul> </li> <li> <p>Text: Depending on the status value one of the following</p> <ul> <li>'login': for successful user login.</li> <li>'autologon' for failed user autologon </li> <li>username in case of otherwise failed login attempts</li> </ul> </li> <li> <p>Level: Active user level (0 = nobody logged in, 1 = operator level, 2 = supervisor level, 3 = admin level)</p> </li> </ul>"},{"location":"v3/lua/eventlog/#alarm-event","title":"Alarm event","text":"<p>The alarm event is fired, whenever a new alarm is raised or if an alarm state changes. The function signature is as follows:</p> <pre><code>EventLog.Write(ALARM, Status, User1, User2, Text)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li>Status (int): Alarm level (0 = alarm cleared)</li> <li>Text (string): Alarm message</li> </ul>"},{"location":"v3/lua/eventlog/#workflow-event","title":"Workflow event","text":"<p>The workflow event is fired, whenever the workflow state changes. The function signature is as follows:</p> <pre><code>EventLog.Write(WORKFLOW, Status, User1, User2, Text)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li>Status (int): Type code</li> <li>Text (string): Descriptive message</li> </ul>"},{"location":"v3/lua/eventlog/#result-event","title":"Result event","text":"<p>The result event is fired, whenever the result state for the current tool operation changes. The function signature is as follows:</p> <pre><code>EventLog.Write(RESULT, Status, User1, User2, Text)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li>Status (int): Quality code of the result</li> <li>Text (string): currently not used</li> </ul>"},{"location":"v3/lua/eventlog/#sample-code","title":"Sample code","text":""},{"location":"v3/lua/eventlog/#write-events-to-a-logfile","title":"Write events to a logfile","text":"<p>A sample implementaion for logging all events to a file is provides in <code>heEventLog.lua</code> (in the lualib folder).</p>"},{"location":"v3/lua/eventlog/#send-events-over-mqtt","title":"Send events over MQTT","text":"<p>To send the events over MQTT, here is a snippet on how to convert the event data into a json message ready to be published over MQTT.</p> <p>The sample omits the MQTT boilerplate code and focuses on the Eventlog implementation (see luamqttclient for more info).</p> <p><pre><code>local mqtt = require('luamqttclient')\nlocal json = require('json')    \n\nlocal MqttTopic = 'mytopic/mysubtopic'      -- the MQTT event topic\n\n-- setup the global eventlog table\nEventLog = {\n}\n\n-- The init function called from OGS\nEventLog.Init = function()\n\n    --[[\n        initialize MQTT [omitted]\n    ]]\n\n    -- send a MQTT bootup message\n    local msg = json.encode({type=0,name='COMMON',status=0,text='OGS started'})        \n    MC:Publish(MqttTopic, 0, msg)\n\n    return true\nend\n\n-- The Stop function - send a MQTT shutdown message\nEventLog.Stop = function()\n    -- send a MQTT shutdown message\n    local msg = json.encode({type=0,name='COMMON',status=0,text='OGS shutdown'})        \n    MC:Publish(MqttTopic, 0, msg)\nend\n\n-- Define a event parameter/name mapping table\nEventLog.EvtParms = {   -- define custom tags names for the function parameters\n    [1] = { name='BARCODE',     'fieldno', 'user1', 'user2', 'code', 'source', 'tag' },\n    [2] = { name='INTERACTION', 'status', 'user1', 'user2', 'text', 'jobseq', 'opseq', 'field' },\n    [3] = { name='USER_LOGON',  'status', 'user1', 'user2', 'login', 'level' },\n    [4] = { name='ALARM',       'severity', 'user1', 'user2', 'message' },\n    [5] = { name='WORKFLOW',    'status', 'user1', 'user2', 'message', 'source', 'tag' },\n    [6] = { name='RESULT',      'status', 'user1', 'user2', 'code', 'source', 'tag' },\n    --[0] = { name='COMMON', 'type', 'status', 'text' },\n    --[7] = { name='SOFTWARE_ERROR', 'type', 'status', 'text' },\n}\n\n-- The Eventlog.Write function is called from OGS whenever a new event occurrs\nEventLog.Write = function (type, ...)\n    -- map the parameters/names depending on the event type\n    local params = EventLog.EvtParms[type]\n    local t = os.date('*t')\n    local res = {\n        type = type,\n        timestamp = string.format('%04d-%02d-%02d %02d:%02d:%02d',t.year,t.month,t.day,t.hour,t.min,t.sec),\n    }\n    res.name = params.name or 'UNKNOWN'\n    if params then\n        for i = 2,#arg do\n            res[params[i-1]] = arg[i-1]\n        end\n    end\n    -- publish over mqtt\n    local msg = json.encode(res)        \n    MC:Publish(MqttTopic, 0, msg)\nend\n</code></pre> Running this code then generates json messages like the following (login event):</p> <pre><code>{\n    \"type\":3,\n    \"timestamp\":\"2023-03-31 09:56:00\",\n    \"name\":\"USER_LOGON\",\n    \"status\":0,\n    \"user1\":\"U40003ACC4D\",\n    \"user2\":\"\",\n    \"login\":\"login\"\n}\n</code></pre>"},{"location":"v3/lua/userrights/","title":"Userrights","text":"<pre><code>finishProcess   = 0x0001 ,  // finish assembly processing (without waiting)\nclearProcess    = 0x0002,   // clear all tightening results on assembly go to first Job\n\nstartJob        = 0x0004,   // start current Job (is available only in WorkflowState::WaitJobStart)\nfinishJob       = 0x0008,   // finish current Job processing and set WorkflowState::WaitJobStart\nskipJob         = 0x0010,   // finish current Job processing and go to next Job\nclearJob        = 0x0020,   // clear all tightening results on current Job and set WorkflowState::WaitJobStart\n\nskipRundown     = 0x0040,   // set current operation to NOK and go to next operation\nclearBolt       = 0x0080,   // set current Bolt to NOT_PROCESSED\nstartDiag       = 0x0100,   // enable start diagnostic job\nselectRundown   = 0x0200,   // select Job / Bolt in view or on image\nuserLogon       = 0x0400,   // user logon\npauseJob        = 0x0800,   // pause Job\nprocessNOK      = 0x1000,   //continue processing after NOK result\nCCW             = 0x2000,   // CCW\nmanualInput     = 0x4000,   // manual input in start view (added for LUA trace log only)\nunmountJob      = 0x8000,   // unmount Job\nswitchTool      = 0x10000,  // switch between alternative and standard tool\nteachToolPos    = 0x20000,  // teach Tool position\nwaitFinishProcess = 0x40000,  // finish assembly processing normally (wait for completion)\n</code></pre>"},{"location":"v3/lua/webbrowser/","title":"Browser","text":""},{"location":"v3/lua/webbrowser/#overview","title":"Overview","text":"<p>The OGS runtime uses up to 4 web browser (Microsoft WebView2) instances. The instances are:</p> <ul> <li><code>StartView</code>: Browser on the start screen</li> <li><code>ProcessView</code>: Browser on the process screen (only visible, if the <code>url</code>-parameter in the job/task is set)</li> <li><code>SidePanel</code>: Browser on the slide-in side panel (requires enabling the sidepanel in <code>station.ini</code>)</li> <li><code>InstructionView</code>: Browser in the instruction view popup (is triggered from LUA, so only visible with custom LUA code)</li> </ul> <p>The OGS infrastructure provides functions to bidirectionally exchange data between the JavaScript code running inside the web browser and the LUA code running inside OGS. There is a LUA function to execute JavaScript code in the webbrowser and a JavaScript bridge, which calls a LUA function (if registered accordingly). To make things a bit easier, starting with OGS V3.0.8510, there is also a JavaScript helper object injected into the page.</p> <p>To implement this functionality, OGS provides the following:</p> <ul> <li>For the LUA side: a global <code>Browser</code> table with functions to manipulate the browser instances</li> <li>For the JavaScript side: <ul> <li>an injected JavaScript helper object, which provides easy to use functions to access the Bridge and send a message string</li> <li>the (lowlevel) JavaScript hostObjects bridge accessibal through the <code>hostObjects</code> interface of the Chromium browser (<code>window.chrome.webview.hostObjects.sync.&lt;instance&gt;</code>, with <code>instance</code> one of the above)</li> </ul> </li> </ul>"},{"location":"v3/lua/webbrowser/#injected-javascript-helper-object","title":"Injected JavaScript helper object","text":"<p>NOTE: Available starting with OGS V3.0.8510.</p> <p>OGS injects a JavaScript <code>OGS</code> object into the page after the \"NavigationComplete\" Event of the Edge Browser. This especially makes using the <code>Bridge</code> to send messages out to the OGS core easier (see JavaScript hostObjects bridge below for details) and also allows overriding some events. The <code>OGS</code>-object provides the following members:</p> <ul> <li><code>getBridgeName(): string</code>: Returns the bridge instance name (which is identical to the browser instance name, e.g. <code>'StartView'</code>).</li> <li><code>SendCmd(cmd: string): boolean</code>: send the <code>cmd</code> string  to the OGS core. The function returns <code>true</code>, if the string was sent correctly. If <code>false</code> is returned, the command was not sent. This usually happens during and shortly after page load (and even for a small time after DocumentComplete), as the Edge bridge host object needs some time to initialize. Best practice is to embed the <code>SendCmd()</code> into a timer started with window.onload() or in the body. An even better option is to implement the OGS.onInit() override (see sample below).</li> <li>event: <code>onInit(url: string)</code>: This function can be implemented on the JavaScript side to get notified when OGS is done loading the webpage (called after the <code>OnNavigateComplete</code>-Event of the Edge browser). This can(should) be used to have a reliable event on when the OGS-Communication is available.</li> <li>event: <code>onShow()</code>: This function can be implemented on the JavaScript side to get notified when the web browser gets visible to the user. This is especially useful for the <code>SidePanel</code> view, as the user can open/close the browser view without reloading the page.</li> <li>event: <code>onHide()</code>: This function can be implemented on the JavaScript side to get notified when the web browser gets visible to the user.</li> </ul> <p>Here is a sample on how to use the <code>OGS</code>-JavaScript helper oject to send a \"hello\"-message after the bridge gets ready:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html &gt;\n&lt;/html&gt;\n&lt;body&gt;\n&lt;!-- whatever content is in the page --&gt;\n&lt;/body&gt;\n\n&lt;script&gt;\n// Create the OGS object and implement the callbacks/events\nOGS = {};       \nOGS.onInit = function(url) {\n    console.log(\"OGS.onInit called: \", url, OGS);\n    // if we get here, everyhing is initialized, so now send the 'hello' message\n    OGS.SendCmd('hello!');\n}\nOGS.onShow = function OGS_onShow() {\n    console.log(\"OGS.onShow called!\");\n}\nOGS.onHide = function() {\n    console.log(\"OGS.onHide called!\");\n}\n&lt;/script&gt;\n</code></pre> <p>An alternative way (without using the OGS object) would be to poll until everything is ready:</p> <pre><code>// Send Hello after the bridge is ready\nfunction SendHello()\n    var timer = window.setInterval( () =&gt; {\n        if (OGS) {  // check, if the global OGS object exists\n            if (OGS.SendCmd('Hello')) {\n                // successfully send, remove the timer\n                clearInterval(timer);\n            }\n        }\n    }, 100);    // execute every 100ms until the bridge is ready\nend\nwindow.onload = function() {\n    SendHello();\n}\n</code></pre>"},{"location":"v3/lua/webbrowser/#javascript-hostobjects-bridge","title":"JavaScript hostObjects bridge","text":"<p>NOTE: Starting with OGS V3.0.8510, it is recommended to use the JavaScript hostObjects bridge (see previous section) instead. </p> <p>To allow interaction between the JavaScript code running in the Browser and the OGS core, OGS registers a hostObject in the WebView2 browser for the JavaScript side. The registered object is named identically to the browser instance, e.g. <code>StartView</code> and implements a single string property <code>ObjectMessage</code>.</p> <p>To send a string to OGS from JavaScript, simply assign a value to the <code>window.chrome.webview.hostObjects.sync.&lt;instance&gt;.ObjectMessage</code> property (<code>instance</code> is the name of the actual browser instance, e.g. <code>StartView</code>, <code>ProcessView</code>, ..., see above).</p> <p>NOTE: To use the bridge, one has to use the correct <code>&lt;instance&gt;</code>!</p>"},{"location":"v3/lua/webbrowser/#sample-code","title":"Sample code","text":"<pre><code>// send a command string to OGS - from the StartView instance\nfunction sendOgsCommand(cmd)\n{\n    if (!window.chrome || !window.chrome.webview\n     || !window.chrome.webview.hostObjects\n     || !window.chrome.webview.hostObjects.sync) {\n        // WebView2 is not yet fully initialized\n        return;     \n    }\n    let ogs = window.chrome.webview.hostObjects.sync.StartView;\n    if (ogs) {\n        ogs.ObjectMessage = cmd;    \n    }\n}\n</code></pre>"},{"location":"v3/lua/webbrowser/#global-browser-table","title":"Global Browser table","text":"<p>OGS exposes the browser instances through the global <code>Browser</code> object. The <code>Browser</code> object implements the following functions:</p> <ul> <li>Navigate: Load a new URL in the web browser</li> <li>ExecJS_nonblocking: Run javascript inside the web browser (asynchronously, not returning a value)</li> <li>RegMsgHandler: Register a LUA callback function to be called when the JavaScript side writes to the object message endpoint.</li> </ul>"},{"location":"v3/lua/webbrowser/#navigate","title":"Navigate","text":"<p>The <code>Browser.Navigate</code> function starts loading a new URL into the given browser instance.</p> <pre><code>Browser.Navigate(instance, url)\n</code></pre>"},{"location":"v3/lua/webbrowser/#parameters","title":"Parameters","text":"<ul> <li>instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') </li> <li>url [string]: Url to navigate the browser instance to (in the standard URL format, e.g. file://filename or https://server/page)</li> </ul>"},{"location":"v3/lua/webbrowser/#sample-code_1","title":"Sample code","text":"<pre><code>-- Navigate the StartView browser to https://www.my-url.com/mypage\nBrowser.Navigate('StartView', 'https://www.my-url.com/mypage')\n</code></pre>"},{"location":"v3/lua/webbrowser/#show","title":"Show","text":"<p>The <code>Browser.Show</code> function is similar to the <code>Browser.Navigate</code> function, but also ensures the webbrowser is actually visible. The actual behaviour depends on the view - e.g. for the <code>SidePanel</code> view, the side panel pops out. For the <code>ProcessView</code> view, this switches from the image-view to the web view.</p> <pre><code>local oldUrl = Browser.Show(instance, url)\n</code></pre>"},{"location":"v3/lua/webbrowser/#parameters_1","title":"Parameters","text":"<ul> <li>instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') </li> <li>url [string]: Url to navigate the browser instance to (in the standard URL format, e.g. file://filename or https://server/page)</li> </ul>"},{"location":"v3/lua/webbrowser/#return-value","title":"Return value","text":"<p>The function returns the \"current\" URL of the webbrowser (the URL before changing to the given one). This can be used to return to the previous URL after hiding the browser.</p>"},{"location":"v3/lua/webbrowser/#sample-code_2","title":"Sample code","text":"<pre><code>-- Make the SidePanel visible and navigate the\n-- web browser to https://www.my-url.com/mypage\nlocal oldUrl = Browser.Show('SidePanel', 'https://www.my-url.com/mypage')\n</code></pre>"},{"location":"v3/lua/webbrowser/#hide","title":"Hide","text":"<p>The <code>Browser.Hide</code> function is complementary to the <code>Browser.Show</code> function - it closes the browser view (only relevant for <code>SidePanel</code> and <code>ProcessView</code>).</p> <pre><code>Browser.Hide(instance)\n</code></pre>"},{"location":"v3/lua/webbrowser/#parameters_2","title":"Parameters","text":"<ul> <li>instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') </li> </ul>"},{"location":"v3/lua/webbrowser/#sample-code_3","title":"Sample code","text":"<pre><code>-- Hide the SidePanel\nBrowser.Hide('SidePanel')\n</code></pre>"},{"location":"v3/lua/webbrowser/#regmsghandler","title":"RegMsgHandler","text":"<p>The <code>Browser.RegMsgHandler</code> function registers or unregisters a LUA function to be called whenever the JavaScript running in the browser writes a message to the hostObject bridge <code>OGS.ObjectMessage</code> property.</p> <p>NOTE: Calling the function mutliple times with the same url parameter  will replace a previously registered handler for the same url.</p>"},{"location":"v3/lua/webbrowser/#function-signature","title":"Function signature","text":"<pre><code>-- Register the callback function\nfn, err = Browser.RegMsgHandler(instance, callbackfn, url)\n</code></pre>"},{"location":"v3/lua/webbrowser/#parameters_3","title":"Parameters","text":"<ul> <li> <p>instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') </p> </li> <li> <p>callbackfn [function]: LUA function to be called when the JavaScript code writes a string to the <code>OGS.ObjectMessage</code> hostObject. If callbackfn is <code>nil</code>, then the current registration is removed. The callback function has the following signature:</p> <pre><code>callbackfn(instance, objectMessage)\n</code></pre> <p><code>instance</code> [string] is the web browsers instance name (e.g. 'StartView') and <code>objectMessage</code> [string] the text which was written to the <code>OGS.ObjectMessage</code> property of the hostObject bridge from the JavaScript side.</p> </li> <li> <p>url [string or nil]: The optional <code>url</code> parameter allows registering seperate message handlers for different URLs shown in the browser. This is especially handy for the <code>SidePanel</code> view, where typically different pages are viewed (see Browser.show(...url...) above). If the <code>url</code> parameter is missing (on nil), then the handler is registered globally (for the given browser instance).</p> </li> </ul>"},{"location":"v3/lua/webbrowser/#return-values","title":"Return values","text":"<p>If the function was executed successfully, the callbackfn is returned as the first return value. Else nil is returned and the second return value has an error message string (wrong parameters or unknown instance).</p>"},{"location":"v3/lua/webbrowser/#sample-code_4","title":"Sample code","text":"<pre><code>local function callbackfn(instance, objectMessage)\n    -- do whatever you want to do here if the javascript \n    -- code writes the OGS.ObjectMessage property\nend\n\n-- Register a LUA function to be called from the JavaScript side\nBrowser.RegMsgHandler('StartView', callbackfn)\n</code></pre>"},{"location":"v3/lua/webbrowser/#execjs_nonblocking","title":"ExecJS_nonblocking","text":"<p>The <code>Browser.ExecJS_nonblocking</code> executes JavaScript code in the web browser instance.</p> <pre><code>Browser.ExecJS_nonblocking(instance, jstext)\n</code></pre>"},{"location":"v3/lua/webbrowser/#parameters_4","title":"Parameters","text":"<ul> <li>instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') </li> <li>jstext [string]: JavaScript string to execute in the browser. Note that this must be valid JavaScript code. </li> </ul> <p>NOTES: </p> <ul> <li>When passing strings through the function, make sure to properly escape them!</li> <li>Best practice is to write a JavaScript function in the web page and only call it through this function.</li> <li>You can serialize LUA objects to a JSON string and pass this through the function. The JavaScript side can then easily deserialize it.</li> <li>You can only call Javascript functions defined in the global scope from the LUA/OGS side. Make sure to either register them in a global object (e.g. add them to the OGS object (best), to window or to globalThis) .</li> </ul>"},{"location":"v3/lua/webbrowser/#sample-code_5","title":"Sample code","text":"<p>LUA side:</p> <pre><code>-- define which browser view to use\nlocal instance = 'StartView'\n\n-- define a function to be called from JavaScript\nlocal callbackfn = function(instance, msg)\n    XTRACE(16, \"I am called from Javascript: msg=\" .. msg)\nend\n\n-- Register (global) callback for the browser instance\nBrowser.RegMsgHandler(instance, callbackfn)\n\n-- Build a JavaScript command, call the function \"OGS.myFunction\" with\n-- some JSON text\nlocal param = '{ \"cmd\": \"showmessage\" }'\nlocal command = \"OGS.myFunction(\"..param..\");\"\n-- Call the JavaScript function in the browser instance\nBrowser.ExecJS_nonblocking(instance, command)\n</code></pre> <p>Javascript side (for the StartView browser window):</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html &gt;\n&lt;/html&gt;\n&lt;body&gt;\n&lt;!-- whatever content is in the page --&gt;\n&lt;/body&gt;\n\n&lt;script&gt;\n// Create the OGS object and implement the callbacks/events\nOGS = {};       \nOGS.onInit = function(url) {\n    // if we get here, everyhing is initialized, so now send the 'hello' message\n    OGS.SendCmd('hello!');\n}\nOGS.myFunction = function(params) {\n    // This function was called from LUA code\n    console.log(\"OGS.myFunction called!\", params);\n    // Now call back into OGS and return a complex object\n    var retval = { cmd: 'test', params: { p1: 1, p2: 'string' } };\n    OGS.SendCmd(JSON.stringify(retval));\n}\n&lt;/script&gt;\n</code></pre>"},{"location":"v3/lua/webserver/","title":"Webserver","text":""},{"location":"v3/lua/webserver/#overview","title":"Overview","text":"<p>The OGS runtime uses the Microsoft Windows builtin http.sys web server to server static pages and dynamic pages. The dynamic pages are implemented through LUA scripting and makes it possible to flexibly implement web services like OpenAPI / REST services or others.</p> <p>A typical use case is to provide a REST interface for third-party systems to connect them to OGS, another is to implement backend logic for a single page application web page frontend running inside OGS (see also OGS Webbrowser LUA interface).</p> <p>The web server LUA api works by registering LUA callback functions for specific URL prefixes, which are then called by the web server, whenever the given URL is requested from a web client.</p>"},{"location":"v3/lua/webserver/#prerequisites","title":"Prerequisites","text":"<p>To use the LUA web server API, the web server must be enabled through <code>station.ini</code> (in the <code>[WebServer]</code> section) and the Microsoft <code>http.sys</code> web server must be configured accordingly (a URL reservation must be activated through the <code>netsh http add urlacl ...</code> command).</p> <p>By default the, installer registers a web endpoint at http://localhost:59990, so the endpoint is only accessible from the local machine and only for a locally logged on user.</p> <p>To access the web server from the outside, make sure to change the listen address in the <code>station.ini</code> file, the URL reservation through <code>netsh http ...</code> and check the firewall settings. </p>"},{"location":"v3/lua/webserver/#global-webserver-table","title":"Global Webserver table","text":"<p>OGS exposes the web server through the global <code>Webserver</code> object. The <code>Webserver</code> object implements the following functions:</p> <ul> <li>RegUrl: Register a LUA callback function to be called when a specific URL prefix is requested from the web server.</li> </ul>"},{"location":"v3/lua/webserver/#regurl","title":"RegUrl","text":"<p>The <code>Webserver.RegUrl</code> function registers or unregisters a LUA function to be called whenever the web server receives a request to the given URL prefix.</p> <pre><code>fn, err = Webserver.RegUrl(prefix, callbackfn)\n</code></pre>"},{"location":"v3/lua/webserver/#parameters","title":"Parameters","text":"<ul> <li>prefix [string]: Path prefix to match against when checking the request URL. Note that this only checks for the path part of the URL (e.g. '/home'). </li> <li> <p>callbackfn [function]: LUA function to be called when a web request matches the prefix. The callback function has the following signature:</p> <pre><code>table = callbackfn(reqpath, reqparams, verb, body)\n</code></pre> <p>Where reqpath [string] is the full request path, (e.g. '/api/items'), reqparams [string] the request parameters (e.g. '?max=10&amp;class=5'), verb [integer] the request type (GET, PUT, POST, DELETE) and body [string] the body (binaty) string value (only for POST and PUT).</p> <p>The callback function should return a response table with the required parameters to build the http response (optional body).</p> <p>[Datails tbd.]</p> </li> </ul>"},{"location":"v3/lua/webserver/#return-values","title":"Return values","text":"<p>If the function was executed successfully, the callbackfn is returned as the first return value. Else nil is returned and the second return value has an error message string (wrong parameters or unknown instance).</p>"},{"location":"v3/lua/webserver/#sample-code","title":"Sample code","text":"<pre><code>local function handlerfn(reqpath, reqparams, verb, body)\n    -- process the request, return the response object (or nil\n    -- if this request is not handled) \n    return nil\nend\n-- Register a LUA function to be called whenever a web request to /api/lua\n-- is made\nBrowser.RegMsgHandler('/api/lua', handlerfn)\n</code></pre>"}]}