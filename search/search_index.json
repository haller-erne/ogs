{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OGS - Operator guidance system","text":""},{"location":"#scope","title":"Scope","text":"<p>This documentation provides low-level infomation about the OGS software.  The main purpose is to document the API interfaces (mostly LUA scripting), the available (tool)drivers and show how everything fits together.  This allows advanced users and implementors to unlock the full potential  of OGS by modifying and extending the software.</p> <p>NOTE: This documentation is valid for OGS V3. </p>"},{"location":"#overview","title":"Overview","text":"<p>The documentation currently has the following information:</p> <ul> <li>Tool driver and tool configuration information (see Tool configuration)</li> <li>LUA scripting (see LUA scripting)</li> <li>LUA helper libraries (see LUA libraries)</li> </ul>"},{"location":"appnotes/databanking/","title":"Databanking","text":"<p>Databanking is the general term used by OGS for tracking the parts assembly state across multiple stations. It is actually a set of LUA interfaces in OGS, that facilitate two main functions:</p> <ol> <li>When starting a workflow, read the part/job state </li> <li>When finishing a workflow, write the part/job state</li> </ol> <p>Reading and writing the part/job state can be implemented in LUA. Therefore almost any backed system can be used to access and store the parts current build state.</p> <p>Typical use cases are:</p> <ul> <li>Rework stations (usually having the workflows of multiple stations combined into a single, large workflow).</li> <li>EOL-Checks (end of line checks): Can be used to selectively check single tasks from the assembly stations and visualize these to the operator and add additional (plausibility) checks.</li> </ul> <p>A default implementation using a Microsoft SQL server backend is available and described here.</p>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#default-sql-server-implementation","title":"Default SQL Server implementation","text":"","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#overview","title":"Overview","text":"<p>The SQL server default databanking implementation identifies and stores data by combining then following properties and using it as a key for data retrieval:</p> <ul> <li>Part serial number</li> <li>Job name</li> <li>Task name</li> </ul> Sample rework scenario <p>Info</p> <ul> <li>All data is retrieved by using the key <code>[part serial number]:[Job name]:[Task name]</code>, so the rework station shows the exact part/task status of the previous operations</li> <li>The rework station does not need to have all jobs/tasks defined identically to the original stations (e.g. S1 Job 1 is not defined in the example rework config shown above). Setup just what you need!</li> </ul>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#example","title":"Example","text":"<p>Say <code>station 1</code> processes the part with the serial <code>123456</code> as follows:</p> Jobs Tasks Result S1 Job 1 Task 1.1 OK S1 Job 2 Task 2.1 OK Task 2.1 NOK S1 Job 3 Task 3.1 not completed <p>Say the rework station <code>station 5</code> is configured to rework all jobs as follows:</p> Jobs Tasks S1 Job 2 Task 2.1 Task 2.1 S1 Job 3 Task 3.1 S2 Job 1 Task 4.1 S3 Job 1 Task 5.1 S4 Job 1 Task 6.1 <p>If the part with the serial <code>123456</code> is scanned in <code>station 5</code> (assume due to being NOK in <code>station 1</code> it is directly routed to the rework station <code>station 5</code>), it now shows up as follows in the OGS process screen (current part status was loaded from the databanking SQL server):</p> Jobs Tasks Result S1 Job 2 Task 2.1 OK Task 2.1 NOK S1 Job 3 Task 3.1 not completed S2 Job 1 Task 4.1 not completed S3 Job 1 Task 5.1 not completed S4 Job 1 Task 6.1 not completed","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#server-requirements","title":"Server requirements","text":"<p>A Microsoft SQL server database must be available and accessible from each OGS station using databanking. As OGS accesses the data every time a workflow is started and completed, a reliable and fast network connection to the database server is very important.</p> <p>Supported SQL server versions are: 2019, 2022.</p>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#client-requirements","title":"Client Requirements","text":"<p>Databanking is fully supported with OGS &gt;= V3.0.</p> <p>Additional software components required:</p> <ul> <li>SQL Server native client 11 (SNAC/SQLNCLI) or SQL Server OLE DB driver (MSOLEDBSQL). NOTE: On an x64 operating system, the x64 versions od the database drivers must be used! </li> </ul>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#installation","title":"Installation","text":"<p>To install follow the steps outlined in the next sections. All files mentioned are available from the public OGS GitHub repository.</p>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#sql-server-schema","title":"SQL Server Schema","text":"<p>Use the OGS_Databanking.dacpac file to install the database schema required by the default databanking implementation. See Microsofts documentation on how to import a dacpac file for more information.</p>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#integrate-databanking-into-ogs-project","title":"Integrate databanking into OGS Project","text":"<p>To integrate databanking into your OGS project, the following changes to the project are needed:</p> <ol> <li>Add the databanking.lua file to your project by adding it into the <code>requires</code> table in your projects <code>config.lua</code> file.</li> <li> <p>Modify your <code>station.ini</code> file to add the database connection information in the <code>[DATABANKING]</code> section to the <code>ConnectionString=</code> parameter. Here is a sample (using SQL server native client, see Connection strings below for more info):</p> <pre><code>[DATABANKING]\nConnectionString=Provider=SQLNCLI11.1;User ID=&lt;my-user&gt;;Password=&lt;my-pass&gt;;Initial Catalog=&lt;my-db&gt;;Data Source=&lt;my-server&gt;\\&lt;my-instance&gt;[,server-port]\n</code></pre> </li> </ol> <p>Info</p> <p>To use an encrypted database connection string, see database connection strings below.</p>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#database-connection-strings","title":"Database connection strings","text":"<p>The databanking setup in this sample uses Microsoft ADO to connect to the database. It therefore is not limited to Microsoft SQL server, but works with all databases providing ODBC or OleDB database drivers.</p> <p>To prevent information leakage, you can also use encrypted database connection strings. This works by encrypting the plaintext connection string with Microsofts data protection API using the machine key of the current system. As this ties the encrypted string to the physical machine, copies of the configureation file cannot be decrypted on another machine. See sample powershell command for encryption on how to encrypt a plaintext string for use with OGS.</p> <p>For Microsoft SQL server, there are multiple options for connecting to the database, supported are the (old) SQL server native client and the current SQL server OleDB driver. These are described in more detail in the following section.</p> <p>Info</p> <p>To workaround missing or invalid server certificates, add <code>Encrypt=false;</code> and/or <code>TrustServerCertificate=false;</code> to the connection string.</p>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#sql-server-oledb-driver-msoledbsql","title":"SQL Server OleDB driver (MSOLEDBSQL)","text":"<p>Here is a sample connection string using the SQL server native client 11:</p> <pre><code>[DATABANKING]\nConnectionString=Provider=MSOLEDBSQL;Data Source=&lt;my-server&gt;\\&lt;my-instance&gt;[,server-port];Initial Catalog=&lt;my-db&gt;;User ID=&lt;my-user&gt;;Password=&lt;my-pass&gt;;\n</code></pre> <p>A quick reference to the parameters can be found at connectionstrings.com or in the official Microsoft documentation.</p>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#sql-server-native-client-snacsqlncli","title":"SQL Server native client (SNAC/SQLNCLI)","text":"<p>Here is a sample connection string using the SQL server native client 11:</p> <pre><code>[DATABANKING]\nConnectionString=Provider=SQLNCLI11.1;Data Source=&lt;my-server&gt;\\&lt;my-instance&gt;[,server-port];Initial Catalog=&lt;my-db&gt;;User ID=&lt;my-user&gt;;Password=&lt;my-pass&gt;;\n</code></pre> <p>A quick reference to the parameters can be found at connectionstrings.com or in the official Microsoft documentation.</p>","tags":["appnote","enterprise"]},{"location":"appnotes/databanking/#custom-implementations","title":"Custom implementations","text":"<p>TODO: describe the LUA functions used for databanking.</p>","tags":["appnote","enterprise"]},{"location":"appnotes/debugging/","title":"Debugging LUA scripts","text":"<p>OGS ships with a debugging helper script (<code>&lt;instdir&gt;/lualib/libdebug</code>), which is intended to be used with Visual Studio Code and Tom Blinds / lsmoths Second local LUA debuger.</p>","tags":["API"]},{"location":"appnotes/debugging/#debugging-with-vscode","title":"Debugging with VSCode","text":"<p>To use the LUA debugger, the following steps are required:</p> <ol> <li>Install  Visual Studio Code and Tom Blinds / lsmoths Second local LUA debuger extension (search for <code>local lua debugger</code> in Visual Studio Code extensions or install from the link)</li> <li>Add a debugging configuration (see below for a sample debugging configuration)</li> <li>Load the debugger from one of the LUA scripts executed by OGS (requires adding one line, see below for a sample).</li> </ol> <p>To actually start debugging, open your OGS project folder (something like <code>c:\\OGS projects\\sample configuration</code>), create the debugging configuration there and hit <code>F5</code> to start debugging.</p> <p>Info</p> <p>Currently Tom Blinds / lsmoths Second local LUA debuger does not directly support changing breakpoints while the code is running. Either make sure to set some breakpoints before you start the application therefore or cyclically call <code>lldebugger.pullBreakpoints()</code> from your application code (see pullBreakpointsSupport)</p>","tags":["API"]},{"location":"appnotes/debugging/#sample-vscode-debugging-configuration","title":"Sample VSCode debugging configuration","text":"<p>Here is a sample debugging (launch) configuration for VSCode (<code>./vscode/launch.json</code>) - replace <code>&lt;instdir&gt;</code> with the full path where OGS is installed (typically <code>C:/Program Files (x86)/Bosch Rexroth AG/OGS/V3.0</code>)</p> .vscode/launch.json<pre><code>    {\n        \"version\": \"0.2.0\",\n        \"configurations\": [\n            {\n                \"name\": \"OGS (local lua debugger)\",\n                \"type\": \"lua-local\",\n                \"request\": \"launch\",\n                \"program\": {\n                    \"command\": \"&lt;instdir&gt;/monitor.exe\",\n                    \"communication\": \"stdio\"\n                },\n                \"args\": [\n                ],\n                \"scriptRoots\": [\n                    \"&lt;instdir&gt;\",\n                    \"&lt;instdir&gt;/lualibs\",\n                ],\n                \"stopOnEntry\": true,\n                \"pullBreakpointsSupport\": true,\n                \"cwd\": \"&lt;instdir&gt;\",\n                \"verbose\": false,\n                \"integratedTerminal\": true\n            }\n        ]\n    }\n</code></pre>","tags":["API"]},{"location":"appnotes/debugging/#start-the-debugger-backend-from-your-lua-script","title":"Start the debugger backend from your LUA script","text":"<p>To make the debugger work, it is required to run the debugger backend (VSCode only provides the \"frontend\" GUI) from your LUA code. </p> <p>To do so, add the following line to one of the LUA files loaded by OGS:</p> <pre><code>    require('lua-local-debugger')\n</code></pre> <p>Best is to add it into <code>&lt;yourproject&gt;/config.lua</code> somewhere at the top.</p> <p>Info</p> <p>When starting monitor.exe through VSCode, it will automatically break at the end of <code>lua-local-debugger.lua</code> (if the launch.json settings include \"stopOnEntry\": true). You can now set breakpoints or step out into the code where you added the require line.</p> <p>For more details, see https://github.com/tomblind/local-lua-debugger-vscode (lua local debugger) or https://github.com/tarantool/tarantool-lua-debugger-vscode (tarantool lua debugger).</p>","tags":["API"]},{"location":"appnotes/debugging/#known-issues-and-workarounds","title":"Known issues and workarounds","text":"<p>Although the debugger is easy to install and configure, it has some known issues:</p> <ul> <li>Sometimes it is needed to clear the vscode workspace userdata at   %appdata%\\Code\\User\\workspaceStorage (see https://github.com/tomblind/local-lua-debugger-vscode/issues/57)</li> <li>A working LUA repl seems is not available, even if a console is actually avaliable - see https://github.com/tomblind/local-lua-debugger-vscode/issues/81 on how to enable it.</li> </ul>","tags":["API"]},{"location":"appnotes/debugging/#repl","title":"REPL","text":"<p>An interactive REPL is available when debugging with VSCode, see Known issues and workarounds above. </p> <p>An alternative is to use vclua (see also vclua on github and vclua form designer) and build your own. There is a simple sample available for use with OGS (debug-repl-vcl.lua). To use it with OGS, include <code>debug-repl-vcl</code> in the <code>requires</code> list in <code>config.lua</code>. </p> <p>This will then show an additional top level window with a textbox and an edit control. You can enter commands into the edit control and execute them by hitting the enter button.</p> <p>Here is a sample screenshot:</p> <p></p>","tags":["API"]},{"location":"appnotes/station_io/","title":"Station IO","text":"","tags":["appnote"]},{"location":"appnotes/station_io/#overview","title":"Overview","text":"<p>Many times, a real world installation of OGS needs to interact with external sensors and actuators. Typical samples are external push buttons (to acknowledge an operation) connected to a remote I/O module or positioning sensors connected over EtherNet/IP.</p> <p>To simplify access to external IO, OGS provides two generic LUA modules to interact with Modbus/TCP and EtherNet/IP based remote IO devices.</p> <p>These modules provide the following:</p> <ul> <li>Configuration of the devices (like IP address and register scanlist) in <code>station.ini</code></li> <li>Cyclic data exchange in the background (not blocking LUA processing)</li> <li>A LUA interface to add application specific code for mapping input/output data and connecting the physical IOs to a logical OGS function </li> </ul> <p>Currently the following modules are available (see below for more details on using them):</p> <ul> <li><code>station_io_enip.lua</code>: Handle Ethernet/IP remote IO devices using a class 1 (implicit) connection. IP addresses are configurable through station.ini. A set of 'known' devices is included, but others can be added (by specifying the CIP forward open parameters).</li> <li><code>station_io_modbus.lua</code>: Handle Modbus/TCP remote I/O devices. IP addresses and scan list (registers to be scanned cyclically) are configurable through station.ini.</li> </ul> <p>Info</p> <p>Note, that you can also use the OpenProtocol custom IO signals for IO. This is not covered here, see the OpenProtocol tools section for more information.</p>","tags":["appnote"]},{"location":"appnotes/station_io/#usage","title":"Usage","text":"<p>The recommended way to use the station IO modules is to create a station specific <code>station_io.lua</code> file and add this to the <code>config.lua</code> requires list.</p>","tags":["appnote"]},{"location":"appnotes/station_io/#station_io_enip","title":"station_io_enip","text":"","tags":["appnote"]},{"location":"appnotes/station_io/#station_io_modbus","title":"station_io_modbus","text":"<ol> <li>When starting a workflow, read the part/job state </li> <li>When finishing a workflow, write the part/job state</li> </ol> <p>Reading and writing the part/job state can be implemented in LUA. Therefore almost any backed system can be used to access and store the parts current build state.</p> <p>Typical use cases are:</p> <ul> <li>Rework stations (usually having the workflows of multiple stations combined into a single, large workflow).</li> <li>EOL-Checks (end of line checks): Can be used to selectively check single tasks from the assembly stations and visualize these to the operator and add additional (plausibility) checks.</li> </ul> <p>A default implementation using a Microsoft SQL server backend is available and described here.</p>","tags":["appnote"]},{"location":"appnotes/station_io/#default-sql-server-implementation","title":"Default SQL Server implementation","text":"","tags":["appnote"]},{"location":"appnotes/station_io/#overview_1","title":"Overview","text":"<p>The SQL server default databanking implementation identifies and stores data by combining then following properties and using it as a key for data retrieval:</p> <ul> <li>Part serial number</li> <li>Job name</li> <li>Task name</li> </ul> Sample rework scenario <p>Info</p> <ul> <li>All data is retrieved by using the key <code>[part serial number]:[Job name]:[Task name]</code>, so the rework station shows the exact part/task status of the previous operations</li> <li>The rework station does not need to have all jobs/tasks defined identically to the original stations (e.g. S1 Job 1 is not defined in the example rework config shown above). Setup just what you need!</li> </ul>","tags":["appnote"]},{"location":"appnotes/station_io/#example","title":"Example","text":"<p>Say <code>station 1</code> processes the part with the serial <code>123456</code> as follows:</p> Jobs Tasks Result S1 Job 1 Task 1.1 OK S1 Job 2 Task 2.1 OK Task 2.1 NOK S1 Job 3 Task 3.1 not completed <p>Say the rework station <code>station 5</code> is configured to rework all jobs as follows:</p> Jobs Tasks S1 Job 2 Task 2.1 Task 2.1 S1 Job 3 Task 3.1 S2 Job 1 Task 4.1 S3 Job 1 Task 5.1 S4 Job 1 Task 6.1 <p>If the part with the serial <code>123456</code> is scanned in <code>station 5</code> (assume due to being NOK in <code>station 1</code> it is directly routed to the rework station <code>station 5</code>), it now shows up as follows in the OGS process screen (current part status was loaded from the databanking SQL server):</p> Jobs Tasks Result S1 Job 2 Task 2.1 OK Task 2.1 NOK S1 Job 3 Task 3.1 not completed S2 Job 1 Task 4.1 not completed S3 Job 1 Task 5.1 not completed S4 Job 1 Task 6.1 not completed","tags":["appnote"]},{"location":"appnotes/station_io/#server-requirements","title":"Server requirements","text":"<p>A Microsoft SQL server database must be available and accessible from each OGS station using databanking. As OGS accesses the data every time a workflow is started and completed, a reliable and fast network connection to the database server is very important.</p> <p>Supported SQL server versions are: 2019, 2022.</p>","tags":["appnote"]},{"location":"appnotes/station_io/#client-requirements","title":"Client Requirements","text":"<p>Databanking is fully supported with OGS &gt;= V3.0.</p> <p>Additional software components required:</p> <ul> <li>SQL Server native client 11 (SNAC/SQLNCLI) or SQL Server OLE DB driver (MSOLEDBSQL). NOTE: On an x64 operating system, the x64 versions od the database drivers must be used! </li> </ul>","tags":["appnote"]},{"location":"appnotes/station_io/#installation","title":"Installation","text":"<p>To install follow the steps outlined in the next sections. All files mentioned are available from the public OGS GitHub repository.</p>","tags":["appnote"]},{"location":"appnotes/station_io/#sql-server-schema","title":"SQL Server Schema","text":"<p>Use the OGS_Databanking.dacpac file to install the database schema required by the default databanking implementation. See Microsofts documentation on how to import a dacpac file for more information.</p>","tags":["appnote"]},{"location":"appnotes/station_io/#integrate-databanking-into-ogs-project","title":"Integrate databanking into OGS Project","text":"<p>To integrate databanking into your OGS project, the following changes to the project are needed:</p> <ol> <li>Add the databanking.lua file to your project by adding it into the <code>requires</code> table in your projects <code>config.lua</code> file.</li> <li> <p>Modify your <code>station.ini</code> file to add the database connection information in the <code>[DATABANKING]</code> section to the <code>ConnectionString=</code> parameter. Here is a sample (using SQL server native client, see Connection strings below for more info):</p> <pre><code>[DATABANKING]\nConnectionString=Provider=SQLNCLI11.1;User ID=&lt;my-user&gt;;Password=&lt;my-pass&gt;;Initial Catalog=&lt;my-db&gt;;Data Source=&lt;my-server&gt;\\&lt;my-instance&gt;[,server-port]\n</code></pre> </li> </ol> <p>Info</p> <p>To use an encrypted database connection string, see database connection strings below.</p>","tags":["appnote"]},{"location":"appnotes/station_io/#database-connection-strings","title":"Database connection strings","text":"<p>The databanking setup in this sample uses Microsoft ADO to connect to the database. It therefore is not limited to Microsoft SQL server, but works with all databases providing ODBC or OleDB database drivers.</p> <p>To prevent information leakage, you can also use encrypted database connection strings. This works by encrypting the plaintext connection string with Microsofts data protection API using the machine key of the current system. As this ties the encrypted string to the physical machine, copies of the configureation file cannot be decrypted on another machine. See sample powershell command for encryption on how to encrypt a plaintext string for use with OGS.</p> <p>For Microsoft SQL server, there are multiple options for connecting to the database, supported are the (old) SQL server native client and the current SQL server OleDB driver. These are described in more detail in the following section.</p> <p>Info</p> <p>To workaround missing or invalid server certificates, add <code>Encrypt=false;</code> and/or <code>TrustServerCertificate=false;</code> to the connection string.</p>","tags":["appnote"]},{"location":"appnotes/station_io/#sql-server-oledb-driver-msoledbsql","title":"SQL Server OleDB driver (MSOLEDBSQL)","text":"<p>Here is a sample connection string using the SQL server native client 11:</p> <pre><code>[DATABANKING]\nConnectionString=Provider=MSOLEDBSQL;Data Source=&lt;my-server&gt;\\&lt;my-instance&gt;[,server-port];Initial Catalog=&lt;my-db&gt;;User ID=&lt;my-user&gt;;Password=&lt;my-pass&gt;;\n</code></pre> <p>A quick reference to the parameters can be found at connectionstrings.com or in the official Microsoft documentation.</p>","tags":["appnote"]},{"location":"appnotes/station_io/#sql-server-native-client-snacsqlncli","title":"SQL Server native client (SNAC/SQLNCLI)","text":"<p>Here is a sample connection string using the SQL server native client 11:</p> <pre><code>[DATABANKING]\nConnectionString=Provider=SQLNCLI11.1;Data Source=&lt;my-server&gt;\\&lt;my-instance&gt;[,server-port];Initial Catalog=&lt;my-db&gt;;User ID=&lt;my-user&gt;;Password=&lt;my-pass&gt;;\n</code></pre> <p>A quick reference to the parameters can be found at connectionstrings.com or in the official Microsoft documentation.</p>","tags":["appnote"]},{"location":"appnotes/station_io/#custom-implementations","title":"Custom implementations","text":"<p>TODO: describe the LUA functions used for databanking.</p>","tags":["appnote"]},{"location":"libs/_template_/","title":"Ability","text":"<p>Abilities are CoreObjects that can be added to Players and guide the Player's animation in sync with the Ability's state machine. Spawn an Ability with <code>World.SpawnAsset()</code> or add an Ability as a child of an Equipment/Weapon to have it be assigned to the Player automatically when that item is equipped.</p> <p>Abilities can be activated by association with an Action Binding. Their internal state machine flows through the phases: Ready, Cast, Execute, Recovery, and Cooldown. An Ability begins in the Ready state and transitions to Cast when its Binding (for example Left mouse click) is activated by the owning player. It then automatically flows from Cast to Execute, then Recovery and finally Cooldown. At each of these state transitions it fires a corresponding event.</p> <p>Only one ability can be active at a time. By default, activating an ability will interrupt the currently active ability. The <code>canBePrevented</code> and <code>preventsOtherAbilities</code> properties can be used to customize interruption rules for competing abilities.</p> <p>If an ability is interrupted during the Cast phase, it will immediately reset to the Ready state. If an ability is interrupted during the Execute or Recovery phase, the ability will immediately transition to the Cooldown phase.</p>","tags":["API"]},{"location":"libs/_template_/#properties","title":"Properties","text":"Property Name Return Type Description Tags <code>isEnabled</code> <code>boolean</code> Turns an Ability on/off. It stays on the Player but is interrupted if <code>isEnabled</code> is set to <code>false</code> during an active Ability. True by default. Read-Write <code>canActivateWhileDead</code> <code>boolean</code> Indicates if the Ability can be used while the owning Player is dead. False by default. Read-Only <code>name</code> <code>string</code> The name of the Ability. Read-Only <code>actionBinding</code> <code>string</code> This property is deprecated. Please use <code>actionName</code> instead, but note that <code>actionBinding</code> and <code>actionName</code> use different values.  Which action binding will cause the Ability to activate. Possible values of the bindings are listed on the Ability binding page. Read-Only, Deprecated <code>actionName</code> <code>string</code> Which binding set action name will cause the Ability to activate. See Binding Sets reference. Read-Only <code>owner</code> <code>Player</code> Assigning an owner applies the Ability to that Player. Read-Write <code>castPhaseSettings</code> <code>AbilityPhaseSettings</code> Config data for the Cast phase (see below). Read-Only <code>executePhaseSettings</code> <code>AbilityPhaseSettings</code> Config data for the Execute phase. Read-Only <code>recoveryPhaseSettings</code> <code>AbilityPhaseSettings</code> Config data for the Recovery phase. Read-Only <code>cooldownPhaseSettings</code> <code>AbilityPhaseSettings</code> Config data for the Cooldown phase. Read-Only <code>animation</code> <code>string</code> Name of the animation the Player will play when the Ability is activated. Possible values: See Ability Animation for strings and other info. Read-Only <code>canBePrevented</code> <code>boolean</code> Used in conjunction with the phase property <code>preventsOtherAbilities</code> so multiple abilities on the same Player can block each other during specific phases. True by default. Read-Only","tags":["API"]},{"location":"libs/_template_/#functions","title":"Functions","text":"Function Name Return Type Description Tags <code>Activate()</code> <code>None</code> Activates an Ability as if the button had been pressed. None <code>Interrupt()</code> <code>None</code> Changes an Ability from Cast phase to Ready phase. If the Ability is in either Execute or Recovery phases it instead goes to Cooldown phase. None <code>AdvancePhase()</code> <code>None</code> Advances a currently active Ability from its current phase to the next phase. For example, an ability in the Cast phase will begin the Execute phase, an ability on cooldown will become ready, etc. None <code>GetCurrentPhase()</code> <code>AbilityPhase</code> The current AbilityPhase for this Ability. These are returned as one of: AbilityPhase.READY, AbilityPhase.CAST, AbilityPhase.EXECUTE, AbilityPhase.RECOVERY and AbilityPhase.COOLDOWN. None <code>GetCurrentPhaseSettings()</code> <code>AbilityPhaseSettings</code> Returns the settings for the current phase of this Ability. Returns <code>nil</code> if the current phase is <code>AbilityPhase.READY</code>. None <code>GetPhaseTimeRemaining()</code> <code>number</code> Seconds left in the current phase. None <code>GetTargetData()</code> <code>AbilityTarget</code> Returns information about what the Player has targeted this phase. None <code>SetTargetData(AbilityTarget)</code> <code>None</code> Updates information about what the Player has targeted this phase. This can affect the execution of the Ability. None","tags":["API"]},{"location":"libs/_template_/#events","title":"Events","text":"Event Name Return Type Description Tags <code>readyEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability becomes ready. In this phase it is possible to activate it again. None <code>castEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability enters the Cast phase. None <code>executeEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability enters Execute phase. None <code>recoveryEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability enters Recovery. None <code>cooldownEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability enters Cooldown. None <code>interruptedEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability is interrupted. None <code>tickEvent</code> <code>Event</code>&lt;<code>Ability</code> ability, <code>number</code> deltaTime&gt; Fired every tick while the Ability is active (isEnabled = true and phase is not ready). None","tags":["API"]},{"location":"libs/_template_/#examples","title":"Examples","text":"<p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#castevent","title":"<code>castEvent</code>","text":"<p>The Cast phase begins as soon as an ability is activated. By checking if the player casting the ability <code>isGrounded</code> we can create an effect that propels you upwards, but it doesn't work if you are already jumping or flying. We detect this is the <code>castEvent</code>, which is early enough for an <code>Interrupt()</code> to reset the ability.</p> <pre><code>--Server script\nlocal ability = script.parent\n\nfunction OnCast(ability)\n    if ability.owner.isGrounded then\n        ability.owner:SetVelocity(Vector3.UP * 2000)\n    else\n        ability:Interrupt()\n    end\nend\n\nability.castEvent:Connect(OnCast)\n</code></pre> <p>See also: CoreObject.parent | Ability.owner | Player.isGrounded | Vector3.UP | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#cooldownevent","title":"<code>cooldownEvent</code>","text":"<p>In this example, a fighting game has an \"invincible\" mechanic where player attacks are not interrupted while they have this effect. Some powerful attacks make the player invincible during the entire active cycle of the ability. The effect is gained at the beginning of the cast phase and is removed at the end of the recovery phase, before the cooldown begins. The resource system is used in keeping track of the invincibility effect.</p> <pre><code>--Server script\nlocal ability = script.parent\n\nfunction OnCast(ability)\n    ability.owner:AddResource(\"invincible\", 1)\nend\n\nfunction OnCooldown(ability)\n    ability.owner:RemoveResource(\"invincible\", 1)\nend\n\nability.castEvent:Connect(OnCast)\nability.cooldownEvent:Connect(OnCooldown)\n</code></pre> <p>See also: CoreObject.parent | Player.owner | Ability.castEvent | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#executeevent","title":"<code>executeEvent</code>","text":"<p>Weapons implement lots of built-in gameplay that doesn't require any scripting, such as attack and reload abilities. However, they can be augmented with additional mechanics. In this example, a special sound effect is played when a weapon shoots while low on ammunition. The script expects to be a child of a weapon's \"Shoot\" ability.</p> <pre><code>--Server script\nlocal ability = script.parent\nlocal weapon = script:FindAncestorByType('Weapon')\nlocal lowAmmoSound = script:GetCustomProperty(\"LowAmmoSound\")\n\nlocal LOW_AMMO_PERCENTAGE = 0.2\n\nfunction OnExecute(ability)\n    if weapon.currentAmmo / weapon.maxAmmo &lt;= LOW_AMMO_PERCENTAGE then\n        World.SpawnAsset(lowAmmoSound, {position = weapon:GetWorldPosition()})\n    end\nend\n\nability.executeEvent:Connect(OnExecute)\n</code></pre> <p>See also: CoreObject.parent | Weapon.currentAmmo | World.SpawnAsset | Ability.executeEvent | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#interruptedevent","title":"<code>interruptedEvent</code>","text":"<p>The <code>interruptedEvent</code> fires when an ability is going through it's activation process and <code>Interrupt()</code> is called on it, or if it becomes disabled. In this example, interruption is a key part of the game design, so a visual effect is spawned at the player's position to help communicate the interaction between players.</p> <pre><code>--Server script\nlocal ability = script.parent\nlocal interruptedVfx = script:GetCustomProperty(\"InterruptedVfx\")\n\nfunction OnInterrupted(ability)\n    if Object.IsValid(ability.owner) then\n        World.SpawnAsset(interruptedVfx, {position = ability.owner:GetWorldPosition()})\n    end\nend\n\nability.interruptedEvent:Connect(OnInterrupted)\n</code></pre> <p>See also: CoreObject.parent | Object.IsValid | Ability.owner | World.SpawnAsset | Player.GetWorldPosition | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#readyevent","title":"<code>readyEvent</code>","text":"<p>The Ready phase begins when an ability comes off cooldown and is \"ready\" to be used again. In this example, we create an invisibility effect that takes advantage of the <code>readyEvent</code>, leveraging the cooldown duration of the ability as a clock to determine when to make the player visible again.</p> <pre><code>-- Server script\nlocal ability = script.parent\n\nfunction OnExecute(ability)\n    -- Hide the player\n    ability.owner:SetVisibility(false)\nend\n\nfunction OnReady(ability)\n    -- Show the player\n    ability.owner:SetVisibility(true)\nend\n\nability.readyEvent:Connect(OnReady)\nability.executeEvent:Connect(OnExecute)\n</code></pre> <p>See also: CoreObject.parent | Ability.owner | Player.SetVisibility | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#recoveryevent","title":"<code>recoveryEvent</code>","text":"<p>The <code>recoveryEvent</code> marks the end of an ability's Execute phase and the beginning of its Recovery phase. In this example, a melee punch ability has a trigger that causes damage to enemies who overlap it. For it to work the trigger is only enabled for a brief moment, during the Execute phase.</p> <pre><code>--Server script\nlocal ability = script.parent\nlocal trigger = script:GetCustomProperty(\"ImpactTrigger\"):WaitForObject()\ntrigger.collision = Collision.FORCE_OFF\n\nlocal DAMAGE_AMOUNT = 10\n\nfunction OnExecute(ability)\n    trigger.collision = Collision.FORCE_ON\nend\n\nfunction OnRecovery(ability)\n    trigger.collision = Collision.FORCE_OFF\nend\n\nability.executeEvent:Connect(OnExecute)\nability.recoveryEvent:Connect(OnRecovery)\n\nfunction OnBeginOverlap(trigger, other)\n    -- Only damage enemy players\n    if other:IsA(\"Player\") and other.team ~= ability.owner.team then\n        other:ApplyDamage(Damage.New(DAMAGE_AMOUNT))\n    end\nend\n\ntrigger.beginOverlapEvent:Connect(OnBeginOverlap)\n</code></pre> <p>See also: CoreObject.parent | CoreObjectReference.WaitForObject | Ability.executeEvent | Event.Connect | other.IsA | Player.team | Damage.New | Trigger.beginOverlapEvent</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#tickevent","title":"<code>tickEvent</code>","text":"<p>Abilities fire the <code>tickEvent</code> while they are active or on cooldown (not on Ready state). In this example, a piece of equipment carries several abilities, but we want to do a common update logic on all of them. Note: <code>Ability.tickEvent</code> works somewhat differently from a <code>Tick()</code> function - <code>tickEvent</code> is an actual event that just happens to fire once per tick. Each invocation of the callback runs on its own task. This means that, unlike <code>Tick()</code>, there is no guarantee that it will wait for the previous <code>tickEvent</code> to finish before starting the next one. This means you can't use things like <code>Task.Wait()</code> to add time between ticks.</p> <pre><code>local equipment = script.parent\nlocal allAbilities = equipment:GetAbilities()\n\nfunction OnTick(ability, deltaTime)\n    print(\"Updating ability \" .. ability.name)\nend\n\nfor _, ability in ipairs(allAbilities) do\n    ability.tickEvent:Connect(OnTick)\nend\n</code></pre> <p>See also: CoreObject.parent | Equipment.GetAbilities | Event.Connect | CoreLua.print</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#activate","title":"<code>Activate</code>","text":"<p>The Ability <code>Activate()</code> function behaves as if the player had pressed the key binding. In order for a server gameplay decision to result in an ability activation, it must be communicated over the network somehow. In this example, a trigger overlap is representative of an arbitrary gameplay decision on the server. A broadcast message is sent to the client, who receives the event and activates the ability.</p> <pre><code>--Server script\nlocal trigger = script.parent\nlocal function OnBeginOverlap(trigger, other)\n    if other:IsA(\"Player\") then\n        Events.BroadcastToPlayer(other, \"SteppedOnObject\")\n    end\nend\n\ntrigger.beginOverlapEvent(OnBeginOverlap)\n\n--[[#description\n    Client context script under the ability:\n]]\nlocal ability = script:FindAncestorByType(\"Ability\")\n\nfunction OnPlayAnimation()\n    if ability.owner and ability.owner == Game.GetLocalPlayer() then\n        ability:Activate()\n    end\nend\n\nEvents.Connect(\"SteppedOnObject\", OnPlayAnimation)\n</code></pre> <p>See also: CoreObject.parent | Trigger.beginOverlapEvent | other.IsA | Events.BroadcastToPlayer | Ability.owner | Game.GetLocalPlayer()</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#advancephase","title":"<code>AdvancePhase</code>","text":"","tags":["API"]},{"location":"libs/_template_/#getcurrentphase","title":"<code>GetCurrentPhase</code>","text":"<p>In this example an ability is on cooldown, but can be set back to <code>Ready</code> by calling <code>AdvancePhase()</code>.</p> <pre><code>function EndAbilityCooldown(ability)\n    if ability:GetCurrentPhase() == AbilityPhase.COOLDOWN then\n        ability:AdvancePhase()\n    end\nend\n</code></pre> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#getcurrentphase_1","title":"<code>GetCurrentPhase</code>","text":"","tags":["API"]},{"location":"libs/_template_/#getphasetimeremaining","title":"<code>GetPhaseTimeRemaining</code>","text":"<p>In this example, while the ability is on cooldown, the percentage completion of the cooldown is calculated. This could be useful, for instance, in displaying user interface.</p> <pre><code>local ability = script:FindAncestorByType(\"Ability\")\n\nfunction Tick()\n    if ability:GetCurrentPhase() == AbilityPhase.COOLDOWN then\n        local duration = ability.cooldownPhaseSettings.duration\n        local remaining = ability:GetPhaseTimeRemaining()\n        local percent = 100 * (1 - remaining / duration)\n\n        print(\"Cooldown remaining: %\" .. string.format(\"%.2f\",percent))\n    end\nend\n</code></pre> <p>See also: CoreObject.FindAncestorByType | Ability.GetCurrentPhase | AbilityPhaseSettings.duration | CoreLua.print</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#gettargetdata","title":"<code>GetTargetData</code>","text":"","tags":["API"]},{"location":"libs/_template_/#settargetdata","title":"<code>SetTargetData</code>","text":"<p>The ability's targeting data gives a lot of information about where and what the player is aiming at. If setup correctly, it can also be modified programmatically. In this example, the Z position of the target is flattened horizontally. Useful, for example, in a top-down shooter. For this to work it should be placed in a client context under the ability. The ability should also have the option \"Is Target Data Update\" turned off for the Execute phase, otherwise any data set programmatically will be overwritten when the phase changes.</p> <pre><code>--Server script\nlocal ability = script:FindAncestorByType(\"Ability\")\n\nfunction OnCast(ability)\n    local abilityTarget = ability:GetTargetData()\n    local pos = abilityTarget:GetHitPosition()\n\n    pos.z = ability.owner:GetWorldPosition().z + 50\n\n    abilityTarget:SetHitPosition(pos)\n    ability:SetTargetData(abilityTarget)\nend\n\nability.castEvent:Connect(OnCast)\n</code></pre> <p>See also: CoreObject.FindAncestorByType | AbilityTarget.GetHitPosition | Ability.owner | Player.GetWorldPosition | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#interrupt","title":"<code>Interrupt</code>","text":"<p>Interrupting an ability either sends it back into ready state (if it was still in the Cast phase) or puts it on cooldown. In this example, we have an ability that searches for all enemies in a 10 meter radius and interrupts their abilities.</p> <pre><code>--Server script\nlocal ability = script.parent\nlocal RADIUS = 1000 -- 10 meters\n\nfunction OnExecute(ability)\n    local center = ability.owner:GetWorldPosition()\n    -- Search for enemies\n    local enemies = Game.FindPlayersInCylinder(center, RADIUS, {ignoreTeams = ability.owner.team})\n    for _, enemy in ipairs(enemies) do\n        -- Interrupt all their abilities\n        local enemyAbilities = enemy:GetAbilities()\n        for _,a in ipairs(enemyAbilities) do\n            a:Interrupt()\n        end\n    end\nend\n\nability.executeEvent:Connect(OnExecute)\n</code></pre> <p>See also: CoreObject.parent | Ability.owner | Player.GetWorldPosition | Game.FindPlayersInCylinder | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#actionname","title":"<code>actionName</code>","text":"<p>Even though some API properties are read-only, they are useful is solutions such as user interface. In this example, a client context script searches the local player's list of abilities to find one that matches the action name (input) designated for this UI component. When it's found, the ability's name is written to the UI Text object.</p> <pre><code>--Client script\nlocal ACTION_NAME = script:GetCustomProperty(\"ActionName\")\nlocal NAME_UI = script:GetCustomProperty(\"NameUIText\"):WaitForObject()\n\nfunction GetLocalPlayerAbilityWithActionName()\n    local player = Game.GetLocalPlayer()\n    local abilities = player:GetAbilities()\n\n    for _, ability in pairs(abilities) do\n        if ability.actionName == ACTION_NAME then\n            return ability\n        end\n    end\n\n    return nil\nend\n\nfunction Tick()\n    local ability = GetLocalPlayerAbilityWithActionName()\n    if ability then\n        NAME_UI.text = ability.name\n    end\nend\n</code></pre> <p>See also: CoreObject.name | CoreObjectReference.WaitForObject | Game.GetLocalPlayer | Player.GetAbilities | UIText.text</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#animation","title":"<code>animation</code>","text":"<p>In this example, the <code>ProcessAbilities()</code> function can be called once, such as at the beginning of a round, to take inventory of a player's abilities and classify them based on animation. This example also demonstrates how to disconnect event listeners so that we don't listen for the same event multiple times.</p> <pre><code>--Server script\nfunction OnMelee1HandCast(ability)\n    print(\"One-handed melee attack\")\nend\n\nfunction OnMelee2HandCast(ability)\n    print(\"Two-handed melee attack\")\nend\n\nlocal abilityEventListeners = {}\n\nfunction CleanupListeners(player)\n    -- If we have previously processed this player, cleanup all listeners\n    if abilityEventListeners[player] then\n        for i, eventListener in ipairs(abilityEventListeners[player]) do\n            eventListener:Disconnect()\n        end\n        abilityEventListeners[player] = nil\n    end\nend\n\nfunction ProcessAbilities(player)\n    CleanupListeners(player)\n\n    local allAbilities = player:GetAbilities()\n\n    for _, ability in ipairs(allAbilities) do\n        if string.match(ability.animation, \"melee\") then\n            local eventListener\n            if string.match(ability.animation, \"1h\") then\n                eventListener = ability.castEvent:Connect(OnMelee1HandCast)\n            else\n                eventListener = ability.castEvent:Connect(OnMelee2HandCast)\n            end\n            table.insert(abilityEventListeners[player], eventListener)\n        end\n    end\nend\n\n-- Lets also cleanup when a player leaves the game, as perhaps their ability objects might stay in the game.\nGame.playerLeftEvent:Connect(CleanupListeners)\n</code></pre> <p>See also: EventListener.Disconnect | Player.GetAbilities | Ability.castEvent | Event.Connect | Game.playerLeftEvent | CoreLua.print</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#canactivatewhiledead","title":"<code>canActivateWhileDead</code>","text":"<p>Some games may have abilities that can be used while the player is dead. In this example, we have abilities that can only be activated while dead. If not dead, then it's interrupted.</p> <pre><code>--Server script\nlocal ability = script:FindAncestorByType(\"Ability\")\n\nfunction OnCast(ability)\n    if ability.canActivateWhileDead and not ability.owner.isDead then\n        ability:Interrupt()\n    end\nend\n\nability.castEvent:Connect(OnCast)\n\n--[[#description\n    On the client context, a user interface component that displays ability details is hidden until the player dies:\n]]\nlocal abilityCanvas = script:GetCustomProperty(\"Canvas\")\nlocal ACTION_NAME = script:GetCustomProperty(\"ActionName\")\n\nfunction Tick(deltaTime)\n    local ability = GetLocalPlayerAbilityWithActionName()\n\n    if ability\n    and ability.isEnabled\n    and ability.canActivateWhileDead\n    and ability.owner\n    and ability.owner.isDead then\n\n        abilityCanvas.visibility = Visibility.INHERIT\n    else\n        abilityCanvas.visibility = Visibility.FORCE_OFF\n    end\nend\n\n-- Searches the local player's abilities until one with a matching action name is found\n-- The ACTION_NAME search criteria should be set in the custom property\nfunction GetLocalPlayerAbilityWithActionName()\n    local abilities = Game.GetLocalPlayer():GetAbilities()\n    for _, ability in pairs(abilities) do\n        if ability.actionName == ACTION_NAME then\n            return ability\n        end\n    end\n\n    return nil\nend\n</code></pre> <p>See also: CoreObject.FindAncestorByType | Ability.owner | Player.isDead | Event.Connect | CoreLua.Tick</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#canbeprevented","title":"<code>canBePrevented</code>","text":"<p>In this example, an ability recognizes that it has been interrupted by the activation of another, special ability, that is setup to serve for animation cancelling. The <code>canBePrevented</code> property is usually true in this game, but in this special case it has been configured as false so that it can be activated at any time. The player gains vertical impulse as result of the synergy and hears a small audio cue that helps communicate the mechanic.</p> <pre><code>--Server script\nlocal ability = script.parent\nlocal cancelSound = script:GetCustomProperty(\"CancelSound\")\n\nfunction OnInterrupted(ability)\n    local player = ability.owner\n    if not Object.IsValid(player) then return end\n\n    for _, a in ipairs(player:GetAbilities()) do\n        if a:GetCurrentPhase() ~= AbilityPhase.READY and not a.canBePrevented then\n            player:AddImpulse(Vector3.UP * 1000)\n            World.SpawnAsset(cancelSound, {position = player:GetWorldPosition()})\n            return\n        end\n    end\nend\n\nability.interruptedEvent:Connect(OnInterrupted)\n</code></pre> <p>See also: CoreObject.parent | Ability.owner | Object.IsValid | Player.GetAbilities | Vector3.UP | World.SpawnAsset | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#castphasesettings","title":"<code>castPhaseSettings</code>","text":"","tags":["API"]},{"location":"libs/_template_/#executephasesettings","title":"<code>executePhaseSettings</code>","text":"","tags":["API"]},{"location":"libs/_template_/#recoveryphasesettings","title":"<code>recoveryPhaseSettings</code>","text":"","tags":["API"]},{"location":"libs/_template_/#cooldownphasesettings","title":"<code>cooldownPhaseSettings</code>","text":"<p>In this example, a function in a client context script can be called to show the elapsed times for an ability. The UI Text it controls displays how many seconds are remaining in the current phase, and the color of the text blends from black to white to indicate the percentage of completion. Although the Execute and Recovery phases are actually separate, they are here presented to the player as a single phase.</p> <pre><code>--Client script\nlocal COUNTDOWN_TEXT = script:GetCustomProperty(\"CountdownText\"):WaitForObject()\n\nfunction UpdateForAbility(ability)\n    local currentPhase = ability:GetCurrentPhase()\n\n    local percent = 1\n    local cooldownText = \"Ready\"\n\n    if currentPhase ~= AbilityPhase.READY then\n        local phaseDuration\n        local timeRemaining = ability:GetPhaseTimeRemaining()\n\n        if currentPhase == AbilityPhase.CAST then\n            phaseDuration = ability.castPhaseSettings.duration\n        elseif currentPhase == AbilityPhase.EXECUTE then\n            -- In the case of Execute and Recovery phases, we can show those as a single one\n            local recoveryD = ability.recoveryPhaseSettings.duration\n            phaseDuration = ability.executePhaseSettings.duration + recoveryD\n            timeRemaining = timeRemaining + recoveryD\n        elseif currentPhase == AbilityPhase.RECOVERY then\n            phaseDuration = ability.recoveryPhaseSettings.duration\n        else --currentPhase == AbilityPhase.COOLDOWN\n            phaseDuration = ability.cooldownPhaseSettings.duration\n        end\n\n        if phaseDuration &gt; 0 then\n            percent = 1 - timeRemaining / phaseDuration\n        end\n        cooldownText = string.format(\"%.1f\", timeRemaining)\n    end\n\n    COUNTDOWN_TEXT.text = cooldownText\n\n    local c = Color.Lerp(Color.BLACK, Color.WHITE, percent)\n    COUNTDOWN_TEXT:SetColor(c)\nend\n</code></pre> <p>See also: CoreObject.GetCustomProperty | CoreObjectReference.WaitForObject | Ability.GetCurrentPhase | AbilityPhaseSettings.duration | UIText.text | Color.Lerp</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#isenabled","title":"<code>isEnabled</code>","text":"<p>In this example, an equipment is setup with multiple abilities that all use the same action binding. This script cycles through the abilities, making sure only one is enabled at a time. The <code>owner</code> property is cleared for the previous ability and set for the next one, as part of ensuring the correct one activates when the binding is pressed.</p> <pre><code>--Server script\nlocal equipment = script:FindAncestorByType(\"Equipment\")\nlocal abilities = {}\nlocal abilityIndex = 1\n\nfunction OnAbilityRecovery(ability)\n    if (#abilities &gt; 1) then\n        abilities[abilityIndex].isEnabled = false\n        abilities[abilityIndex].owner = nil\n\n        abilityIndex = abilityIndex + 1\n        if (abilityIndex &gt; #abilities) then\n            abilityIndex = 1\n        end\n\n        abilities[abilityIndex].isEnabled = true\n        abilities[abilityIndex].owner = equipment.owner\n    end\nend\n\nfor _, child in pairs(equipment:FindDescendantsByType(\"Ability\")) do\n    table.insert(abilities, child)\n\n    child.isEnabled = (#abilities == 1)\n\n    child.recoveryEvent:Connect(OnAbilityRecovery)\nend\n</code></pre> <p>See also: CoreObject.FindAncestorByType | Ability.owner | Equipment.owner | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#owner","title":"<code>owner</code>","text":"<p>Usually, abilities are presented as part of an equipment, but that isn't a requirement. In this example, when new players join the game they are assigned an ability through the use of the <code>owner</code> property.</p> <pre><code>--Server script\nlocal abilityTemplate = script:GetCustomProperty(\"AbilityTemplate\")\n\nfunction OnPlayerJoined(player)\n    local ability = World.SpawnAsset(abilityTemplate)\n    ability.owner = player\nend\n\nGame.playerJoinedEvent:Connect(OnPlayerJoined)\n</code></pre> <p>See also: CoreObject.GetCustomProperty | World.SpawnAsset | Player.owner | Game.playerJoinedEvent | Event.Connect</p>","tags":["API"]},{"location":"libs/_template_/#tutorials","title":"Tutorials","text":"<p>Abilities in Core</p>","tags":["API"]},{"location":"libs/lua-dpapi/","title":"LuaDPApi","text":"<p>LuaDPApi provides an interface to the Microsoft Data Protection API. It implements a thin LUA wrapper interface over the <code>CryptProtectData</code> and <code>CryptUnprotectData</code> API calls. </p> <p>The main purpose is to store secrets (like passwords, or API token etc.) in a configuration file (like to OGS <code>station.ini</code>) without exposing the sensitive data to the world (e.g. if storing backups of these configuration files or versioning these files through git). This works by encrypting the secret data and writing the encrypted string into the configuration file. The application reading the configuration file can the decrypt the data and use it.</p> <p>In the background, the Microsoft Data Protection API encrypts/decrypts data by deriving an encryption key based on either the unique machine-id or a user-specific id:</p> <ul> <li>If the scope during the encryption is the machine-id, then all users, who are able to log on to this machine, will be able to decrypt the data. </li> <li>If the scope during the encryption is the user-id, then only the user, who encrypted the data will be able to decrypt later. Changes top the user password are tracked internally, so even after a password change, the user will be able to decrypt. If a users password is reset, then no access to the encrypted data is possible anymore.</li> </ul> <p>Note, that in an ActiveDirectory environment, backup keys are stored on the domain controller - allowing the domain administrator to decrypt, too. </p> <p>In addition to the user/machine-scope, an additional <code>enthropy</code> parameter can be used during encryption. In this case, the <code>enthropy</code>-data is added as part of the encryption key - effectively allowing successful decryption only, if the very same <code>enthropy</code>-data is added during decryption. This is e.g. used by the Edge browser to encrypt website passwords - the <code>entropy</code> data is the website URL, so without knowng the actual URL, no password can be decrypted.</p>","tags":["API"]},{"location":"libs/lua-dpapi/#module","title":"Module","text":"<p>The LuaDPApi module provides global functions to access the Microsoft Data Protection API.</p>","tags":["API"]},{"location":"libs/lua-dpapi/#functions","title":"Functions","text":"Function Name Return Type Description Tags <code>protect(data: string, scope: string = 'machine' entropy: string = nil)</code> <code>data: string</code> or <code>nil, win32error: integer</code> Encrypts the given data (binary string) using the given scope (one of 'maschine' or 'user') and entropy. Returns the encrypted data (as a binary string) or nil and the Win32 API error code. None <code>unprotect(data: string, entropy: string = nil)</code> <code>data: string</code> or <code>nil, win32error: integer</code> Dencrypts the given data (binary string) using the given entropy. Returns the decrypted data (as a binary string) or nil and the Win32 API error code. None <p>Info</p> <p>Note that the LUA functions pass raw data strings to the underlying Microsoft Data Protection API functions. Encoding and decoding text strings (e.g. to read/write the encrypted binary data from/to a configuration file) must be handled by additional code.</p> <p>Tip</p> <p>As encrypted data is binary, for configuration files, it is usually stored as a base64 encoded string. Use the LUA <code>mime</code> library (part of the <code>luasocket</code> library) to encode and decode a base64 string (see below for sample code). Also make sure to use the same text encoding for encryption and decryption (LUA uses UTF8-strings)!</p>","tags":["API"]},{"location":"libs/lua-dpapi/#examples","title":"Examples","text":"","tags":["API"]},{"location":"libs/lua-dpapi/#encrypt-a-string","title":"Encrypt a string","text":"<p>This sample shows how to encrypt a given plaintext string (LUA string, UTF8-encoded) and encode the encrypted data into a base64 string.</p> <pre><code>local dpapi = require('luadpapi')  -- load the DPAPI\nlocal mime = require('mime')       -- load luasocket/mime (base64)\n\n-- Sample plaintext password (or connection string, etc)\nlocal plaintext = 'MySuperSecretPassword' \n\n-- Encrypt the plaintext for the 'machine' scope. All users logged \n-- into the same machine will be able to decrypt the data later.\n-- encrypt (usually done at the commandline through powershell):\nlocal encrypted_data, err = dpapi.protect(plaintext, 'machine') \nif encrypted_data == nil then\n    print(\"ERROR: encrypt failed, err=\", err)\n    os.exit(-1)\nend\n\n-- Do a base64 encode of the encrypted data for storing in *.ini file:\nlocal encrypted_b64 = mime.b64(encrypted_data)     \n\n-- TODO: save to some text file, but for now just print it\nprint(\"encrypted, base64 encoded data: \", encrypted_b64)\n</code></pre>","tags":["API"]},{"location":"libs/lua-dpapi/#decrypt-base64-encoded-data","title":"Decrypt base64-encoded data","text":"<p>This sample shows how to decrypt previously encrypted and base64 encoded data. </p> <pre><code>local dpapi = require('luadpapi')   -- load the DPAPI\nlocal mime = require('mime')        -- load luasocket/mime (base64)\n\n-- Sample plaintext password (or connection string, etc)\n-- !!! Make sure to paste the data generated from the previous sample!\nlocal encrypted_b64 = 'AQAAANCMnd8BFdERjHoAwE/Cl+'...'ylQ=' \n\n-- Convert from base64 to raw data\nlocal encrypted = mime.unb64(encrypted_b64)\n\n-- Decrypt the raw data.\nlocal decrypted_data, err = dpapi.unprotect(encrypted) \nif decrypted_data == nil then\n    print(\"ERROR: decrypt failed, err=\", err)\n    os.exit(-1)\nend\n\n-- TODO: use the decrypted data - assume this is a string and print it:\nprint(\"decrypted data: \", decrypted_data)\n</code></pre>","tags":["API"]},{"location":"libs/lua-dpapi/#encryptdecrypt-using-powershell","title":"Encrypt/decrypt using Powershell","text":"<p>The DPAPI is also implemented in the [Security.Cryptography.ProtectedData] DotNET assembly, so  these functions can be also be used from Powershell.</p> <p>Warning</p> <p>In contrast to LUA, Powershell by default uses Unicode encodiung (16-Bit characters)!  For interoperability with LUA, make sure to encode/decode all strings to UTF8 (as shown  in the samples below)!</p> <p>The following samples are based on https://stackoverflow.com/questions/46400234/encrypt-string-with-the-machine-key-in-powershell.</p> <pre><code>Function Decrypt-WithMachineKey($s) {\n    Add-Type -AssemblyName System.Security\n\n    $SecureStr = [System.Convert]::FromBase64String($s)\n    $bytes = [Security.Cryptography.ProtectedData]::Unprotect($SecureStr, $null, [Security.Cryptography.DataProtectionScope]::LocalMachine)\n    $Password = [System.Text.Encoding]::UTF8.GetString($bytes)\n    return $Password\n}\n\nFunction Encrypt-WithMachineKey($s) {\n    Add-Type -AssemblyName System.Security\n\n    $bytes = [System.Text.Encoding]::UTF8.GetBytes($s)\n    $SecureStr = [Security.Cryptography.ProtectedData]::Protect($bytes, $null, [Security.Cryptography.DataProtectionScope]::LocalMachine)\n    $SecureStrBase64 = [System.Convert]::ToBase64String($SecureStr)\n    return $SecureStrBase64\n}\n\n# Encrypt\n$plaintext = \"MySuperSecretPassword\"\n$encrypted_b64 = Encrypt-WithMachineKey($plaintext)\n\n# Show the base64-string\n$encrypted_b64\n\n# Decrypt again\n$decrypted = Decrypt-WithMachineKey($encrypted_b64)\n\n# Show the decrypted string\n$decrypted\n</code></pre>","tags":["API"]},{"location":"libs/lua-dpapi/#sample-powershell-commandlet-for-encryption","title":"Sample powershell commandlet for encryption","text":"<p>The following script is a sample for a commandlet to encrypt sensitive data from the commandline. Use this as follows:</p> <pre><code>powershell -file myscript.ps1 -data \"MySuperSecretPassword\"\n</code></pre> <p>Warning</p> <p>Powershell uses the <code>$</code> (dollar) sign as a special character. If your plaintext password contains a dollar sign, then insert a backtick character plus the dollar sign instead of the original <code>$</code>.</p> <p>Here is the sample:</p> <pre><code># Encrypt a given text using DPAPI (machine key)\n# \n#   powershell -file myscript.ps1 -data \"MySuperSecretPassword\"\n#\nparam(\n    [Parameter(Mandatory=$True, Position=0)]\n    [System.String]\n    $data\n)\n\nFunction Encrypt-WithMachineKey($s) {\n    Add-Type -AssemblyName System.Security\n\n    $bytes = [System.Text.Encoding]::UTF8.GetBytes($s)\n    $SecureStr = [Security.Cryptography.ProtectedData]::Protect($bytes, $null, [Security.Cryptography.DataProtectionScope]::LocalMachine)\n    $SecureStrBase64 = [System.Convert]::ToBase64String($SecureStr)\n    return $SecureStrBase64\n}\n\n# Encrypt\n$encrypted_b64 = Encrypt-WithMachineKey($data)\n\n# Show the base64-string\n$encrypted_b64\n</code></pre>","tags":["API"]},{"location":"libs/lua-hid/","title":"LuaHID","text":"<p>LuaHID provides an interface to access USB devices over the <code>HID</code> (human input device) protocol. It implements a thin LUA wrapper interface over the  cross platform hidapi library (hidapi.dll, see  signal11/hidapi (github.com), licensed under BSD License). The code is derived from ynezz/luahidapi (github.com) (MIT License) and adopted to OGS.</p> <p>Note, that although USB mice and keyboards are technically HID devices, the Windows API does not allow to access these through the HID API (for security reasons). All other (custom) USB HID devices should work.</p>","tags":["API"]},{"location":"libs/lua-hid/#module","title":"Module","text":"<p>The LuaHID module provides global functions to access the systems HID API. Before calling any other function of the module, the <code>init()</code> function must be called. </p> <p>To actually connect to a physical device, an instance of the <code>HidDevice</code> object must be created (see #class_hiddevice below) by calling the <code>open()</code> function. This requires specifying the VID (vendor ID) and PID (device id) and (optionally) the SN (serial number). If the parameters are not known beforehand, they may be listed through calling the module level <code>enumerate()</code> function. This returns a table of all currently connected devices. Specific device actions (like reading/writing) can then be executed on the object returned from the <code>open()</code> call.</p>","tags":["API"]},{"location":"libs/lua-hid/#properties","title":"Properties","text":"Property Name Return Type Description Tags <code>_VERSION</code> <code>string</code> Current version of the LuaHID module. See also the <code>version_mod()</code> function to get more details about the DLL module version. Read-Only <code>_TIMESTAMP</code> <code>string</code> Timestamp of the last build of the LuaHID module. Read-Only","tags":["API"]},{"location":"libs/lua-hid/#functions","title":"Functions","text":"Function Name Return Type Description Tags <code>init()</code> <code>boolean</code> Initializes the LuaHID library. Returns true on success, nil on failure. None <code>exit()</code> <code>boolean</code> Cleans up and terminates the LuaHID library. Returns true on success, nil on failure. None <code>enumerate(integer vid, integer pid)</code><code>enumerate()</code> <code>hidenum</code> Returns a HID device enumeration object for HID devices that matches given vid, pid pair. Enumerates all HID devices if no arguments provided or (0,0) used.IMPORTANT: Mouse and keyboard devices are not visible on WindowsReturns nil if failed. None <code>open(string path)</code><code>open(number vid, number pid)</code> <code>HidDevice</code> Opens a HID device using a path name or a vid,pid pair. Returns a HID device object on success - specifying a serial number is currently not implemented. Returns nil on failure. None <code>write(HidDevice dev, string report)</code><code>write(HidDevice dev, integer report_id, string report)</code> <code>integer</code> Writes the given <code>report</code> data string to the <code>report_id</code> (0 by default). Returns number of bytes actually sent on success, nil on failure. None <code>read(HidDevice dev, integer report_size [, timeout_msec])</code> <code>string</code> Reads data from the given device. If a device has multiple reports, the first byte indicates the report ID and one extra byte needs to be allocated via report_size. For a normal call, <code>timeout_msec</code> can be omitted and blocking will depend on the selected option setting. Passing <code>timeout_msec</code> == -1 will always block. Returns the report data (as string) on success, nil on failure. None <code>set(HidDevice dev, string option)</code> <code>integer</code> Set the read blocking option, allowed parameters are <code>noblock</code> and <code>block</code>. Returns true on success, nil on failure. None <code>getstring(HidDevice dev, string option)</code> <code>string</code> Reads the given option property from the device. Currently known option names are <code>manufacturer</code>, <code>product</code> and <code>serial</code>. Returns the option value on success, nil on failure. None <code>setfeature(HidDevice dev, integer feature_id, string data)</code> <code>integer</code> Send a feature report for the given <code>feature_id</code> with the given <code>feature_data</code>. Returns the number of bytes actually sent on success, nil on failure. None <code>getfeature(HidDevice dev, integer feature_id, integer feature_size)</code> <code>string</code> Get (read) a feature report for the given <code>feature_id</code>. A 0 is used for a single feature report. Returns the feature data (as a string) on success, nil on failure. None <code>error(HidDevice dev)</code> <code>string</code> Returns a string (as ASCII) describing the last error occurred for the device or nil if there was no error. None <code>close(HidDevice dev)</code> <code>None</code> Closes the given HidDevice object. None <code>msleep(integer milliseconds)</code> <code>None</code> Convenience function to sleep a number of milliseconds. None <code>version_mod()</code> <code>string, table</code> Returns the file version info of the LuaHID DLL (as a string in the from \"major.minor.build-hi,build-low\" and a table with the same values. None","tags":["API"]},{"location":"libs/lua-hid/#class-hiddeviceinfo","title":"Class HidDeviceInfo","text":"<p>The HidDeviceInfo table provides information about a USB HID device connected to the system. The HidDeviceInfo is retrieved by calling the <code>enumerate()</code> function and iterating the result by calling the <code>next()</code> member. </p>","tags":["API"]},{"location":"libs/lua-hid/#properties_1","title":"Properties","text":"Property Name Return Type Description Tags <code>path</code> <code>string</code> System specific device path. Read-Only <code>vid</code> <code>integer</code> Vendor ID of the device. Read-Only <code>pid</code> <code>integer</code> Product ID of the device. Read-Only <code>serial_number</code> <code>string</code> Device serial number. Read-Only <code>release</code> <code>integer</code> Release number (version) of the device. Read-Only <code>manufacturer_string</code> <code>string</code> Manufacturer name. Read-Only <code>product_ _string</code> <code>string</code> Product name. Read-Only <code>usage_page</code> <code>integer</code> HID usage page of the device. Read-Only <code>usage</code> <code>integer</code> HID usage of the device. Read-Only <code>interface</code> <code>integer</code> Interface number of the device. Read-Only","tags":["API"]},{"location":"libs/lua-hid/#class-hidenum","title":"Class HidEnum","text":"<p>The HidEnum class is actually an iterator and represents the list returned from calling the <code>enumerate</code> module function. Each element of the list represents a connected USB HID device and has the properties shown in the following section.  To iterate the list, call the <code>next()</code> instance function - each call to next returns a <code>HidDeviceInfo</code> table and internally advances to the next item.</p>","tags":["API"]},{"location":"libs/lua-hid/#functions_1","title":"Functions","text":"Function Name Return Type Description Tags <code>next()</code> <code>HidDevice</code> Returns the current device info data and steps on to the next element in the list. None <code>close()</code> <code>None</code> Closes the iterator and frees any resources. There is normally no need to call this, as the object is garbage collected automatically. None","tags":["API"]},{"location":"libs/lua-hid/#class-hiddevice","title":"Class HidDevice","text":"","tags":["API"]},{"location":"libs/lua-hid/#functions_2","title":"Functions","text":"<p>The member functions of HidDevice are wrapped functions of the module. The following lines are identical:</p> <pre><code>local hidapi = require('luahid')\n-- ...\n-- assume dev is a HidDevice object returned from calling open()\n-- The following are identical:\nhidapi.write(dev, report_id, report_data)\ndev:write(report_id, report_data)\n</code></pre> Function Name Return Type Description Tags <code>write(string report)</code><code>write(HidDevice dev, integer report_id, string report)</code> <code>integer</code> See <code>LuaHID.write(...)</code> None <code>read(integer report_size [, timeout_msec])</code> <code>string</code> See <code>LuaHID.read(...)</code> None <code>set(HidDevice dev, integer option)</code> <code>integer</code> See <code>LuaHID.set(...)</code> None <code>getstring(HidDevice dev, string option)</code> <code>string</code> See <code>LuaHID.getstring(...)</code> None <code>setfeature(HidDevice dev, integer feature_id, string data)</code> <code>integer</code> See <code>LuaHID.setfeature(...)</code> None <code>getfeature(HidDevice dev, integer feature_id, integer feature_size)</code> <code>string</code> See <code>LuaHID.getfeature(...)</code> None <code>error()</code> <code>string</code> See <code>LuaHID.error(...)</code> None <code>close(HidDevice dev)</code> <code>None</code> See <code>LuaHID.close(...)</code> None","tags":["API"]},{"location":"libs/lua-hid/#examples","title":"Examples","text":"","tags":["API"]},{"location":"libs/lua-hid/#enumerate-connected-devices","title":"Enumerate connected devices","text":"<p>This sample lists all connected HID devices and shows some of their properties. <pre><code>-- Load the LuaHID module\nlocal hidapi = require('luahid')\nprint(string.format(\"Lib VERSION %s build on %s\", hid._VERSION, hid._TIMESTAMP))\n\n-- Initialize the library\nif hidapi.init() then\n    print(\"hid library: init\")\nelse\n    print(\"hid library: init error\")\n    return\nend\n\n-- Enumerate the currently connected devices and print some information\nlocal enum = hidapi.enumerate()\nif not enum then\n    print(\"Enumeration: no device found or enumeration failed!\")\n    return\nelse\n    while true do\n        local dev = enum:next()\n        if not dev then break end\n            print(\"Device found:\")\n            print(string.format(\"path = '%s'\", dev.path))\n            print(string.format(\"vid = 0x%04X\", dev.vid))\n            print(string.format(\"pid = 0x%04X\", dev.pid))\n            print(string.format(\"serial_number = '%s'\", dev.serial_number))\n        end\n    end\nend\n\n-- Do a clean shutdown\nif hidapi.exit() then\n    print(\"hid library: exit\")\nelse\n    print(\"hid library: exit error\")\n    return\nend\n</code></pre></p>","tags":["API"]},{"location":"libs/lua-hid/#readwrite-device-report-data","title":"Read/write device report data","text":"<p>This sample tries to connect to a specific device using a given VID/PID and writes/reads some data in non-blocking mode.  <pre><code>-- Load the LuaHID module\nlocal hidapi = require('luahid')\nprint(string.format(\"Lib VERSION %s build on %s\", hid._VERSION, hid._TIMESTAMP))\n\n-- Initialize the library\nif hid.init() then\n    print(\"hid library: init\")\nelse\n    print(\"hid library: init error\")\n    return\nend\n\n-- Open a device by VID/PID\nUSB_DEVICE_VID = 0x04D8\nUSB_DEVICE_PID = 0x8ABC\nUSB_REPORT_SIZE = 4\nlocal dev = hidapi.open(USB_DEVICE_VID, USB_DEVICE_PID)\nif not dev then\n    print(\"Open: unable to open test device\")\n    return\nend\nprint(\"Open: opened test device\")\n\n-- Read the serial number\nlocal sn = dev:getstring(\"serial\")\nif sn then\n    print(\"Product String: \"..sn)\nelse\n    print(\"Unable to read product string\")\n    return\nend\n\n-- set non-blocking reads\nif not dev:set(\"noblock\") then\n    print(\"Failed to set non-blocking option\")\n    return\nend\n\n-- Try to read from the device. There shoud be no\n-- data here, but execution should not block.\nlocal rx = dev:read(USB_REPORT_SIZE)\nif rx then\n    print(\"Done non-blocking read test\")\n    print(\"Size of report read = \"..#rx)\nelse\n    print(\"Read error during non-blocking read test\")\n    return\nend\n\n-- Prepare and write report; report 0 is implied\nlocal tx = string.char(0x12, 0x34, 0x56, 0x78)\nlocal res = dev:write(tx)\nif not res then\n    print(\"Unable to write()\")\n    print(\"Error: \"..dev:error())\n    return\nend\n\n-- Try reading data\nlocal rx\nfor i = 1, 10 do\n    -- a non-infinite read loop\n    -- since we read immediately right after writing, the device buffer\n    -- will be empty, it will NAK, and an empty string is returned\n    rx = dev:read(USB_REPORT_SIZE)\n    if not rx then\n        print(\"Unable to read()\")\n        print(\"Error: \"..dev:error())\n        return\n    elseif rx == \"\" then\n        print(\"Waiting...\")\n    else\n        break\n    end\n    for j = 1,200000 do end -- short delay\nend\nif #rx &gt; 0 then\n    print(\"Successfully read data from device!\")\nend\n\n-- Close the device\ndev:close()\nprint(\"Close: closed test device\")\n\n-- Do a clean shutdown\nif hidapi.exit() then\n    print(\"hid library: exit\")\nelse\n    print(\"hid library: exit error\")\n    return\nend\n</code></pre></p>","tags":["API"]},{"location":"libs/lua-hid/#more-samples","title":"More samples","text":"<p>More samples can be found in then <code>examples</code>-folder in the GitHub repository at luahidapi/doc/examples at master \u00b7 ynezz/luahidapi (github.com).</p>","tags":["API"]},{"location":"libs/lua-modbus/","title":"LuaModbus","text":"<p>LuaModbus provides a wrapper over libModbus (see libmodbus (github.com), LGPL-2.1) to access Modbus-TCP/UDP-Devices from LUA. In addition to wrapping the libModbus library, LuaModbus also adds a background thread to cyclically read/write a set of registers and automatically reconnect the connection. Using this thread, after the connection is (re)established, a register can automatically be set to a given value (e.g. for setting a \"startup\" bit as seen in the Rexroth/Phoenix Contact I/O modules). The actual LUA wrapper is based on the etactica/lua-libmodbus (github.com) LUA bindings (MIT-License), but heavily modified for use with OGS.</p> <p>Unless otherwise noted, LuaModbus implements the same set of features as the original lua-libmodbus, so the library documentation (Reference (etactica.github.io)) is a very good source of information.</p> <p>Content will follow soon...</p>","tags":["API"]},{"location":"libs/lua-net/","title":"LuaNet","text":"<p>LuaNet provides simple to use functions for REST/OpenAPI calls using http and https protocols. Compared to luasocket and luassl, it uses the the Windows infrastructure and therefore correctly works with system proxies. Feature-wise it is not as flexible as luasocket/luassl at the moment (e.g. no direct access to all headers), but it is good enough for OAuth and SAP endpoints (like the SAP Digital Manufacturing Cloud).</p> <p>The basic functions work in a blocking mode, i.e. the process calling the function is blocked until a response from the endpoint is received. However, there are also asynchronous functions for starting a (post) request and polling for the completion. This is especially useful for long-running OpenAPI calls (like some SAP digital manufacturing cloud endpoints).</p> <p>Info</p> <p>All functions in LuaNet work transparently, i. e. use raw text strings (binary) for request and response body texts. For OpenAPI/REST services typically JSON encoded objects are used. From the large number of lua json libraries (e. g. see Awesome Lua), we recommend to use Lua CJSON. If you use another library, make sure it support UTF8 correctly! </p>","tags":["API"]},{"location":"libs/lua-net/#module","title":"Module","text":"<p>The LuaNet module provides global functions to execute http/https requests.</p>","tags":["API"]},{"location":"libs/lua-net/#functions","title":"Functions","text":"<p>Info</p> <p>For authentication, currently two options are supported: basic authentication through username/password (if user/pass parameters are non-empty) or OAuth2 client credentials (use the <code>token</code> parameter to pass data received from the <code>get_oauth_token</code> function). </p> <p>The following table lists blocking functions: </p> Function Name Return Type Description Tags <code>get(url: string, user: string = nil, pass: string = nil)</code> <code>data: string, status: number, statustext: string, data: string</code> or <code>nil, status: number, statustext: number</code> Executes a blocking get request for the given URL. If the server returns (http) status = 200, then the response is considered valid. In any case, <code>status</code> and <code>statustext</code> will receive the http response header status data. If a response body is available, then this is returned in the <code>data</code> return value (even if status ~= 200). None <code>get_oauth_token(url: string, user: string = nil, pass: string = nil)</code> <code>status: number, data: string</code> or <code>nil, status: number, statustext: string</code> Requests client credentials from an OAuth2 server (granttype = client_credentials). None <code>post(url: string, body: string = nil, auth_bearer_token: string = nil, user: string = nil, pass: string = nil)</code> <code>status: number, data: string, statustext: string</code> Send a post request to the given endpoint <code>URL</code>, with post <code>data</code> in the request body, optinally adding the <code>auth_bearer_token</code> value to the <code>Authorization</code> header. None <code>put(url: string, body: string = nil, auth_bearer_token: string = nil, user: string = nil, pass: string = nil)</code> <code>status: number, data: string, statustext: string</code> Send a put request to the given endpoint <code>URL</code>, with put <code>data</code> in the request body, optinally adding the <code>auth_bearer_token</code> value to the <code>Authorization</code> header. None <p>The following table lists the non-blocking functions:</p> Function Name Return Type Description Tags <code>post_async(url: string, body: string = nil, auth_bearer_token: string = nil, user: string = nil, pass: string = nil)</code> <code>handle: number</code> or <code>nil</code> Starts an async post request (see the blocking <code>post</code> above for parameter descriptions). On success a <code>handle</code> is returned, which can be used for polling the request status or aborting the request. None <code>put_async(url: string, body: string = nil, auth_bearer_token: string = nil, user: string = nil, pass: string = nil)</code> <code>handle: number</code> or <code>nil</code> Starts an async put request (see the blocking <code>put</code> above for parameter descriptions). On success a <code>handle</code> is returned, which can be used for polling the request status or aborting the request. None <code>abort_async_request(handle: number)</code> (no return value) Tries to abort a currently active request identified by the <code>handle</code> value (as returned from <code>post_async()</code>. If the request is currently active, it might block for a short time - until the request is actually cancelled. If a request was cancelled, then further calls to <code>poll_async_request()</code> will return <code>nil</code>, as the internal request object for the given handle was deleted and does not exist anymore. None <code>poll_async_request(handle: number)</code> <code>requeststate: number, status: number, data: string, statustext: string</code>  or <code>nil, errorcode: number, errortext: string</code> Checks the request state of a pending request and returns the current state in <code>requeststate</code>. If the 'handle' was not found, nil is returned for <code>requeststae</code>, else the current (internal) process step. A value of &gt;= 100 indicates, that the request has completed and the other return values are valid (see the blocking <code>post</code> above for result value descriptions). Note, that the internal request object is automatically deleted after <code>poll_async_request()</code> returns a status of &gt;= 100. None <p>Warning</p> <p>A request started through <code>post_async()</code> must be completed by either aborting the request through <code>abort_async_request()</code> or by polling the request (by using <code>poll_async_request</code>) until a state of &gt;= 100 is returned. If not, then the internal request object will not get deleted thus consuming more and more resource.</p>","tags":["API"]},{"location":"libs/lua-net/#examples","title":"Examples","text":"","tags":["API"]},{"location":"libs/lua-net/#simple-get-request","title":"Simple get request","text":"<p>This sample shows how to execute a simple https get request with basic authentication (e.g. typical surveillance camera).</p> <pre><code>local mime = require('mime')       -- load luasocket/mime (base64)\n\n-- Sample plaintext password (or connection string, etc)\nlocal plaintext = 'MySuperSecretPassword' \n\n-- Encrypt the plaintext for the 'machine' scope. All users logged \n-- into the same machine will be able to decrypt the data later.\n-- encrypt (usually done at the commandline through powershell):\nlocal encrypted_data, err = dpapi.protect(plaintext, 'machine') \nif encrypted_data == nil then\n    print(\"ERROR: encrypt failed, err=\", err)\n    os.exit(-1)\nend\n\n-- Do a base64 encode of the encrypted data for storing in *.ini file:\nlocal encrypted_b64 = mime.b64(encrypted_data)     \n\n-- TODO: save to some text file, but for now just print it\nprint(\"encrypted, base64 encoded data: \", encrypted_b64)\n</code></pre>","tags":["API"]},{"location":"libs/lua-net/#decrypt-base64-encoded-data","title":"Decrypt base64-encoded data","text":"<p>This sample shows how to decrypt previously encrypted and base64 encoded data. </p> <pre><code>local dpapi = require('luadpapi')   -- load the DPAPI\nlocal mime = require('mime')        -- load luasocket/mime (base64)\n\n-- Sample plaintext password (or connection string, etc)\n-- !!! Make sure to paste the data generated from the previous sample!\nlocal encrypted_b64 = 'AQAAANCMnd8BFdERjHoAwE/Cl+'...'ylQ=' \n\n-- Convert from base64 to raw data\nlocal encrypted = mime.unb64(encrypted_b64)\n\n-- Decrypt the raw data.\nlocal decrypted_data, err = dpapi.unprotect(encrypted) \nif decrypted_data == nil then\n    print(\"ERROR: decrypt failed, err=\", err)\n    os.exit(-1)\nend\n\n-- TODO: use the decrypted data - assume this is a string and print it:\nprint(\"decrypted data: \", decrypted_data)\n</code></pre>","tags":["API"]},{"location":"tools/","title":"Tool configuration","text":""},{"location":"tools/#overview","title":"Overview","text":""},{"location":"tools/#stationini","title":"station.ini","text":""},{"location":"tools/remote-tool/","title":"RemoteTool","text":"<p>OGS supports connecting tools over a <code>ToolGateway</code>. This enables advanced  tool management scenarios, e.g. \"roaming\" tools between multiple stations.</p> <p>Using the <code>RemoteTool</code> driver requires a <code>ToolGateway</code> running on a server - the server then actually controls the tool, whereas the OGS stations only communication with the <code>ToolGateway</code>. This allows delegating tool management to the central <code>ToolGateway</code>. </p> <p>For each tool managed through the <code>ToolGateway</code>, OGS only uses a generic <code>RemoteTool</code> type channel in its local configuration, the <code>ToolGateway</code> then has the actual tool-specific configuration (like e.g. OpenProtocol tools).</p>"},{"location":"tools/remote-tool/#installation","title":"Installation","text":"<p>The <code>RemoteTool</code> driver is implemented in <code>RemoteTool.dll</code>. To use any <code>RemoteTool</code> tool, the driver must be loaded in the <code>[TOOL_DLL]</code> section of the projects <code>station.ini</code> configuration file (see also Tool configuration).</p> <p>To enable the driver in station.ini, set it as follows:</p> <pre><code>[TOOL_DLL]\nRemoteTool.dll=1\n</code></pre> <p>The overall parameters for the <code>RemoteTool</code> driver are configured in the \u00b4[RemoteTool]<code>section. This is basically used to configure the</code>ToolGateway` connection parameters, here is a sample setup:</p> <pre><code>[RemoteTool]\nToolGateway_Addr=mytoolgateway.mycompany.com\nToolGateway_Port=\n</code></pre> <p>For more information about the driver parameters, see Driver Parameters below.</p>"},{"location":"tools/remote-tool/#tool-registration-and-configuration","title":"Tool registration and configuration","text":"<p>All <code>RemoteTool</code>-tools are registered in the <code>[CHANNELS]</code> section of the projects <code>station.ini</code> file.</p> <p>The <code>[CHANNELS]</code> section only defines a channel number to channel name mapping - the channel/tool specific settings are then configured in a seperate section defined by the channel name. Inside the section, a reference to the <code>RemoteTool</code> driver then links driver and channel accordingly.</p> <p>The overall layout is therefore as follows (sample is for channel 2):</p> <pre><code>[CHANNELS]\n# Map the channel/tool 2 to the 'RemoteTool_Nexo1'-section\n2=RemoteTool_Nexo1\n\n[RemoteTool_Nexo1]\n# link to the RemoteTool driver\nDRIVER=RemoteTool\n# more channel/tool specific parameters for this tool/driver\n</code></pre> <p>Please see Channel/tool parameter reference below for more information about the available parameters.</p>"},{"location":"tools/remote-tool/#channeltool-parameter-reference","title":"Channel/tool parameter reference","text":"<p>Currently, there are no channel/tool-specific parameters needed (other than specifying the <code>DRIVER=RemoteTool</code>) to use this driver. All concrete tool communication settings are to be configured on the <code>ToolGateway</code> server side. </p>"},{"location":"tools/remote-tool/#driver-parameter-reference","title":"Driver parameter reference","text":"<p>The driver parameters are defined in the <code>[RemoteTool]</code> section in the projects <code>station.ini</code>.</p> <p>The following parameters are available:</p>"},{"location":"tools/remote-tool/#toolgateway_addr","title":"ToolGateway_Addr","text":"<p>IP address or hostname of the tool gateway.</p>"},{"location":"tools/remote-tool/#toolgateway_port","title":"ToolGateway_Port","text":"<p>(optional)</p> <p>Port number to use for connecting to the tool gateway. If not given, the driver tries to use the RPC endpoint mapper using the service UUID to resolve the connection endpoint (might require additional firewall settings).</p>"},{"location":"tools/openprotocol/","title":"OpenProtocol tools","text":""},{"location":"tools/openprotocol/#overview","title":"Overview","text":"<p>OGS supports connecting tools with <code>OpenProtocol</code> interface. As tools differ in functionality and also different tool vendors implement the <code>OpenProtocol</code> specification in slightly different ways, OGS has special protocol handlers for the following tools:</p> <ul> <li>Rexroth Nexo and Nexo 2 wireless tools (for more information, see Nexo OpenProtocol)</li> <li>Rexroth CS351 and KE350 system tools (for more information, see System 350 OpenProtocol)</li> <li>Rexroth OPEXplus (for more information, see OPEXplus OpenProtocol)</li> <li>GWK Operator+ torque wrenches (for more information, see GWK Operator+ OpenProtocol)</li> <li>Crane TCI torque wrenches (for more information, see Crane OpenProtocol)</li> <li>Gehmeyr Exact Wifi tools (for more information, see Gehmeyr OpenProtocol)</li> <li>Sturtevant Richmont Global 400 MP connected Exacta 2 digital torque wrenches (for more information, see Sturtevant Richmond OpenProtocol)</li> <li>HS-Technik riveting tool</li> </ul> <p>The overall configuration for these tools is similar and the actual driver has the same set of configuration parameters - described on this page.</p> <p>To workaround various glitches in the tools concrete OpenProtocol implementation, the tools are identified by their MID0002 vendor string and their tool type name. For more details, see the CHANNEL TYPE Parameter description in the Channel parameter reference below. </p> <p>The supported tool types and vendor codes are:</p> Tool type Vendor code Vendor Comments NEXO BRC Bosch Rexroth Wireless Nexo Tool CS351 BRC Bosch Rexroth Single channel Compact Box KE350 BRC Bosch Rexroth Multispindle system OPEX (GWK) Bosch Rexroth OPEXplus torque wrench CRANE CEL Crane Electronics TCI Multi, Wrenchstar GHM GHM Gehmeyr GF-ION-EXACT GWK GWK GWK Operator+, Operator22 CET CET Sturtevant Richmond Global 400mt controller BTC BTC HS-Technik NutBee riveting tool ATG ATG Cleco Cleco wifi battery tool"},{"location":"tools/openprotocol/#installation","title":"Installation","text":"<p>The <code>OpenProtocol</code> driver is implemented in <code>OpConn.dll</code>. To use any <code>OpenProtocol</code> tool, the driver must be loaded in the <code>[TOOL_DLL]</code> section of the projects <code>station.ini</code> configuration file (see also Tool configuration).</p>"},{"location":"tools/openprotocol/#tool-registration-and-configuration","title":"Tool registration and configuration","text":"<p>All <code>OpenProtocol</code>-tools are registered in the <code>[OPENPROTO]</code> section of the projects <code>station.ini</code> file.</p> <p>The <code>[OPENPROTO]</code> section mixes the tool parameters and the channel mapping (due to historic reasons) by combining the channel number and the parameter name/value in the <code>station.ini</code> entry. </p> <p>Each parameter is prefixed with the channel number and followed by parameter name as follows:</p> <pre><code>CHANNEL_&lt;two-digit channel&gt;_&lt;param name&gt;=&lt;param value&gt;\n</code></pre> <p>Where - <code>&lt;two-digit channel&gt;</code> is the channel number in the range 01...99 (the channel number maps 1:1 to the tool number from the workflow configuration)  - <code>&lt;param name&gt;</code> is the parameter name (see Channel parameter reference) - <code>&lt;param value&gt;</code> is the actual parameter value for the given parameter</p> <p>In addition to the channel-specific parameters, there are also shared parameters. These act as default parameters for the channel-specific settings and can be overridden by the channel specific values.</p> <p>For more details on the shared parameters, see Shared parameter reference) below .</p> <p>A sample <code>OpenProtocol</code> tool configuration (channel 01) would therefore look similar to the following:</p> <pre><code>[OPENPROTO]\n# Shared/default parameters\nPORT=4545\n# Channel/Tool 1 parameters\nCHANNEL_01=10.10.2.163\nCHANNEL_01_TYPE=NEXO\nCHANNEL_01_CHECK_TIME_ENABLED=1\nCHANNEL_01_NEXONAR_CHANNEL=6\nCHANNEL_01_CURVE_REQUEST=1\n</code></pre>"},{"location":"tools/openprotocol/#openprotocol-driver-parameters-reference","title":"OpenProtocol driver parameters reference","text":""},{"location":"tools/openprotocol/#shared-parameter-reference","title":"Shared parameter reference","text":"<p>The shared parameters are used to change the global defaults for all OpenProtocol tools. If assigned, then these settings will override the built-in defaults. Note, that a channel-specific setting will take priority anyways.</p>"},{"location":"tools/openprotocol/#port","title":"PORT","text":"<p>(optional, defaults to 4545)</p> <p>Defines the TCP port used for OpenProtocol communication. By default uses the standard OpenProtocol port 4545. If the controller supports multiple tools through a single IP address, then typically this setting must be changed to correctly connect to the individual tool.</p>"},{"location":"tools/openprotocol/#check_time_interval","title":"CHECK_TIME_INTERVAL","text":"<p>(optional, defaults to 5 [minutes])</p> <p>Defines the time [in minutes] when OGS shall check the tools clock. This setting is only used, if time synchronization is enabled for the tool (see CHECK_TIME_ENABLED below).</p>"},{"location":"tools/openprotocol/#time_tolerance","title":"TIME_TOLERANCE","text":"<p>(optional, defaults to 5 [seconds])</p> <p>Defines the maximum allowed time difference [in seconds] before OGS corrects the tools realtime clock. This setting is only used, if time synchronization is enabled for the tool (see CHECK_TIME_ENABLED below).</p>"},{"location":"tools/openprotocol/#external_io_offset","title":"EXTERNAL_IO_OFFSET","text":"<p>(optional, defaults to 0)</p> <p>This setting enables custom IO access (through LUA) over the OpenProtocol interface. This can be used to read physical inputs and set physical outputs connected to the controller over OpenProtocol.</p> <p>Depending on the tool, different MIDs are used - to enable this for CS351 and KE350, set it to 2.</p>"},{"location":"tools/openprotocol/#channel-parameter-reference","title":"Channel parameter reference","text":"<p>For specific information about a tools settings or the tools configuration needed (on the tool side), please see the tool-specific information.</p> <p>The parameter names are composed of the channel prefix <code>CHANNEL_</code> followed by the channel/tool number (1-32) and the actual parameter name (e.g. <code>TYPE</code>). - see the detailed description above. </p> <p>In general, the following parameters are available for a <code>OpenProtocol</code>-tool:</p>"},{"location":"tools/openprotocol/#channel__ip","title":"CHANNEL__IP <p>(mandatory)</p> <p>This setting defines the IP address to use for communication with the tool.</p>","text":""},{"location":"tools/openprotocol/#channel__port","title":"CHANNEL__PORT <p>(optional, defaults to the shared parameter value)</p> <p>See PORT in the shared parameter reference.</p>","text":""},{"location":"tools/openprotocol/#channel__type","title":"CHANNEL__TYPE <p>(mandatory)</p> <p>The allowed tool types and their default parameters are listed in the following table (see the overview section above for tool details):</p>    Tool type Alive send rate Response Timeout Comments     NEXO 2 5    CS351 5 15    OPEX 2 5 No MID0040 support, use MID0061 tool SN   KE350 5 15    CRANE 1 5    GHM 2 5 MID0060 Rev 999 only, no alarms   GWK 2 5 No MID0040 support, use MID0061 tool SN   CET 2 5 no alarms, incorrect (+1) result ID sequence   BTC 2 5    ATG 2 5     <p>NOTES: - The Alive send rate and Response timeout default parameter values can be overridden by the CHANNEL__ALIVEXMTT and CHANNEL__RSPTIMEOUT parameters.  - All tools use a slightly different set of MIDs to control operation, e.g. some do support alarms, others don't or allow different revisions of the MID commands. - For Nexo with firmware &lt; V1500, a Alive send rate of 1000ms or less is recommended to ensure stable WiFi operation - For CS351 and KE350, do not use a Alive send rate less than 5 second, else the controller may become unresponsive","text":""},{"location":"tools/openprotocol/#channel__ccw_ack","title":"CHANNEL__CCW_ACK <p>(optional, default = 0 (disabled))</p> <p>Defines, if the operator must select a loosen operation on the tool end (for tools having a CW/CCW switch which is accessible over OpenProtocol). Currently only Rexroth Nexo, CS351 and KE350 support this feature.</p> <p>The following settings are available:</p> <ul> <li>0: Disabled. OGS select a CCW program automatically</li> <li>1: Enabled. Operator must switch to CCW manually </li> </ul>","text":""},{"location":"tools/openprotocol/#channel__alivexmtt","title":"CHANNEL__ALIVEXMTT <p>(optional, default defined by tool type (see above))</p> <p>Defines how often OGS shall send an <code>ALIVE</code> data packet (<code>MID9999</code>) to the tool to check for connectivity. The value is given in milliseconds.</p> <p>If no answer from the tool is received within 3 times of this time, then the connection with the tool is considered disconnected. In this case, OGS shuts down the connection and tries to reconnect.</p>","text":""},{"location":"tools/openprotocol/#channel__rsptimeout","title":"CHANNEL__RSPTIMEOUT","text":""},{"location":"tools/openprotocol/#channel__barcode_mid0051_rev","title":"CHANNEL__BARCODE_MID0051_REV","text":""},{"location":"tools/openprotocol/#channel__check_ext_cond","title":"CHANNEL__CHECK_EXT_COND","text":""},{"location":"tools/openprotocol/#channel__appl_start","title":"CHANNEL__APPL_START","text":""},{"location":"tools/openprotocol/#channel__curve_request","title":"CHANNEL__CURVE_REQUEST","text":""},{"location":"tools/openprotocol/#channel__check_time_enabled","title":"CHANNEL__CHECK_TIME_ENABLED","text":""},{"location":"tools/openprotocol/#channel__ignore_id","title":"CHANNEL__IGNORE_ID","text":""},{"location":"tools/openprotocol/#debugging-settings","title":"Debugging settings","text":""},{"location":"tools/openprotocol/#channel__showalive","title":"CHANNEL__SHOWALIVE","text":""},{"location":"tools/openprotocol/#channel__params","title":"CHANNEL__PARAMS <p>(internal, default depending on tool type)</p>","text":""},{"location":"tools/openprotocol/#tool-mirroringtwins","title":"Tool mirroring/twins","text":""},{"location":"tools/openprotocol/gwk/","title":"GWK Operator+","text":"<p>The GWK Operator+ OpenProtocol implementation (currently, as of June 2023) has quite some quirks. OGS tries to workaround most of them, but the following parameters needs to be tweaked:</p> <ul> <li>The GWK tool only supports a single OpenProtocol session (even if multiple TCP connections are allowed). Make sure to disable multiple connections in the GWK xPico Web settings (under the \"Tunnel\"--&gt;\"Accept\" category)</li> <li>The GWK tool seems to never actively disconnect a TCP session and does not close an OpenProtcol session, if the TCP connection gets dropped. According to the GWK development, the internal session is only closed, if no message is received within 15 seconds (the MID9999 alive timeout) - irregardless of the state of the TCP connection. As a workaround, OGS therefore always waits for 30 seconds to reconnect to the tool in case of network communication errors. Faster reconnects are not recommended, as the tool replies with MID0004 (error 96) for the next MID0001 (which makes any OpenProtocol client disconnect). Having a reconnect time of less than 15 seconds therefore will lead to a reconnect loop, where never a good connection to the tool can be established.</li> </ul> <p>see Bosch Rexroth OPEXplus for information about the tool.</p> <p></p>"},{"location":"tools/openprotocol/sturtevant/","title":"Sturtevant Richmond Global 400mp","text":"<p>The Sturtevant Richmond controller allows </p> <p>see Global 400mp Torque Controller</p> <p></p>"},{"location":"v3/lua/customtools/","title":"Lua custom tools","text":"","tags":["API"]},{"location":"v3/lua/customtools/#overview","title":"Overview","text":"<p>OGS has an interface to add additional tool drivers by adding Windows-DLLs to the <code>[TOOL_DLL]</code> section in <code>station.ini</code>. To make it easier to implement custom tool drivers, OGS provides <code>heLuaTool.dll</code> - this allows implementing tool drivers in pure LUA. </p> <p>To implement a tool driver in LUA, usually the following steps are required:</p> <ul> <li>Add/enable <code>heLuaTool.dll</code> in the <code>[TOOL_DLL]</code>-section in <code>station.ini</code></li> <li>Create a custom LUA tool driver file (see bvelow) and add it to your projects configuration (add the file name to the <code>requires = {}</code>-list in <code>config.lua</code>)</li> <li>Add one or more channels to <code>station.ini</code> (in the <code>[CHANNELS]</code>-section in <code>station.ini</code>). Note, that the section name assigned to the tool number must start with <code>LuaTool_</code>!</li> <li>Add the specified section to <code>station.ini</code> and set <code>Driver=heLuaTool</code> and <code>TYPE=</code> to the tool driver name as defined in your custom LUA tool driver</li> <li>Also add the tool/channel parameters as required by your LUA driver in the specified section.</li> <li>To allow using the custom tools, add then to the <code>custom</code> section in the heOpCfg tools editor tab. Also add new tool/action properties as required. Make sure to use the same tool/channel numbers as defined in your <code>station.ini</code>. </li> </ul> <p>Here is an excerpt from <code>station.ini</code> showing the relevant entries:</p> station.ini<pre><code>[TOOL_DLL]\nheLuaTool.dll=1 ; (1)!\n\n[CHANNELS]\n20=LuaTool_MyCustomTool ; (2)!\n\n[LuaTool_MyCustomTool]\nDriver=heLuaTool\nTYPE=MyCustomTool\n; additional LUA too specific parameters can follow\n</code></pre> <ol> <li> <p>Load and enable the generic LUA tool interface DLL</p> </li> <li> <p>Create the channel/tool 20 and assign the configuration section <code>LuaTool_MyCustomTool</code>. Make sure to start the section name with <code>LuaTool_</code>, else the Lua tool DLL will not get loaded for this section!</p> </li> </ol> <p>To implement a tool driver using LUA, there are basically two options:</p> <ol> <li>Use the low-level API provided by <code>heLuaTool.dll</code>.</li> <li>Use the Simplified API </li> </ol> <p>Info</p> <p>It is highly recommended to use the Simplified API described below to implement custom tool drivers - using the low-level API requires in-depth knowledge of the API to not break other drivers!</p>","tags":["API"]},{"location":"v3/lua/customtools/#lua-driver-anatomy-and-driver-registration","title":"LUA driver anatomy and driver registration","text":"<p>The LUA tool driver must be implemented as LUA module, returning the module table. Another requirement is to have the tool driver type as member <code>type</code> in the module table (this is how <code>station.ini</code> and the actual LUA driver is linked). </p> <p>In addition to this, it is required to register the driver module with OGS by adding the tool driver type and its module to the global <code>lua_known_tool_types</code> table - best practice is to use the function <code>register_tool</code> from the <code>lua_tool_helpers</code>-module.</p> <p>Here is a skeleton of a driver module:</p> my_custom__driver.lua<pre><code>-- My custom LUA tool driver\nlocal _M = {\n    type = 'MyCustomTool',     -- type id (must match the DRIVER= in INI file)\n}\n\n-- register this tool with OGS (heLuaTool.dll)\nlocal helpers = require('lua_tool_helpers')\nhelpers.register_tool(_M)\n\n-- return the module\nreturn _M\n</code></pre>","tags":["API"]},{"location":"v3/lua/customtools/#simplified-api","title":"Simplified API","text":"<p>The simplified custom tool driver API uses five states and associated transitions to implement the tool behaviour. Each transitions can be implemented in the custom tool LUA code to provide the custom functionality - if not implemented, the transition is executed without a custom action.</p> <p>Here is the state diagram for the behaviour:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; active: init()\n    inactive --&gt; active: activate()\n    active --&gt; inactive: deactivate()\n    active --&gt; enabled: enable()\n    enabled --&gt; enabled: execute()\n    enabled --&gt; disabled: disable()\n    disabled --&gt; enabled: enable()\n    disabled --&gt; inactive: deactivate()</code></pre> <p>The <code>active</code> state is entered whenever OGS has an active operation for this tool. While the tool is <code>active</code>, it might switch back and forth between <code>disabled</code> and <code>enabled</code> (e.g. depending on any external enable/release condition).  After a tool result has been received, the state typically switches back to <code>inactive</code> (another tool is active or workflow has finished). </p> <p>Info</p> <p>Use the <code>lua_tool_helpers.lua</code> in your code - this provides helpers for registering the tool driver, flexible default formatting functions and a few handy helpers!</p>","tags":["API"]},{"location":"v3/lua/customtools/#tool-driver-interface-functions","title":"Tool driver interface functions","text":"<p>The actual tool driver implementation is provided by implementing the tool driver interface functions - and return them as members of the module table. Note that each interface has a <code>channel</code> parameter with</p> <p>A typical implementation would look like the following (adding the <code>_M.init()</code>, the <code>_M.enable()</code> and the the <code>_M.execute()</code> functions):</p> my_custom__driver.lua<pre><code>-- My custom LUA tool driver\nlocal _M = {\n    type = 'MyCustomTool',     -- type id (must match the DRIVER= in INI file)\n}\nlocal helpers = require('lua_tool_helpers')\n\n-------------------------------------------------------------\n-- Tool event: Initialize tool - called once during OGS init \n-- return 'OK' or some error text if the initialization failes.\nfunction _M.init(channel)\n    -- Decode/get my configuration (from station.ini)\n    local cfg = {\n        ComPort = channel.ini_params.COM_PORT,      -- COM port\n    }\n    -- Do whatever is needed to initialize your driver\n    -- ...\n    channel.cfg = cfg         -- store the channels config data\n    return 'OK'               -- init successfully done\nend\n\n----------------------------------------------------------------------------\n-- Tool event: Cyclically called while the tool is enabled\n-- return the tool task state\nfunction _M.execute(channel)\n    -- Check for tool finished\n    local ResultData = _M.GetResultData() -- must be implemented!\n    if ResultData == nil then       -- no data available from the tool\n        return channel.task_state   -- wait more.\n    end\n    if ResultData.Error then        -- some error occurred\n        return lua_task_fault       -- return an error code\n    end\n    if ResultData.Data then         -- received data\n        -- Build a result data table and notify the OGS core \n        local values = {\n            ResultData.torque,          -- M1 actual value\n            ResultData.angle,           -- M2 actual value\n            ResultData.t_min,           -- M1 min\n            ResultData.t_max,           -- M1 max\n            0.0,                        -- M2 min\n            0.0                         -- M2 max\n        }\n        local error_code = helpers.get_code_from_limits(ResultData.torque, ResultData.t_min, ResultData.t_max)\n        lua_tool_result_response(channel.tool, error_code, 0, '2A', values)\n        return lua_task_completed\n    end\n    return channel.task_state       -- wait more.\nend\n\n-------------------------------------------------------------\n-- Tool event: Called whenever the tool is to be enabled\n-- @ output: true|false  - tool enabled/not enabled \n--                         (will be called again until enabled!)\nfunction _M.enable(channel)\n    local cfg = channel.cfg     -- access the channel config data\n    -- Do whatever is needed\n    return true                 -- tool is enabled\nend\n\n-------------------------------------------------------------\n-- register this tool with OGS (heLuaTool.dll)\nhelpers.register_tool(_M)\n-- return the module\nreturn _M\n</code></pre> <p>The following functions can be implemented as part of the <code>simple</code> LUA tool driver interface:</p> Function Name Return Type Description Tags <code>init(channel: table)</code> <code>result: string</code> Is called once for each tool (channel) registered in <code>station.ini</code> for this driver. The <code>channel</code> table parameter has the <code>channel.tool</code> entry set to the channel/tool number defined in <code>[CHANNELS]</code> (from <code>station.ini</code>) and the <code>channel.ini_params</code> as a table of strings with the complete <code>LuaTool_...</code>-section from <code>station.ini</code>. Return <code>'OK'</code> on successful initialization, else an error message string. Hint: The driver can add its own instance data to the <code>channel</code> table for later use. None <code>activate(channel: table)</code> <code>result: boolean</code> Is called whenever OGS activates a tool (i.e. the workflow switches to an action/operation where this tool is needed). The function is called cyclically until it returns <code>true</code> None <code>deactivate(channel: table)</code> <code>result: boolean</code> Is called whenever OGS deactivates a tool (i.e. the workflow switches to another action/operation). The function is called cyclically until it returns <code>true</code> None <code>enable(channel: table)</code> <code>result: boolean</code> Is called whenever the tool is active and OGS needs to enable a tool. The function is called cyclically until it returns <code>true</code> None <code>disable(channel: table)</code> <code>result: boolean</code> Is called whenever the tool is active and OGS needs to disable a tool (e.g. if some external condition is removed like an external enable signal). The function is called cyclically until it returns <code>true</code> None <code>execute(channel: table)</code> <code>result: number</code> Is called while the tool is enabled to check the tool, if it has finished. If so, the global function <code>lua_tool_result_response</code> should be called (to send result data to the OGS core) and a value of <code>lua_task_completed</code> should be returned. If the function should be called again (tool not yet finished), return <code>channel.task_state</code>. In case of an error, return <code>lua_task_fault</code> or some of the other error codes (see <code>lua_tool.lua</code> in the <code>lualibs</code> folder for details) None <p>Note</p> <p>To cyclically poll a tool driver (e.g. to implement network communication), implement the modules <code>_M.poll()</code> function (low-level API) or register a global StatePoll function (use <code>StatePollFunctions.add()</code> and use the (low-level API) _M.channels table to iterate your drivers registered channels).</p>","tags":["API"]},{"location":"v3/lua/customtools/#tool-driver-formatting-functions","title":"Tool driver formatting functions","text":"<p>To allow the LUA tool drivers to correctly present their values on the OGS user interface screen, the following module interface functions can be used:</p> <ul> <li>_M.get_tool_units(): Defines the unit texts and number of digits used for formatting the tool results in the action/operation list pane. </li> <li>_M.get_tool_result_string(): Defines the main (large) result text shown in the bottom right corner result pane.</li> <li>_M.get_footer_string(): Defines the footer string shown in the bottom right corner result pane.</li> <li>_M.get_prg_string(): Defines the program string shown in the upper right corner of the bottom right corner result pane.</li> </ul> <p>As the functions are part of the low-level API, they are passed the the tool number instead of the channel table (as with the simple API interface). As the LUA tool driver infrastructure keeps a list of registered channels in each tool drivers module table, this can be used to access the channel table from a given tool as follows:</p> <pre><code>-- Get the channel table from a given tool number\n_M.get_channel_from_tool = function(tool)\n    local channel = _M.channels[tool]\n    return channel\nend\n</code></pre> <p>The following functions can be implemented for formatting:</p> Function Name Return Type Description Tags <code>get_tool_units(tool: number)</code> <code>unit1: string, unit2: string, decimals1: number, decimals2: number</code> Returns the unit text and number of decimals used for showing the result values in the result list. None <code>get_tool_result_string(tool: number)</code> <code>text: string</code> Returns the center text shown in the result pane. None <code>get_footer_string(tool: number)</code> <code>text: string</code> Returns the footer text for the result pane. None <code>get_prg_string(tool: number)</code> <code>text: string</code> Returns the program name/number text for the result pane (the top right text). None <p>The <code>lua_tool_helpers</code> module provides a reusable implementation for formatting text by specifying a format string - and a helper function to read the format strings from the <code>station.ini</code> tool driver sections.</p> <p>Here is some sample code on how to use it:</p> <pre><code>local helpers = require('lua_tool_helpers')\nlocal _M = {\n    type = 'MyLuaTool',     -- type identifier (as in INI file)\n}\n\n-------------------------------------------------------------\n-- Initialize the driver and read the parameter section\nfunction _M.init(channel)\n    -- local (tool instance specific) parameters\n    local cfg = {\n        -- Initialize the parameters for formatting\n        fmt = helpers.read_fmt_config(channel)\n    }\n    channel.cfg = cfg\n    return 'OK'\nend\n\n-------------------------------------------------------------\n-- Get the tool specific measurement units \n-- @param tool: channel number as configured in station.ini\n-- @return:  applicable only for the first two values (from 6)\n_M.get_tool_units = function(tool)\n    local channel = _M.channels[tool]\n    return helpers.get_tool_units(channel, channel.cfg.fmt)\nend\n-- Get the tool specific result string\n_M.get_tool_result_string = function(tool)\n    local channel = _M.channels[tool]\n    return helpers.get_tool_result_string(channel, channel.cfg.fmt)\nend\n-- Get the tool specific footer string\n_M.get_footer_string = function(tool)\n    local channel = _M.channels[tool]\n    return helpers.get_footer_string(channel, channel.cfg.fmt)\nend\n-- Get the tool specific program name\n_M.get_prg_string = function(tool)\n    local channel = _M.channels[tool]\n    return helpers.get_prg_string(channel, channel.cfg.fmt)\nend\n</code></pre>","tags":["API"]},{"location":"v3/lua/customtools/#tool-driver-miscelaneous-functions","title":"Tool driver miscelaneous functions","text":"<p>tbd.</p>","tags":["API"]},{"location":"v3/lua/eventlog/","title":"Workflow and interaction events","text":""},{"location":"v3/lua/eventlog/#overview","title":"Overview","text":"<p>The OGS core allows to subscribe for various events from the kernel. The main use case is to log all actions to allow full traceability or to measure event timings.</p> <p>The LUA eventlog interface consists of the single global table <code>EventLog</code> - and a few functions which are called by OGS. The <code>EventLog</code> table must be created by the LUA code during startup, as <code>EventLog.Init()</code> is only called once during the OGS startup sequence.</p> <p>The following functions should be defined to use the EventLog-Interface:</p> <ul> <li><code>EventLog.Init()</code>: Is called during OGS startup. To enable the EventLog events, the function must return true.</li> <li><code>EventLog.Stop()</code>: Is called before OGS shuts down. </li> <li><code>EventLog.Write(EventType, ...)</code>: Is called whenever a new event is emitted by the OGS core.</li> </ul> <p>The following <code>EventType</code> values are currently supported:</p> <ul> <li><code>COMMON</code> (= 0): </li> <li><code>BARCODE</code> (= 1): </li> <li><code>INTERACTION</code> (= 2):</li> <li><code>USER_LOGON</code> (= 3):</li> <li><code>ALARM</code> (= 4):</li> <li><code>WORKFLOW</code> (= 5): </li> <li><code>RESULT</code> (= 6): Called whenever the current tool result is updated.</li> <li><code>SOFTWARE_ERROR</code> (= 7):  -- configuration( ini)  errors</li> </ul>"},{"location":"v3/lua/eventlog/#events","title":"Events","text":"<p>The <code>EventLog.Write(EventType, ...)</code> function is called with different parameters, depending on the actual <code>EventType</code>. If the event is related to a user action, then the parameters <code>User1</code> and <code>User2</code> provide information about the users logged on when the event occurred. The parameters are as follows:</p> <ul> <li><code>User1</code>: The operator-level user</li> <li><code>User1</code>: The supervisor-level user (if logged on)</li> </ul>"},{"location":"v3/lua/eventlog/#common-event","title":"Common event","text":"<p>The common event is currently not used by the OGS core, but reserved as a general status/text event placeholder. It can be used e.g. from the LUA side to inject custom events. The function signature is as follows:</p> <pre><code>EventLog.Write(BARCOMMON, Status, Text)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li>Status (int): Custom status code</li> <li>Text (string): Custom event message</li> </ul>"},{"location":"v3/lua/eventlog/#barcode-event","title":"Barcode event","text":"<p>The barcode event is fired, whenever a new barcode is received. The function signature is as follows:</p> <pre><code>EventLog.Write(BARCODE, FieldNo, User1, User2, Code, Source, Tag)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li>FieldNo: Barcode field number (reference into the barcode table)</li> <li>Code: The actual ID-Code value</li> <li>Source: The ID code source (<code>Barcode</code>, <code>RFID</code>, ... whatever is configured in <code>station.ini</code> or added through <code>barcode.lua</code>)</li> <li>Tag: The barcode table tag name - typically used to identify the type of the scanned bar code. This has a 1:1 relation to the FieldNo value and is defined in the projects barcode table (see <code>barcode.lua</code>).</li> </ul>"},{"location":"v3/lua/eventlog/#interaction-event","title":"Interaction event","text":"<p>The interaction event is fired, whenever one of the operator buttons is pressed on the GUI. The function signature is as follows:</p> <pre><code>EventLog.Write(INTERACTION, Request, User1, User2, Text, JobSeq, OpSeq, Field)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li> <p>Request: The actual request code, one of the following:</p> <ul> <li> <p>noReq (0x0000=: no request</p> </li> <li> <p>finishProcess (0x0001): finish assembly processing</p> </li> <li>clearProcess (0x0002): clear all tightening results on assembly go to first Job</li> <li>startJob (0x0004): start current Job (is available only in WorkflowState::WaitJobStart)</li> <li>finishJob (0x0008): finish current Job processing and set WorkflowState::WaitJobStart</li> <li>skipJob (0x0010): finish current Job processing and go to next Job</li> <li>clearJob (0x0020): clear all tightening results on current Job and set WorkflowState::WaitJobStart</li> <li>skipRundown (0x0040): set current operation to NOK and go to next operation</li> <li>clearBolt (0x0080): set current Bolt to NOT_PROCESSED</li> <li>startDiag (0x0100): enable start diagnostic job</li> <li>selectRundown (0x0200): select Job / Bolt in view or on image</li> <li>userLogon (0x0400): user logon</li> <li>pauseJob (0x0800): pause Job</li> <li>processNOK (0x1000): continue processing after NOK result</li> <li>CCW (0x2000): CCW</li> <li>manualInput (0x4000): manual input in start view (added for LUA trace log only)</li> <li>unmountJob (0x8000): unmount Job</li> <li>switchTool (0x10000): switch between alternative and standard tool</li> <li>teachToolPos (0x20000): enable teach mode for teaching a new tool position (only if positioning mode is enabled)</li> </ul> </li> <li> <p>Text: Usually empty, except for the <code>manualInput</code> request - in this case provides the actual manual input value.</p> </li> <li>JobSeq: Current job sequence</li> <li>OpSeq: Current task/operation sequence</li> <li>Field: Used for the <code>manualInput</code> request - has the field name for which data was entered.</li> </ul>"},{"location":"v3/lua/eventlog/#logon-event","title":"Logon event","text":"<p>The logon event is fired, whenever a user logs on or off. The function signature is as follows:</p> <pre><code>EventLog.Write(LOGON, Status, User1, User2, Text, Level)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li> <p>Status: Logon result status, one of the following values</p> <ul> <li>0 = Success (user is logged on)</li> <li>-1 = Username not found (unknown username or database connection error)</li> <li>-2 = Invalid password (or password check failed)</li> <li>-3 = No priviledges (user is known, password is correct, but missing rights for actual logon - might happen, if e.g. certification check or trainig checks fail for the user (or are outdated))</li> <li>1 = Logoff (user has successfully logged off)</li> <li>2 = Autologon (the autologon user is now logged on)</li> </ul> </li> <li> <p>Text: Depending on the status value one of the following</p> <ul> <li>'login': for successful user login.</li> <li>'autologon' for failed user autologon </li> <li>username in case of otherwise failed login attempts</li> </ul> </li> <li> <p>Level: Active user level (0 = nobody logged in, 1 = operator level, 2 = supervisor level, 3 = admin level)</p> </li> </ul>"},{"location":"v3/lua/eventlog/#alarm-event","title":"Alarm event","text":"<p>The alarm event is fired, whenever a new alarm is raised or if an alarm state changes. The function signature is as follows:</p> <pre><code>EventLog.Write(ALARM, Status, User1, User2, Text)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li>Status (int): Alarm level (0 = alarm cleared)</li> <li>Text (string): Alarm message</li> </ul>"},{"location":"v3/lua/eventlog/#workflow-event","title":"Workflow event","text":"<p>The workflow event is fired, whenever the workflow state changes. The function signature is as follows:</p> <pre><code>EventLog.Write(WORKFLOW, Status, User1, User2, Text)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li>Status (int): Type code</li> <li>Text (string): Descriptive message</li> </ul>"},{"location":"v3/lua/eventlog/#result-event","title":"Result event","text":"<p>The result event is fired, whenever the result state for the current tool operation changes. The function signature is as follows:</p> <pre><code>EventLog.Write(RESULT, Status, User1, User2, Text)\n</code></pre> <p>The following parameter values are provided:</p> <ul> <li>Status (int): Quality code of the result</li> <li>Text (string): currently not used</li> </ul>"},{"location":"v3/lua/eventlog/#sample-code","title":"Sample code","text":""},{"location":"v3/lua/eventlog/#write-events-to-a-logfile","title":"Write events to a logfile","text":"<p>A sample implementaion for logging all events to a file is provides in <code>heEventLog.lua</code> (in the lualib folder).</p>"},{"location":"v3/lua/eventlog/#send-events-over-mqtt","title":"Send events over MQTT","text":"<p>To send the events over MQTT, here is a snippet on how to convert the event data into a json message ready to be published over MQTT.</p> <p>The sample omits the MQTT boilerplate code and focuses on the Eventlog implementation (see luamqttclient for more info).</p> <p><pre><code>local mqtt = require('luamqttclient')\nlocal json = require('json')    \n\nlocal MqttTopic = 'mytopic/mysubtopic'      -- the MQTT event topic\n\n-- setup the global eventlog table\nEventLog = {\n}\n\n-- The init function called from OGS\nEventLog.Init = function()\n\n    --[[\n        initialize MQTT [omitted]\n    ]]\n\n    -- send a MQTT bootup message\n    local msg = json.encode({type=0,name='COMMON',status=0,text='OGS started'})        \n    MC:Publish(MqttTopic, 0, msg)\n\n    return true\nend\n\n-- The Stop function - send a MQTT shutdown message\nEventLog.Stop = function()\n    -- send a MQTT shutdown message\n    local msg = json.encode({type=0,name='COMMON',status=0,text='OGS shutdown'})        \n    MC:Publish(MqttTopic, 0, msg)\nend\n\n-- Define a event parameter/name mapping table\nEventLog.EvtParms = {   -- define custom tags names for the function parameters\n    [1] = { name='BARCODE',     'fieldno', 'user1', 'user2', 'code', 'source', 'tag' },\n    [2] = { name='INTERACTION', 'status', 'user1', 'user2', 'text', 'jobseq', 'opseq', 'field' },\n    [3] = { name='USER_LOGON',  'status', 'user1', 'user2', 'login', 'level' },\n    [4] = { name='ALARM',       'severity', 'user1', 'user2', 'message' },\n    [5] = { name='WORKFLOW',    'status', 'user1', 'user2', 'message', 'source', 'tag' },\n    [6] = { name='RESULT',      'status', 'user1', 'user2', 'code', 'source', 'tag' },\n    --[0] = { name='COMMON', 'type', 'status', 'text' },\n    --[7] = { name='SOFTWARE_ERROR', 'type', 'status', 'text' },\n}\n\n-- The Eventlog.Write function is called from OGS whenever a new event occurrs\nEventLog.Write = function (type, ...)\n    -- map the parameters/names depending on the event type\n    local params = EventLog.EvtParms[type]\n    local t = os.date('*t')\n    local res = {\n        type = type,\n        timestamp = string.format('%04d-%02d-%02d %02d:%02d:%02d',t.year,t.month,t.day,t.hour,t.min,t.sec),\n    }\n    res.name = params.name or 'UNKNOWN'\n    if params then\n        for i = 2,#arg do\n            res[params[i-1]] = arg[i-1]\n        end\n    end\n    -- publish over mqtt\n    local msg = json.encode(res)        \n    MC:Publish(MqttTopic, 0, msg)\nend\n</code></pre> Running this code then generates json messages like the following (login event):</p> <pre><code>{\n    \"type\":3,\n    \"timestamp\":\"2023-03-31 09:56:00\",\n    \"name\":\"USER_LOGON\",\n    \"status\":0,\n    \"user1\":\"U40003ACC4D\",\n    \"user2\":\"\",\n    \"login\":\"login\"\n}\n</code></pre>"},{"location":"v3/lua/webbrowser/","title":"Browser","text":""},{"location":"v3/lua/webbrowser/#overview","title":"Overview","text":"<p>The OGS runtime uses up to 4 web browser (Microsoft WebView2) instances. The instances are:</p> <ul> <li><code>StartView</code>: Browser on the start screen</li> <li><code>ProcessView</code>: Browser on the process screen (only visible, if the <code>url</code>-parameter in the job/task is set)</li> <li><code>SidePanel</code>: Browser on the slide-in side panel (requires enabling the sidepanel in <code>station.ini</code>)</li> <li><code>InstructionView</code>: Browser in the instruction view popup (is triggered from LUA, so only visible with custom LUA code)</li> </ul> <p>The OGS infrastructure provides functions to bidirectionally exchange data between the JavaScript code running inside the web browser and the LUA code running inside OGS. There is a LUA function to execute JavaScript code in the webbrowser and a JavaScript bridge, which calls a LUA function (if registered accordingly). To make things a bit easier, starting with OGS V3.0.8510, there is also a JavaScript helper object injected into the page.</p> <p>To implement this functionality, OGS provides the following:</p> <ul> <li>For the LUA side: a global <code>Browser</code> table with functions to manipulate the browser instances</li> <li>For the JavaScript side: <ul> <li>an injected JavaScript helper object, which provides easy to use functions to access the Bridge and send a message string</li> <li>the (lowlevel) JavaScript hostObjects bridge accessibal through the <code>hostObjects</code> interface of the Chromium browser (<code>window.chrome.webview.hostObjects.sync.&lt;instance&gt;</code>, with <code>instance</code> one of the above)</li> </ul> </li> </ul>"},{"location":"v3/lua/webbrowser/#injected-javascript-helper-object","title":"Injected JavaScript helper object","text":"<p>NOTE: Available starting with OGS V3.0.8510.</p> <p>OGS injects a JavaScript <code>OGS</code> object into the page after the \"NavigationComplete\" Event of the Edge Browser. This especially makes using the <code>Bridge</code> to send messages out to the OGS core easier (see JavaScript hostObjects bridge below for details) and also allows overriding some events. The <code>OGS</code>-object provides the following members:</p> <ul> <li><code>getBridgeName(): string</code>: Returns the bridge instance name (which is identical to the browser instance name, e.g. <code>'StartView'</code>).</li> <li><code>SendCmd(cmd: string): boolean</code>: send the <code>cmd</code> string  to the OGS core. The function returns <code>true</code>, if the string was sent correctly. If <code>false</code> is returned, the command was not sent. This usually happens during and shortly after page load (and even for a small time after DocumentComplete), as the Edge bridge host object needs some time to initialize. Best practice is to embed the <code>SendCmd()</code> into a timer started with window.onload() or in the body. An even better option is to implement the OGS.onInit() override (see sample below).</li> <li>event: <code>onInit(url: string)</code>: This function can be implemented on the JavaScript side to get notified when OGS is done loading the webpage (called after the <code>OnNavigateComplete</code>-Event of the Edge browser). This can(should) be used to have a reliable event on when the OGS-Communication is available.</li> <li>event: <code>onShow()</code>: This function can be implemented on the JavaScript side to get notified when the web browser gets visible to the user. This is especially useful for the <code>SidePanel</code> view, as the user can open/close the browser view without reloading the page.</li> <li>event: <code>onHide()</code>: This function can be implemented on the JavaScript side to get notified when the web browser gets visible to the user.</li> </ul> <p>Here is a sample on how to use the <code>OGS</code>-JavaScript helper oject to send a \"hello\"-message after the bridge gets ready:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html &gt;\n&lt;/html&gt;\n&lt;body&gt;\n&lt;!-- whatever content is in the page --&gt;\n&lt;/body&gt;\n\n&lt;script&gt;\n// Create the OGS object and implement the callbacks/events\nOGS = {};       \nOGS.onInit = function(url) {\n    console.log(\"OGS.onInit called: \", url, OGS);\n    // if we get here, everyhing is initialized, so now send the 'hello' message\n    OGS.SendCmd('hello!');\n}\nOGS.onShow = function OGS_onShow() {\n    console.log(\"OGS.onShow called!\");\n}\nOGS.onHide = function() {\n    console.log(\"OGS.onHide called!\");\n}\n&lt;/script&gt;\n</code></pre> <p>An alternative way (without using the OGS object) would be to poll until everything is ready:</p> <pre><code>// Send Hello after the bridge is ready\nfunction SendHello()\n    var timer = window.setInterval( () =&gt; {\n        if (OGS) {  // check, if the global OGS object exists\n            if (OGS.SendCmd('Hello')) {\n                // successfully send, remove the timer\n                clearInterval(timer);\n            }\n        }\n    }, 100);    // execute every 100ms until the bridge is ready\nend\nwindow.onload = function() {\n    SendHello();\n}\n</code></pre>"},{"location":"v3/lua/webbrowser/#javascript-hostobjects-bridge","title":"JavaScript hostObjects bridge","text":"<p>NOTE: Starting with OGS V3.0.8510, it is recommended to use the JavaScript hostObjects bridge (see previous section) instead. </p> <p>To allow interaction between the JavaScript code running in the Browser and the OGS core, OGS registers a hostObject in the WebView2 browser for the JavaScript side. The registered object is named identically to the browser instance, e.g. <code>StartView</code> and implements a single string property <code>ObjectMessage</code>.</p> <p>To send a string to OGS from JavaScript, simply assign a value to the <code>window.chrome.webview.hostObjects.sync.&lt;instance&gt;.ObjectMessage</code> property (<code>instance</code> is the name of the actual browser instance, e.g. <code>StartView</code>, <code>ProcessView</code>, ..., see above).</p> <p>NOTE: To use the bridge, one has to use the correct <code>&lt;instance&gt;</code>!</p>"},{"location":"v3/lua/webbrowser/#sample-code","title":"Sample code","text":"<pre><code>// send a command string to OGS - from the StartView instance\nfunction sendOgsCommand(cmd)\n{\n    if (!window.chrome || !window.chrome.webview\n     || !window.chrome.webview.hostObjects\n     || !window.chrome.webview.hostObjects.sync) {\n        // WebView2 is not yet fully initialized\n        return;     \n    }\n    let ogs = window.chrome.webview.hostObjects.sync.StartView;\n    if (ogs) {\n        ogs.ObjectMessage = cmd;    \n    }\n}\n</code></pre>"},{"location":"v3/lua/webbrowser/#global-browser-table","title":"Global Browser table","text":"<p>OGS exposes the browser instances through the global <code>Browser</code> object. The <code>Browser</code> object implements the following functions:</p> <ul> <li>Navigate: Load a new URL in the web browser</li> <li>ExecJS_nonblocking: Run javascript inside the web browser (asynchronously, not returning a value)</li> <li>RegMsgHandler: Register a LUA callback function to be called when the JavaScript side writes to the object message endpoint.</li> </ul>"},{"location":"v3/lua/webbrowser/#navigate","title":"Navigate","text":"<p>The <code>Browser.Navigate</code> function starts loading a new URL into the given browser instance.</p> <pre><code>Browser.Navigate(instance, url)\n</code></pre>"},{"location":"v3/lua/webbrowser/#parameters","title":"Parameters","text":"<ul> <li>instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') </li> <li>url [string]: Url to navigate the browser instance to (in the standard URL format, e.g. file://filename or https://server/page)</li> </ul>"},{"location":"v3/lua/webbrowser/#sample-code_1","title":"Sample code","text":"<pre><code>-- Navigate the StartView browser to https://www.my-url.com/mypage\nBrowser.Navigate('StartView', 'https://www.my-url.com/mypage')\n</code></pre>"},{"location":"v3/lua/webbrowser/#show","title":"Show","text":"<p>The <code>Browser.Show</code> function is similar to the <code>Browser.Navigate</code> function, but also ensures the webbrowser is actually visible. The actual behaviour depends on the view - e.g. for the <code>SidePanel</code> view, the side panel pops out. For the <code>ProcessView</code> view, this switches from the image-view to the web view.</p> <pre><code>local oldUrl = Browser.Show(instance, url)\n</code></pre>"},{"location":"v3/lua/webbrowser/#parameters_1","title":"Parameters","text":"<ul> <li>instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') </li> <li>url [string]: Url to navigate the browser instance to (in the standard URL format, e.g. file://filename or https://server/page)</li> </ul>"},{"location":"v3/lua/webbrowser/#return-value","title":"Return value","text":"<p>The function returns the \"current\" URL of the webbrowser (the URL before changing to the given one). This can be used to return to the previous URL after hiding the browser.</p>"},{"location":"v3/lua/webbrowser/#sample-code_2","title":"Sample code","text":"<pre><code>-- Make the SidePanel visible and navigate the\n-- web browser to https://www.my-url.com/mypage\nlocal oldUrl = Browser.Show('SidePanel', 'https://www.my-url.com/mypage')\n</code></pre>"},{"location":"v3/lua/webbrowser/#hide","title":"Hide","text":"<p>The <code>Browser.Hide</code> function is complementary to the <code>Browser.Show</code> function - it closes the browser view (only relevant for <code>SidePanel</code> and <code>ProcessView</code>).</p> <pre><code>Browser.Hide(instance)\n</code></pre>"},{"location":"v3/lua/webbrowser/#parameters_2","title":"Parameters","text":"<ul> <li>instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') </li> </ul>"},{"location":"v3/lua/webbrowser/#sample-code_3","title":"Sample code","text":"<pre><code>-- Hide the SidePanel\nBrowser.Hide('SidePanel')\n</code></pre>"},{"location":"v3/lua/webbrowser/#regmsghandler","title":"RegMsgHandler","text":"<p>The <code>Browser.RegMsgHandler</code> function registers or unregisters a LUA function to be called whenever the JavaScript running in the browser writes a message to the hostObject bridge <code>OGS.ObjectMessage</code> property.</p> <p>NOTE: Calling the function mutliple times with the same url parameter  will replace a previously registered handler for the same url.</p>"},{"location":"v3/lua/webbrowser/#function-signature","title":"Function signature","text":"<pre><code>-- Register the callback function\nfn, err = Browser.RegMsgHandler(instance, callbackfn, url)\n</code></pre>"},{"location":"v3/lua/webbrowser/#parameters_3","title":"Parameters","text":"<ul> <li> <p>instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') </p> </li> <li> <p>callbackfn [function]: LUA function to be called when the JavaScript code writes a string to the <code>OGS.ObjectMessage</code> hostObject. If callbackfn is <code>nil</code>, then the current registration is removed. The callback function has the following signature:</p> <pre><code>callbackfn(instance, objectMessage)\n</code></pre> <p><code>instance</code> [string] is the web browsers instance name (e.g. 'StartView') and <code>objectMessage</code> [string] the text which was written to the <code>OGS.ObjectMessage</code> property of the hostObject bridge from the JavaScript side.</p> </li> <li> <p>url [string or nil]: The optional <code>url</code> parameter allows registering seperate message handlers for different URLs shown in the browser. This is especially handy for the <code>SidePanel</code> view, where typically different pages are viewed (see Browser.show(...url...) above). If the <code>url</code> parameter is missing (on nil), then the handler is registered globally (for the given browser instance).</p> </li> </ul>"},{"location":"v3/lua/webbrowser/#return-values","title":"Return values","text":"<p>If the function was executed successfully, the callbackfn is returned as the first return value. Else nil is returned and the second return value has an error message string (wrong parameters or unknown instance).</p>"},{"location":"v3/lua/webbrowser/#sample-code_4","title":"Sample code","text":"<pre><code>local function callbackfn(instance, objectMessage)\n    -- do whatever you want to do here if the javascript \n    -- code writes the OGS.ObjectMessage property\nend\n\n-- Register a LUA function to be called from the JavaScript side\nBrowser.RegMsgHandler('StartView', callbackfn)\n</code></pre>"},{"location":"v3/lua/webbrowser/#execjs_nonblocking","title":"ExecJS_nonblocking","text":"<p>The <code>Browser.ExecJS_nonblocking</code> executes JavaScript code in the web browser instance.</p> <pre><code>Browser.ExecJS_nonblocking(instance, jstext)\n</code></pre>"},{"location":"v3/lua/webbrowser/#parameters_4","title":"Parameters","text":"<ul> <li>instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') </li> <li>jstext [string]: JavaScript string to execute in the browser. Note that this must be valid JavaScript code. </li> </ul> <p>NOTES: </p> <ul> <li>When passing strings through the function, make sure to properly escape them!</li> <li>Best practice is to write a JavaScript function in the web page and only call it through this function.</li> <li>You can serialize LUA objects to a JSON string and pass this through the function. The JavaScript side can then easily deserialize it.</li> <li>You can only call Javascript functions defined in the global scope from the LUA/OGS side. Make sure to either register them in a global object (e.g. add them to the OGS object (best), to window or to globalThis) .</li> </ul>"},{"location":"v3/lua/webbrowser/#sample-code_5","title":"Sample code","text":"<p>LUA side:</p> <pre><code>-- define which browser view to use\nlocal instance = 'StartView'\n\n-- define a function to be called from JavaScript\nlocal callbackfn = function(instance, msg)\n    XTRACE(16, \"I am called from Javascript: msg=\" .. msg)\nend\n\n-- Register (global) callback for the browser instance\nBrowser.RegMsgHandler(instance, callbackfn)\n\n-- Build a JavaScript command, call the function \"OGS.myFunction\" with\n-- some JSON text\nlocal param = '{ \"cmd\": \"showmessage\" }'\nlocal command = \"OGS.myFunction(\"..param..\");\"\n-- Call the JavaScript function in the browser instance\nBrowser.ExecJS_nonblocking(instance, command)\n</code></pre> <p>Javascript side (for the StartView browser window):</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html &gt;\n&lt;/html&gt;\n&lt;body&gt;\n&lt;!-- whatever content is in the page --&gt;\n&lt;/body&gt;\n\n&lt;script&gt;\n// Create the OGS object and implement the callbacks/events\nOGS = {};       \nOGS.onInit = function(url) {\n    // if we get here, everyhing is initialized, so now send the 'hello' message\n    OGS.SendCmd('hello!');\n}\nOGS.myFunction = function(params) {\n    // This function was called from LUA code\n    console.log(\"OGS.myFunction called!\", params);\n    // Now call back into OGS and return a complex object\n    var retval = { cmd: 'test', params: { p1: 1, p2: 'string' } };\n    OGS.SendCmd(JSON.stringify(retval));\n}\n&lt;/script&gt;\n</code></pre>"},{"location":"v3/lua/webserver/","title":"Webserver","text":""},{"location":"v3/lua/webserver/#overview","title":"Overview","text":"<p>The OGS runtime uses the Microsoft Windows builtin http.sys web server to server static pages and dynamic pages. The dynamic pages are implemented through LUA scripting and makes it possible to flexibly implement web services like OpenAPI / REST services or others.</p> <p>A typical use case is to provide a REST interface for third-party systems to connect them to OGS, another is to implement backend logic for a single page application web page frontend running inside OGS (see also OGS Webbrowser LUA interface).</p> <p>The web server LUA api works by registering LUA callback functions for specific URL prefixes, which are then called by the web server, whenever the given URL is requested from a web client.</p>"},{"location":"v3/lua/webserver/#prerequisites","title":"Prerequisites","text":"<p>To use the LUA web server API, the web server must be enabled through <code>station.ini</code> (in the <code>[WebServer]</code> section) and the Microsoft <code>http.sys</code> web server must be configured accordingly (a URL reservation must be activated through the <code>netsh http add urlacl ...</code> command).</p> <p>By default the, installer registers a web endpoint at http://localhost:59990, so the endpoint is only accessible from the local machine and only for a locally logged on user.</p> <p>To access the web server from the outside, make sure to change the listen address in the <code>station.ini</code> file, the URL reservation through <code>netsh http ...</code> and check the firewall settings. </p>"},{"location":"v3/lua/webserver/#global-webserver-table","title":"Global Webserver table","text":"<p>OGS exposes the web server through the global <code>Webserver</code> object. The <code>Webserver</code> object implements the following functions:</p> <ul> <li>RegUrl: Register a LUA callback function to be called when a specific URL prefix is requested from the web server.</li> </ul>"},{"location":"v3/lua/webserver/#regurl","title":"RegUrl","text":"<p>The <code>Webserver.RegUrl</code> function registers or unregisters a LUA function to be called whenever the web server receives a request to the given URL prefix.</p> <pre><code>fn, err = Webserver.RegUrl(prefix, callbackfn)\n</code></pre>"},{"location":"v3/lua/webserver/#parameters","title":"Parameters","text":"<ul> <li>prefix [string]: Path prefix to match against when checking the request URL. Note that this only checks for the path part of the URL (e.g. '/home'). </li> <li> <p>callbackfn [function]: LUA function to be called when a web request matches the prefix. The callback function has the following signature:</p> <pre><code>table = callbackfn(reqpath, reqparams, verb, body)\n</code></pre> <p>Where reqpath [string] is the full request path, (e.g. '/api/items'), reqparams [string] the request parameters (e.g. '?max=10&amp;class=5'), verb [integer] the request type (GET, PUT, POST, DELETE) and body [string] the body (binaty) string value (only for POST and PUT).</p> <p>The callback function should return a response table with the required parameters to build the http response (optional body).</p> <p>[Datails tbd.]</p> </li> </ul>"},{"location":"v3/lua/webserver/#return-values","title":"Return values","text":"<p>If the function was executed successfully, the callbackfn is returned as the first return value. Else nil is returned and the second return value has an error message string (wrong parameters or unknown instance).</p>"},{"location":"v3/lua/webserver/#sample-code","title":"Sample code","text":"<pre><code>local function handlerfn(reqpath, reqparams, verb, body)\n    -- process the request, return the response object (or nil\n    -- if this request is not handled) \n    return nil\nend\n-- Register a LUA function to be called whenever a web request to /api/lua\n-- is made\nBrowser.RegMsgHandler('/api/lua', handlerfn)\n</code></pre>"}]}