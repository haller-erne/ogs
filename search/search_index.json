{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OGS - Operator guidance system","text":""},{"location":"#scope","title":"Scope","text":"<p>This documentation provides low-level infomation about the OGS software.  The main purpose is to document the API interfaces (mostly LUA scripting), the available (tool)drivers and show how everything fits together.  This allows advanced users and implementors to unlock the full potential  of OGS by modifying and extending the software.</p> <p>NOTE: This documentation is valid for OGS V3. As V3 is not yet released, some of the information might still change before the final release.</p>"},{"location":"#overview","title":"Overview","text":"<p>The documentation currently has the following information:</p> <ul> <li>Tool driver and tool configuration information (see Tool configuration)</li> <li>LUA scripting (see LUA scripting)</li> <li>LUA helper libraries (see LUA libraries)</li> </ul>"},{"location":"libs/_template_/","title":"Ability","text":"<p>Abilities are CoreObjects that can be added to Players and guide the Player's animation in sync with the Ability's state machine. Spawn an Ability with <code>World.SpawnAsset()</code> or add an Ability as a child of an Equipment/Weapon to have it be assigned to the Player automatically when that item is equipped.</p> <p>Abilities can be activated by association with an Action Binding. Their internal state machine flows through the phases: Ready, Cast, Execute, Recovery, and Cooldown. An Ability begins in the Ready state and transitions to Cast when its Binding (for example Left mouse click) is activated by the owning player. It then automatically flows from Cast to Execute, then Recovery and finally Cooldown. At each of these state transitions it fires a corresponding event.</p> <p>Only one ability can be active at a time. By default, activating an ability will interrupt the currently active ability. The <code>canBePrevented</code> and <code>preventsOtherAbilities</code> properties can be used to customize interruption rules for competing abilities.</p> <p>If an ability is interrupted during the Cast phase, it will immediately reset to the Ready state. If an ability is interrupted during the Execute or Recovery phase, the ability will immediately transition to the Cooldown phase.</p>","tags":["API"]},{"location":"libs/_template_/#properties","title":"Properties","text":"Property Name Return Type Description Tags <code>isEnabled</code> <code>boolean</code> Turns an Ability on/off. It stays on the Player but is interrupted if <code>isEnabled</code> is set to <code>false</code> during an active Ability. True by default. Read-Write <code>canActivateWhileDead</code> <code>boolean</code> Indicates if the Ability can be used while the owning Player is dead. False by default. Read-Only <code>name</code> <code>string</code> The name of the Ability. Read-Only <code>actionBinding</code> <code>string</code> This property is deprecated. Please use <code>actionName</code> instead, but note that <code>actionBinding</code> and <code>actionName</code> use different values.  Which action binding will cause the Ability to activate. Possible values of the bindings are listed on the Ability binding page. Read-Only, Deprecated <code>actionName</code> <code>string</code> Which binding set action name will cause the Ability to activate. See Binding Sets reference. Read-Only <code>owner</code> <code>Player</code> Assigning an owner applies the Ability to that Player. Read-Write <code>castPhaseSettings</code> <code>AbilityPhaseSettings</code> Config data for the Cast phase (see below). Read-Only <code>executePhaseSettings</code> <code>AbilityPhaseSettings</code> Config data for the Execute phase. Read-Only <code>recoveryPhaseSettings</code> <code>AbilityPhaseSettings</code> Config data for the Recovery phase. Read-Only <code>cooldownPhaseSettings</code> <code>AbilityPhaseSettings</code> Config data for the Cooldown phase. Read-Only <code>animation</code> <code>string</code> Name of the animation the Player will play when the Ability is activated. Possible values: See Ability Animation for strings and other info. Read-Only <code>canBePrevented</code> <code>boolean</code> Used in conjunction with the phase property <code>preventsOtherAbilities</code> so multiple abilities on the same Player can block each other during specific phases. True by default. Read-Only","tags":["API"]},{"location":"libs/_template_/#functions","title":"Functions","text":"Function Name Return Type Description Tags <code>Activate()</code> <code>None</code> Activates an Ability as if the button had been pressed. None <code>Interrupt()</code> <code>None</code> Changes an Ability from Cast phase to Ready phase. If the Ability is in either Execute or Recovery phases it instead goes to Cooldown phase. None <code>AdvancePhase()</code> <code>None</code> Advances a currently active Ability from its current phase to the next phase. For example, an ability in the Cast phase will begin the Execute phase, an ability on cooldown will become ready, etc. None <code>GetCurrentPhase()</code> <code>AbilityPhase</code> The current AbilityPhase for this Ability. These are returned as one of: AbilityPhase.READY, AbilityPhase.CAST, AbilityPhase.EXECUTE, AbilityPhase.RECOVERY and AbilityPhase.COOLDOWN. None <code>GetCurrentPhaseSettings()</code> <code>AbilityPhaseSettings</code> Returns the settings for the current phase of this Ability. Returns <code>nil</code> if the current phase is <code>AbilityPhase.READY</code>. None <code>GetPhaseTimeRemaining()</code> <code>number</code> Seconds left in the current phase. None <code>GetTargetData()</code> <code>AbilityTarget</code> Returns information about what the Player has targeted this phase. None <code>SetTargetData(AbilityTarget)</code> <code>None</code> Updates information about what the Player has targeted this phase. This can affect the execution of the Ability. None","tags":["API"]},{"location":"libs/_template_/#events","title":"Events","text":"Event Name Return Type Description Tags <code>readyEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability becomes ready. In this phase it is possible to activate it again. None <code>castEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability enters the Cast phase. None <code>executeEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability enters Execute phase. None <code>recoveryEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability enters Recovery. None <code>cooldownEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability enters Cooldown. None <code>interruptedEvent</code> <code>Event</code>&lt;<code>Ability</code>&gt; Fired when the Ability is interrupted. None <code>tickEvent</code> <code>Event</code>&lt;<code>Ability</code> ability, <code>number</code> deltaTime&gt; Fired every tick while the Ability is active (isEnabled = true and phase is not ready). None","tags":["API"]},{"location":"libs/_template_/#examples","title":"Examples","text":"<p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#castevent","title":"<code>castEvent</code>","text":"<p>The Cast phase begins as soon as an ability is activated. By checking if the player casting the ability <code>isGrounded</code> we can create an effect that propels you upwards, but it doesn't work if you are already jumping or flying. We detect this is the <code>castEvent</code>, which is early enough for an <code>Interrupt()</code> to reset the ability.</p> <pre><code>--Server script\nlocal ability = script.parent\n\nfunction OnCast(ability)\n    if ability.owner.isGrounded then\n        ability.owner:SetVelocity(Vector3.UP * 2000)\n    else\n        ability:Interrupt()\n    end\nend\n\nability.castEvent:Connect(OnCast)\n</code></pre> <p>See also: CoreObject.parent | Ability.owner | Player.isGrounded | Vector3.UP | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#cooldownevent","title":"<code>cooldownEvent</code>","text":"<p>In this example, a fighting game has an \"invincible\" mechanic where player attacks are not interrupted while they have this effect. Some powerful attacks make the player invincible during the entire active cycle of the ability. The effect is gained at the beginning of the cast phase and is removed at the end of the recovery phase, before the cooldown begins. The resource system is used in keeping track of the invincibility effect.</p> <pre><code>--Server script\nlocal ability = script.parent\n\nfunction OnCast(ability)\n    ability.owner:AddResource(\"invincible\", 1)\nend\n\nfunction OnCooldown(ability)\n    ability.owner:RemoveResource(\"invincible\", 1)\nend\n\nability.castEvent:Connect(OnCast)\nability.cooldownEvent:Connect(OnCooldown)\n</code></pre> <p>See also: CoreObject.parent | Player.owner | Ability.castEvent | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#executeevent","title":"<code>executeEvent</code>","text":"<p>Weapons implement lots of built-in gameplay that doesn't require any scripting, such as attack and reload abilities. However, they can be augmented with additional mechanics. In this example, a special sound effect is played when a weapon shoots while low on ammunition. The script expects to be a child of a weapon's \"Shoot\" ability.</p> <pre><code>--Server script\nlocal ability = script.parent\nlocal weapon = script:FindAncestorByType('Weapon')\nlocal lowAmmoSound = script:GetCustomProperty(\"LowAmmoSound\")\n\nlocal LOW_AMMO_PERCENTAGE = 0.2\n\nfunction OnExecute(ability)\n    if weapon.currentAmmo / weapon.maxAmmo &lt;= LOW_AMMO_PERCENTAGE then\n        World.SpawnAsset(lowAmmoSound, {position = weapon:GetWorldPosition()})\n    end\nend\n\nability.executeEvent:Connect(OnExecute)\n</code></pre> <p>See also: CoreObject.parent | Weapon.currentAmmo | World.SpawnAsset | Ability.executeEvent | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#interruptedevent","title":"<code>interruptedEvent</code>","text":"<p>The <code>interruptedEvent</code> fires when an ability is going through it's activation process and <code>Interrupt()</code> is called on it, or if it becomes disabled. In this example, interruption is a key part of the game design, so a visual effect is spawned at the player's position to help communicate the interaction between players.</p> <pre><code>--Server script\nlocal ability = script.parent\nlocal interruptedVfx = script:GetCustomProperty(\"InterruptedVfx\")\n\nfunction OnInterrupted(ability)\n    if Object.IsValid(ability.owner) then\n        World.SpawnAsset(interruptedVfx, {position = ability.owner:GetWorldPosition()})\n    end\nend\n\nability.interruptedEvent:Connect(OnInterrupted)\n</code></pre> <p>See also: CoreObject.parent | Object.IsValid | Ability.owner | World.SpawnAsset | Player.GetWorldPosition | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#readyevent","title":"<code>readyEvent</code>","text":"<p>The Ready phase begins when an ability comes off cooldown and is \"ready\" to be used again. In this example, we create an invisibility effect that takes advantage of the <code>readyEvent</code>, leveraging the cooldown duration of the ability as a clock to determine when to make the player visible again.</p> <pre><code>-- Server script\nlocal ability = script.parent\n\nfunction OnExecute(ability)\n    -- Hide the player\n    ability.owner:SetVisibility(false)\nend\n\nfunction OnReady(ability)\n    -- Show the player\n    ability.owner:SetVisibility(true)\nend\n\nability.readyEvent:Connect(OnReady)\nability.executeEvent:Connect(OnExecute)\n</code></pre> <p>See also: CoreObject.parent | Ability.owner | Player.SetVisibility | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#recoveryevent","title":"<code>recoveryEvent</code>","text":"<p>The <code>recoveryEvent</code> marks the end of an ability's Execute phase and the beginning of its Recovery phase. In this example, a melee punch ability has a trigger that causes damage to enemies who overlap it. For it to work the trigger is only enabled for a brief moment, during the Execute phase.</p> <pre><code>--Server script\nlocal ability = script.parent\nlocal trigger = script:GetCustomProperty(\"ImpactTrigger\"):WaitForObject()\ntrigger.collision = Collision.FORCE_OFF\n\nlocal DAMAGE_AMOUNT = 10\n\nfunction OnExecute(ability)\n    trigger.collision = Collision.FORCE_ON\nend\n\nfunction OnRecovery(ability)\n    trigger.collision = Collision.FORCE_OFF\nend\n\nability.executeEvent:Connect(OnExecute)\nability.recoveryEvent:Connect(OnRecovery)\n\nfunction OnBeginOverlap(trigger, other)\n    -- Only damage enemy players\n    if other:IsA(\"Player\") and other.team ~= ability.owner.team then\n        other:ApplyDamage(Damage.New(DAMAGE_AMOUNT))\n    end\nend\n\ntrigger.beginOverlapEvent:Connect(OnBeginOverlap)\n</code></pre> <p>See also: CoreObject.parent | CoreObjectReference.WaitForObject | Ability.executeEvent | Event.Connect | other.IsA | Player.team | Damage.New | Trigger.beginOverlapEvent</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#tickevent","title":"<code>tickEvent</code>","text":"<p>Abilities fire the <code>tickEvent</code> while they are active or on cooldown (not on Ready state). In this example, a piece of equipment carries several abilities, but we want to do a common update logic on all of them. Note: <code>Ability.tickEvent</code> works somewhat differently from a <code>Tick()</code> function - <code>tickEvent</code> is an actual event that just happens to fire once per tick. Each invocation of the callback runs on its own task. This means that, unlike <code>Tick()</code>, there is no guarantee that it will wait for the previous <code>tickEvent</code> to finish before starting the next one. This means you can't use things like <code>Task.Wait()</code> to add time between ticks.</p> <pre><code>local equipment = script.parent\nlocal allAbilities = equipment:GetAbilities()\n\nfunction OnTick(ability, deltaTime)\n    print(\"Updating ability \" .. ability.name)\nend\n\nfor _, ability in ipairs(allAbilities) do\n    ability.tickEvent:Connect(OnTick)\nend\n</code></pre> <p>See also: CoreObject.parent | Equipment.GetAbilities | Event.Connect | CoreLua.print</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#activate","title":"<code>Activate</code>","text":"<p>The Ability <code>Activate()</code> function behaves as if the player had pressed the key binding. In order for a server gameplay decision to result in an ability activation, it must be communicated over the network somehow. In this example, a trigger overlap is representative of an arbitrary gameplay decision on the server. A broadcast message is sent to the client, who receives the event and activates the ability.</p> <pre><code>--Server script\nlocal trigger = script.parent\nlocal function OnBeginOverlap(trigger, other)\n    if other:IsA(\"Player\") then\n        Events.BroadcastToPlayer(other, \"SteppedOnObject\")\n    end\nend\n\ntrigger.beginOverlapEvent(OnBeginOverlap)\n\n--[[#description\n    Client context script under the ability:\n]]\nlocal ability = script:FindAncestorByType(\"Ability\")\n\nfunction OnPlayAnimation()\n    if ability.owner and ability.owner == Game.GetLocalPlayer() then\n        ability:Activate()\n    end\nend\n\nEvents.Connect(\"SteppedOnObject\", OnPlayAnimation)\n</code></pre> <p>See also: CoreObject.parent | Trigger.beginOverlapEvent | other.IsA | Events.BroadcastToPlayer | Ability.owner | Game.GetLocalPlayer()</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#advancephase","title":"<code>AdvancePhase</code>","text":"","tags":["API"]},{"location":"libs/_template_/#getcurrentphase","title":"<code>GetCurrentPhase</code>","text":"<p>In this example an ability is on cooldown, but can be set back to <code>Ready</code> by calling <code>AdvancePhase()</code>.</p> <pre><code>function EndAbilityCooldown(ability)\n    if ability:GetCurrentPhase() == AbilityPhase.COOLDOWN then\n        ability:AdvancePhase()\n    end\nend\n</code></pre> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#getcurrentphase_1","title":"<code>GetCurrentPhase</code>","text":"","tags":["API"]},{"location":"libs/_template_/#getphasetimeremaining","title":"<code>GetPhaseTimeRemaining</code>","text":"<p>In this example, while the ability is on cooldown, the percentage completion of the cooldown is calculated. This could be useful, for instance, in displaying user interface.</p> <pre><code>local ability = script:FindAncestorByType(\"Ability\")\n\nfunction Tick()\n    if ability:GetCurrentPhase() == AbilityPhase.COOLDOWN then\n        local duration = ability.cooldownPhaseSettings.duration\n        local remaining = ability:GetPhaseTimeRemaining()\n        local percent = 100 * (1 - remaining / duration)\n\n        print(\"Cooldown remaining: %\" .. string.format(\"%.2f\",percent))\n    end\nend\n</code></pre> <p>See also: CoreObject.FindAncestorByType | Ability.GetCurrentPhase | AbilityPhaseSettings.duration | CoreLua.print</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#gettargetdata","title":"<code>GetTargetData</code>","text":"","tags":["API"]},{"location":"libs/_template_/#settargetdata","title":"<code>SetTargetData</code>","text":"<p>The ability's targeting data gives a lot of information about where and what the player is aiming at. If setup correctly, it can also be modified programmatically. In this example, the Z position of the target is flattened horizontally. Useful, for example, in a top-down shooter. For this to work it should be placed in a client context under the ability. The ability should also have the option \"Is Target Data Update\" turned off for the Execute phase, otherwise any data set programmatically will be overwritten when the phase changes.</p> <pre><code>--Server script\nlocal ability = script:FindAncestorByType(\"Ability\")\n\nfunction OnCast(ability)\n    local abilityTarget = ability:GetTargetData()\n    local pos = abilityTarget:GetHitPosition()\n\n    pos.z = ability.owner:GetWorldPosition().z + 50\n\n    abilityTarget:SetHitPosition(pos)\n    ability:SetTargetData(abilityTarget)\nend\n\nability.castEvent:Connect(OnCast)\n</code></pre> <p>See also: CoreObject.FindAncestorByType | AbilityTarget.GetHitPosition | Ability.owner | Player.GetWorldPosition | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#interrupt","title":"<code>Interrupt</code>","text":"<p>Interrupting an ability either sends it back into ready state (if it was still in the Cast phase) or puts it on cooldown. In this example, we have an ability that searches for all enemies in a 10 meter radius and interrupts their abilities.</p> <pre><code>--Server script\nlocal ability = script.parent\nlocal RADIUS = 1000 -- 10 meters\n\nfunction OnExecute(ability)\n    local center = ability.owner:GetWorldPosition()\n    -- Search for enemies\n    local enemies = Game.FindPlayersInCylinder(center, RADIUS, {ignoreTeams = ability.owner.team})\n    for _, enemy in ipairs(enemies) do\n        -- Interrupt all their abilities\n        local enemyAbilities = enemy:GetAbilities()\n        for _,a in ipairs(enemyAbilities) do\n            a:Interrupt()\n        end\n    end\nend\n\nability.executeEvent:Connect(OnExecute)\n</code></pre> <p>See also: CoreObject.parent | Ability.owner | Player.GetWorldPosition | Game.FindPlayersInCylinder | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#actionname","title":"<code>actionName</code>","text":"<p>Even though some API properties are read-only, they are useful is solutions such as user interface. In this example, a client context script searches the local player's list of abilities to find one that matches the action name (input) designated for this UI component. When it's found, the ability's name is written to the UI Text object.</p> <pre><code>--Client script\nlocal ACTION_NAME = script:GetCustomProperty(\"ActionName\")\nlocal NAME_UI = script:GetCustomProperty(\"NameUIText\"):WaitForObject()\n\nfunction GetLocalPlayerAbilityWithActionName()\n    local player = Game.GetLocalPlayer()\n    local abilities = player:GetAbilities()\n\n    for _, ability in pairs(abilities) do\n        if ability.actionName == ACTION_NAME then\n            return ability\n        end\n    end\n\n    return nil\nend\n\nfunction Tick()\n    local ability = GetLocalPlayerAbilityWithActionName()\n    if ability then\n        NAME_UI.text = ability.name\n    end\nend\n</code></pre> <p>See also: CoreObject.name | CoreObjectReference.WaitForObject | Game.GetLocalPlayer | Player.GetAbilities | UIText.text</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#animation","title":"<code>animation</code>","text":"<p>In this example, the <code>ProcessAbilities()</code> function can be called once, such as at the beginning of a round, to take inventory of a player's abilities and classify them based on animation. This example also demonstrates how to disconnect event listeners so that we don't listen for the same event multiple times.</p> <pre><code>--Server script\nfunction OnMelee1HandCast(ability)\n    print(\"One-handed melee attack\")\nend\n\nfunction OnMelee2HandCast(ability)\n    print(\"Two-handed melee attack\")\nend\n\nlocal abilityEventListeners = {}\n\nfunction CleanupListeners(player)\n    -- If we have previously processed this player, cleanup all listeners\n    if abilityEventListeners[player] then\n        for i, eventListener in ipairs(abilityEventListeners[player]) do\n            eventListener:Disconnect()\n        end\n        abilityEventListeners[player] = nil\n    end\nend\n\nfunction ProcessAbilities(player)\n    CleanupListeners(player)\n\n    local allAbilities = player:GetAbilities()\n\n    for _, ability in ipairs(allAbilities) do\n        if string.match(ability.animation, \"melee\") then\n            local eventListener\n            if string.match(ability.animation, \"1h\") then\n                eventListener = ability.castEvent:Connect(OnMelee1HandCast)\n            else\n                eventListener = ability.castEvent:Connect(OnMelee2HandCast)\n            end\n            table.insert(abilityEventListeners[player], eventListener)\n        end\n    end\nend\n\n-- Lets also cleanup when a player leaves the game, as perhaps their ability objects might stay in the game.\nGame.playerLeftEvent:Connect(CleanupListeners)\n</code></pre> <p>See also: EventListener.Disconnect | Player.GetAbilities | Ability.castEvent | Event.Connect | Game.playerLeftEvent | CoreLua.print</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#canactivatewhiledead","title":"<code>canActivateWhileDead</code>","text":"<p>Some games may have abilities that can be used while the player is dead. In this example, we have abilities that can only be activated while dead. If not dead, then it's interrupted.</p> <pre><code>--Server script\nlocal ability = script:FindAncestorByType(\"Ability\")\n\nfunction OnCast(ability)\n    if ability.canActivateWhileDead and not ability.owner.isDead then\n        ability:Interrupt()\n    end\nend\n\nability.castEvent:Connect(OnCast)\n\n--[[#description\n    On the client context, a user interface component that displays ability details is hidden until the player dies:\n]]\nlocal abilityCanvas = script:GetCustomProperty(\"Canvas\")\nlocal ACTION_NAME = script:GetCustomProperty(\"ActionName\")\n\nfunction Tick(deltaTime)\n    local ability = GetLocalPlayerAbilityWithActionName()\n\n    if ability\n    and ability.isEnabled\n    and ability.canActivateWhileDead\n    and ability.owner\n    and ability.owner.isDead then\n\n        abilityCanvas.visibility = Visibility.INHERIT\n    else\n        abilityCanvas.visibility = Visibility.FORCE_OFF\n    end\nend\n\n-- Searches the local player's abilities until one with a matching action name is found\n-- The ACTION_NAME search criteria should be set in the custom property\nfunction GetLocalPlayerAbilityWithActionName()\n    local abilities = Game.GetLocalPlayer():GetAbilities()\n    for _, ability in pairs(abilities) do\n        if ability.actionName == ACTION_NAME then\n            return ability\n        end\n    end\n\n    return nil\nend\n</code></pre> <p>See also: CoreObject.FindAncestorByType | Ability.owner | Player.isDead | Event.Connect | CoreLua.Tick</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#canbeprevented","title":"<code>canBePrevented</code>","text":"<p>In this example, an ability recognizes that it has been interrupted by the activation of another, special ability, that is setup to serve for animation cancelling. The <code>canBePrevented</code> property is usually true in this game, but in this special case it has been configured as false so that it can be activated at any time. The player gains vertical impulse as result of the synergy and hears a small audio cue that helps communicate the mechanic.</p> <pre><code>--Server script\nlocal ability = script.parent\nlocal cancelSound = script:GetCustomProperty(\"CancelSound\")\n\nfunction OnInterrupted(ability)\n    local player = ability.owner\n    if not Object.IsValid(player) then return end\n\n    for _, a in ipairs(player:GetAbilities()) do\n        if a:GetCurrentPhase() ~= AbilityPhase.READY and not a.canBePrevented then\n            player:AddImpulse(Vector3.UP * 1000)\n            World.SpawnAsset(cancelSound, {position = player:GetWorldPosition()})\n            return\n        end\n    end\nend\n\nability.interruptedEvent:Connect(OnInterrupted)\n</code></pre> <p>See also: CoreObject.parent | Ability.owner | Object.IsValid | Player.GetAbilities | Vector3.UP | World.SpawnAsset | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#castphasesettings","title":"<code>castPhaseSettings</code>","text":"","tags":["API"]},{"location":"libs/_template_/#executephasesettings","title":"<code>executePhaseSettings</code>","text":"","tags":["API"]},{"location":"libs/_template_/#recoveryphasesettings","title":"<code>recoveryPhaseSettings</code>","text":"","tags":["API"]},{"location":"libs/_template_/#cooldownphasesettings","title":"<code>cooldownPhaseSettings</code>","text":"<p>In this example, a function in a client context script can be called to show the elapsed times for an ability. The UI Text it controls displays how many seconds are remaining in the current phase, and the color of the text blends from black to white to indicate the percentage of completion. Although the Execute and Recovery phases are actually separate, they are here presented to the player as a single phase.</p> <pre><code>--Client script\nlocal COUNTDOWN_TEXT = script:GetCustomProperty(\"CountdownText\"):WaitForObject()\n\nfunction UpdateForAbility(ability)\n    local currentPhase = ability:GetCurrentPhase()\n\n    local percent = 1\n    local cooldownText = \"Ready\"\n\n    if currentPhase ~= AbilityPhase.READY then\n        local phaseDuration\n        local timeRemaining = ability:GetPhaseTimeRemaining()\n\n        if currentPhase == AbilityPhase.CAST then\n            phaseDuration = ability.castPhaseSettings.duration\n        elseif currentPhase == AbilityPhase.EXECUTE then\n            -- In the case of Execute and Recovery phases, we can show those as a single one\n            local recoveryD = ability.recoveryPhaseSettings.duration\n            phaseDuration = ability.executePhaseSettings.duration + recoveryD\n            timeRemaining = timeRemaining + recoveryD\n        elseif currentPhase == AbilityPhase.RECOVERY then\n            phaseDuration = ability.recoveryPhaseSettings.duration\n        else --currentPhase == AbilityPhase.COOLDOWN\n            phaseDuration = ability.cooldownPhaseSettings.duration\n        end\n\n        if phaseDuration &gt; 0 then\n            percent = 1 - timeRemaining / phaseDuration\n        end\n        cooldownText = string.format(\"%.1f\", timeRemaining)\n    end\n\n    COUNTDOWN_TEXT.text = cooldownText\n\n    local c = Color.Lerp(Color.BLACK, Color.WHITE, percent)\n    COUNTDOWN_TEXT:SetColor(c)\nend\n</code></pre> <p>See also: CoreObject.GetCustomProperty | CoreObjectReference.WaitForObject | Ability.GetCurrentPhase | AbilityPhaseSettings.duration | UIText.text | Color.Lerp</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#isenabled","title":"<code>isEnabled</code>","text":"<p>In this example, an equipment is setup with multiple abilities that all use the same action binding. This script cycles through the abilities, making sure only one is enabled at a time. The <code>owner</code> property is cleared for the previous ability and set for the next one, as part of ensuring the correct one activates when the binding is pressed.</p> <pre><code>--Server script\nlocal equipment = script:FindAncestorByType(\"Equipment\")\nlocal abilities = {}\nlocal abilityIndex = 1\n\nfunction OnAbilityRecovery(ability)\n    if (#abilities &gt; 1) then\n        abilities[abilityIndex].isEnabled = false\n        abilities[abilityIndex].owner = nil\n\n        abilityIndex = abilityIndex + 1\n        if (abilityIndex &gt; #abilities) then\n            abilityIndex = 1\n        end\n\n        abilities[abilityIndex].isEnabled = true\n        abilities[abilityIndex].owner = equipment.owner\n    end\nend\n\nfor _, child in pairs(equipment:FindDescendantsByType(\"Ability\")) do\n    table.insert(abilities, child)\n\n    child.isEnabled = (#abilities == 1)\n\n    child.recoveryEvent:Connect(OnAbilityRecovery)\nend\n</code></pre> <p>See also: CoreObject.FindAncestorByType | Ability.owner | Equipment.owner | Event.Connect</p> <p>Example using:</p>","tags":["API"]},{"location":"libs/_template_/#owner","title":"<code>owner</code>","text":"<p>Usually, abilities are presented as part of an equipment, but that isn't a requirement. In this example, when new players join the game they are assigned an ability through the use of the <code>owner</code> property.</p> <pre><code>--Server script\nlocal abilityTemplate = script:GetCustomProperty(\"AbilityTemplate\")\n\nfunction OnPlayerJoined(player)\n    local ability = World.SpawnAsset(abilityTemplate)\n    ability.owner = player\nend\n\nGame.playerJoinedEvent:Connect(OnPlayerJoined)\n</code></pre> <p>See also: CoreObject.GetCustomProperty | World.SpawnAsset | Player.owner | Game.playerJoinedEvent | Event.Connect</p>","tags":["API"]},{"location":"libs/_template_/#tutorials","title":"Tutorials","text":"<p>Abilities in Core</p>","tags":["API"]},{"location":"libs/lua-hid/","title":"USB HID Devices (Buttons, Arduino, etc.)","text":"<p>-- id: luahid name: LuaHID title: LuaHID tags:     - API</p>"},{"location":"libs/lua-hid/#luahid","title":"LuaHID","text":"<p>LuaHID provides an interface to access USB devices over the <code>HID</code> (human input device) protocol. It implements a thin LUA wrapper interface over the  cross platform hidapi library (hidapi.dll, see  signal11/hidapi (github.com), licensed under BSD License). The code is derived from ynezz/luahidapi (github.com) (MIT License) and adopted to OGS.</p> <p>Note, that although USB mice and keyboards are technically HID devices, the Windows API does not allow to access these through the HID API (for security reasons). All other (custom) USB HID devices should work.</p>"},{"location":"libs/lua-hid/#module","title":"Module","text":"<p>The LuaHID module provides global functions to access the systems HID API. Before calling any other function of the module, the <code>init()</code> function must be called. </p> <p>To actually connect to a physical device, an instance of the <code>HidDevice</code> object must be created (see #class_hiddevice below) by calling the <code>open()</code> function. This requires specifying the VID (vendor ID) and PID (device id) and (optionally) the SN (serial number). If the parameters are not known beforehand, they may be listed through calling the module level <code>enumerate()</code> function. This returns a table of all currently connected devices. Specific device actions (like reading/writing) can then be executed on the object returned from the <code>open()</code> call.</p>"},{"location":"libs/lua-hid/#properties","title":"Properties","text":"Property Name Return Type Description Tags <code>_VERSION</code> <code>string</code> Current version of the LuaHID module. See also the <code>version_mod()</code> function to get more details about the DLL module version. Read-Only <code>_TIMESTAMP</code> <code>string</code> Timestamp of the last build of the LuaHID module. Read-Only"},{"location":"libs/lua-hid/#enumerations","title":"Enumerations","text":""},{"location":"libs/lua-hid/#functions","title":"Functions","text":"Function Name Return Type Description Tags <code>init()</code> <code>boolean</code> Initializes the LuaHID library. Returns true on success, nil on failure. None <code>exit()</code> <code>boolean</code> Cleans up and terminates the LuaHID library. Returns true on success, nil on failure. None <code>enumerate(integer vid, integer pid)</code><code>enumerate()</code> <code>hidenum</code> Returns a HID device enumeration object for HID devices that matches given vid, pid pair. Enumerates all HID devices if no arguments provided or (0,0) used.IMPORTANT: Mouse and keyboard devices are not visible on WindowsReturns nil if failed. None <code>write()</code> <code>boolean</code> . Returns true on success, nil on failure. None <code>read()</code> <code>boolean</code> . Returns true on success, nil on failure. None <code>set()</code> <code>boolean</code> . Returns true on success, nil on failure. None <code>getstring()</code> <code>boolean</code> . Returns true on success, nil on failure. None <code>setfeature()</code> <code>boolean</code> . Returns true on success, nil on failure. None <code>getfeature()</code> <code>boolean</code> . Returns true on success, nil on failure. None <code>error()</code> <code>boolean</code> . Returns true on success, nil on failure. None <code>close()</code> <code>boolean</code> . Returns true on success, nil on failure. None <code>msleep()</code> <code>boolean</code> . Returns true on success, nil on failure. None <code>version_mod()</code> <code>boolean</code> . Returns true on success, nil on failure. None"},{"location":"libs/lua-hid/#class-hiddeviceinfo","title":"Class HidDeviceInfo","text":"<p>The HidDeviceInfo table provides information about a USB HID device connected to the system. The HidDeviceInfo is retrieved by calling the <code>enumerate()</code> function and iterating the result by calling the <code>next()</code> member. </p>"},{"location":"libs/lua-hid/#properties_1","title":"Properties","text":"Property Name Return Type Description Tags <code>path</code> <code>string</code> System specific device path. Read-Only <code>vid</code> <code>integer</code> Vendor ID of the device. Read-Only <code>pid</code> <code>integer</code> Product ID of the device. Read-Only <code>serial_number</code> <code>string</code> Device serial number. Read-Only <code>release</code> <code>integer</code> Release number (version) of the device. Read-Only <code>manufacturer_string</code> <code>string</code> Manufacturer name. Read-Only <code>product_ _string</code> <code>string</code> Product name. Read-Only <code>usage_page</code> <code>integer</code> HID usage page of the device. Read-Only <code>usage</code> <code>integer</code> HID usage of the device. Read-Only <code>interface</code> <code>integer</code> Interface number of the device. Read-Only"},{"location":"libs/lua-hid/#class-hidenum","title":"Class HidEnum","text":"<p>The HidEnum class is actually an iterator and represents the list returned from calling the <code>enumerate</code> module function. Each element of the list represents a connected USB HID device and has the properties shown in the following section.  To iterate the list, call the <code>next()</code> instance function - each call to next returns a <code>HidDeviceInfo</code> table and internally advances to the next item.</p>"},{"location":"libs/lua-hid/#functions_1","title":"Functions","text":"Function Name Return Type Description Tags <code>next()</code> <code>HidDevice</code> Returns the current device info data and steps on to the next element in the list. None <code>close()</code> <code>None</code> Closes the iterator and frees any resources. There is normally no need to call this, as the object is garbage collected automatically. None"},{"location":"libs/lua-hid/#class-hiddevice","title":"Class HidDevice","text":""},{"location":"libs/lua-hid/#properties_2","title":"Properties","text":""},{"location":"libs/lua-hid/#functions_2","title":"Functions","text":"<pre><code>{\"write\", hidapi_write},\n{\"read\", hidapi_read},\n{\"set\", hidapi_set},\n{\"getstring\", hidapi_getstring},\n{\"setfeature\", hidapi_setfeature},\n{\"getfeature\", hidapi_getfeature},\n{\"error\", hidapi_error},\n{\"close\", hidapi_close},\n{\"__gc\",  hidapi_hiddevice_meta_gc},\n</code></pre> <p>). are CoreObjects that can be added to Players and guide the Player's animation in sync with the Ability's state machine. Spawn an Ability with <code>World.SpawnAsset()</code> or add an Ability as a child of an Equipment/Weapon to have it be assigned to the Player automatically when that item is equipped.</p>"},{"location":"tools/","title":"Tool configuration","text":""},{"location":"tools/#overview","title":"Overview","text":""},{"location":"tools/#stationini","title":"station.ini","text":""},{"location":"tools/remote-tool/","title":"RemoteTool","text":"<p>OGS supports connecting tools over a <code>ToolGateway</code>. This enables advanced  tool management scenarios, e.g. \"roaming\" tools between multiple stations.</p> <p>Using the <code>RemoteTool</code> driver requires a <code>ToolGateway</code> running on a server - the server then actually controls the tool, whereas the OGS stations only communication with the <code>ToolGateway</code>. This allows delegating tool management to the central <code>ToolGateway</code>. </p> <p>For each tool managed through the <code>ToolGateway</code>, OGS only uses a generic <code>RemoteTool</code> type channel in its local configuration, the <code>ToolGateway</code> then has the actual tool-specific configuration (like e.g. OpenProtocol tools).</p>"},{"location":"tools/remote-tool/#installation","title":"Installation","text":"<p>The <code>RemoteTool</code> driver is implemented in <code>RemoteTool.dll</code>. To use any <code>RemoteTool</code> tool, the driver must be loaded in the <code>[TOOL_DLL]</code> section of the projects <code>station.ini</code> configuration file (see also Tool configuration).</p> <p>To enable the driver in station.ini, set it as follows:</p> <pre><code>[TOOL_DLL]\nRemoteTool.dll=1\n</code></pre> <p>The overall parameters for the <code>RemoteTool</code> driver are configured in the \u00b4[RemoteTool]<code>section. This is basically used to configure the</code>ToolGateway` connection parameters, here is a sample setup:</p> <pre><code>[RemoteTool]\nToolGateway_Addr=mytoolgateway.mycompany.com\nToolGateway_Port=\n</code></pre> <p>For more information about the driver parameters, see Driver Parameters below.</p>"},{"location":"tools/remote-tool/#tool-registration-and-configuration","title":"Tool registration and configuration","text":"<p>All <code>RemoteTool</code>-tools are registered in the <code>[CHANNELS]</code> section of the projects <code>station.ini</code> file.</p> <p>The <code>[CHANNELS]</code> section only defines a channel number to channel name mapping - the channel/tool specific settings are then configured in a seperate section defined by the channel name. Inside the section, a reference to the <code>RemoteTool</code> driver then links driver and channel accordingly.</p> <p>The overall layout is therefore as follows (sample is for channel 2):</p> <pre><code>[CHANNELS]\n# Map the channel/tool 2 to the 'RemoteTool_Nexo1'-section\n2=RemoteTool_Nexo1\n\n[RemoteTool_Nexo1]\n# link to the RemoteTool driver\nDRIVER=RemoteTool\n# more channel/tool specific parameters for this tool/driver\n</code></pre> <p>Please see Channel/tool parameter reference below for more information about the available parameters.</p>"},{"location":"tools/remote-tool/#channeltool-parameter-reference","title":"Channel/tool parameter reference","text":"<p>Currently, there are no channel/tool-specific parameters needed (other than specifying the <code>DRIVER=RemoteTool</code>) to use this driver. All concrete tool communication settings are to be configured on the <code>ToolGateway</code> server side. </p>"},{"location":"tools/remote-tool/#driver-parameter-reference","title":"Driver parameter reference","text":"<p>The driver parameters are defined in the <code>[RemoteTool]</code> section in the projects <code>station.ini</code>.</p> <p>The following parameters are available:</p>"},{"location":"tools/remote-tool/#toolgateway_addr","title":"ToolGateway_Addr","text":"<p>IP address or hostname of the tool gateway.</p>"},{"location":"tools/remote-tool/#toolgateway_port","title":"ToolGateway_Port","text":"<p>(optional)</p> <p>Port number to use for connecting to the tool gateway. If not given, the driver tries to use the RPC endpoint mapper using the service UUID to resolve the connection endpoint (might require additional firewall settings).</p>"},{"location":"tools/openprotocol/","title":"OpenProtocol tools","text":"<p>OGS supports connecting tools with <code>OpenProtocol</code> interface. As tools differ in functionality and also different tool vendors implement the <code>OpenProtocol</code> specification in slightly different ways, OGS has special protocol handlers for the following tools:</p> <ul> <li>Rexroth Nexo and Nexo 2 wireless tools (for more information, see Nexo OpenProtocol)</li> <li>Rexroth CS351 and KE350 system tools (for more information, see System 350 OpenProtocol)</li> <li>GWK Operator+ torque wrenches (for more information, see GWK Operator+ OpenProtocol)</li> <li>Crane TCI torque wrenches (for more information, see Crane OpenProtocol)</li> <li>Gehmeyr Exact Wifi tools (for more information, see Gehmeyr OpenProtocol)</li> </ul> <p>The overall configuration for these tools is similar and the actual driver has the same set of configuration parameters - described on this page.</p>"},{"location":"tools/openprotocol/#installation","title":"Installation","text":"<p>The <code>OpenProtocol</code> driver is implemented in <code>OpConn.dll</code>. To use any <code>OpenProtocol</code> tool, the driver must be loaded in the <code>[TOOL_DLL]</code> section of the projects <code>station.ini</code> configuration file (see also Tool configuration).</p>"},{"location":"tools/openprotocol/#tool-registration-and-configuration","title":"Tool registration and configuration","text":"<p>All <code>OpenProtocol</code>-tools are registered in the <code>[OPENPROTO]</code> section of the projects <code>station.ini</code> file.</p> <p>The <code>[OPENPROTO]</code> section mixes the tool parameters and the channel mapping (due to historic reasons) by combining the channel number and the parameter name/value in the <code>station.ini</code> entry. </p> <p>Each parameter is prefixed with the channel number and followed by parameter name as follows:</p> <pre><code>CHANNEL_&lt;two-digit channel&gt;_&lt;param name&gt;=&lt;param value&gt;\n</code></pre> <p>Where - <code>&lt;two-digit channel&gt;</code> is the channel number in the range 01...99 (the channel number maps 1:1 to the tool number from the workflow configuration)  - <code>&lt;param name&gt;</code> is the parameter name (see Channel parameter reference) - <code>&lt;param value&gt;</code> is the actual parameter value for the given parameter</p> <p>In addition to the channel-specific parameters, there are also shared parameters. These act as default parameters for the channel-specific settings and can be overridden by the channel specific values.</p> <p>For more details on the shared parameters, see Shared parameter reference) below .</p> <p>A sample <code>OpenProtocol</code> tool configuration (channel 01) would therefore look similar to the following:</p> <pre><code>[OPENPROTO]\n# Shared/default parameters\nPORT=4545\n# Channel/Tool 1 parameters\nCHANNEL_01=10.10.2.163\nCHANNEL_01_TYPE=NEXO\nCHANNEL_01_CHECK_TIME_ENABLED=1\nCHANNEL_01_NEXONAR_CHANNEL=6\nCHANNEL_01_CURVE_REQUEST=1\n</code></pre>"},{"location":"tools/openprotocol/#shared-parameter-reference","title":"Shared parameter reference","text":""},{"location":"tools/openprotocol/#port","title":"PORT","text":"<p>(optional, defaults to 4545)</p>"},{"location":"tools/openprotocol/#external_io_offset","title":"EXTERNAL_IO_OFFSET","text":""},{"location":"tools/openprotocol/#check_time_interval-and-time_tolerance","title":"CHECK_TIME_INTERVAL and TIME_TOLERANCE","text":""},{"location":"tools/openprotocol/#external_io_offset_1","title":"EXTERNAL_IO_OFFSET","text":""},{"location":"tools/openprotocol/#channel-parameter-reference","title":"Channel parameter reference","text":"<p>For specific information about a tools settings or the tools configuration needed (on the tool side), please see the tool-specific information.</p> <p>In general, the following parameters are available for a <code>OpenProtocol</code>-tool:</p>"},{"location":"tools/openprotocol/#connection-information","title":"Connection information","text":""},{"location":"tools/openprotocol/#port_1","title":"PORT","text":"<p>(optional, defaults to the shared parameter value)</p>"},{"location":"tools/openprotocol/#type","title":"TYPE","text":"<p>(mandatory)</p>"},{"location":"tools/openprotocol/#ccw_ack","title":"CCW_ACK","text":""},{"location":"tools/openprotocol/#params","title":"PARAMS","text":""},{"location":"tools/openprotocol/#alivexmtt","title":"ALIVEXMTT","text":""},{"location":"tools/openprotocol/#showalive","title":"SHOWALIVE","text":""},{"location":"tools/openprotocol/#rsptimeout","title":"RSPTIMEOUT","text":""},{"location":"tools/openprotocol/#barcode_mid0051_rev","title":"BARCODE_MID0051_REV","text":""},{"location":"tools/openprotocol/#check_ext_cond","title":"CHECK_EXT_COND","text":""},{"location":"tools/openprotocol/#appl_start","title":"APPL_START","text":""},{"location":"tools/openprotocol/#curve_request","title":"CURVE_REQUEST","text":""},{"location":"tools/openprotocol/#check_time_enabled","title":"CHECK_TIME_ENABLED","text":""},{"location":"tools/openprotocol/#ignore_id","title":"IGNORE_ID","text":""},{"location":"v3/lua/webbrowser/","title":"Browser","text":""},{"location":"v3/lua/webbrowser/#overview","title":"Overview","text":"<p>The OGS runtime uses up to 4 web browser (Microsoft WebView2) instances. The instances are: - <code>StartView</code>: Browser on the start screen - <code>ProcessView</code>: Browser on the process screen (only visible, if the <code>url</code>-parameter in the job/task is set) - <code>SidePanel</code>: Browser on the slide-in side panel (requires enabling the sidepanel in <code>station.ini</code>) - <code>InstructionView</code>: Browser in the instruction view popup (is triggered from LUA, so only visible with custom LUA code)</p> <p>The OGS infrastructure provides functions to bidirectionally exchange data between the JavaScript code running inside the web browser and the LUA code running inside OGS. There is a LUA function to execute JavaScript code in the webbrowser and a JavaScript bride, which calls a LUA function (if registered accordingly).</p> <p>To implement this functionality, OGS provides the following: - For the JavaScript side: a bridge implementation accessibal through the <code>hostObjects</code> interface of the Chromium browser (<code>window.chrome.webview.hostObjects.sync.OGS</code>) - For the LUA side: a global <code>Browser</code> table with functions to manipulate the browser instances</p>"},{"location":"v3/lua/webbrowser/#javascript-hostobjects-bridge","title":"JavaScript hostObjects bridge","text":"<p>OGS registers a hostObject in the WebView2 browser for the JavaScript side. The registered object is named <code>OGS</code> and implements a single string property <code>ObjectMessage</code>.</p> <p>To send a string to OGS from JavaScript, simply assign a value to the <code>window.chrome.webview.hostObjects.sync.OGS.ObjectMessage</code> property.</p>"},{"location":"v3/lua/webbrowser/#sample-code","title":"Sample code","text":"<pre><code>// send a command string to OGS \nfunction sendOgsCommand(cmd)\n{\n    if (!window.chrome || !window.chrome.webview\n     || !window.chrome.webview.hostObjects\n     || !window.chrome.webview.hostObjects.sync) {\n        // WebView2 is not yet fully initialized\n        return;     \n    }\n    let ogs = window.chrome.webview.hostObjects.sync.OGS;\n    if (ogs) {\n        ogs.ObjectMessage = cmd;    \n    }\n}\n</code></pre>"},{"location":"v3/lua/webbrowser/#global-browser-table","title":"Global Browser table","text":"<p>OGS exposes the browser instances through the global <code>Browser</code> object. The <code>Browser</code> object implements the following functions:</p> <ul> <li>Navigate: Load a new URL in the web browser</li> <li>ExecJS_nonblocking: Run javascript inside the web browser (asynchronously, not returning a value)</li> <li>RegMsgHandler: Register a LUA callback function to be called when the JavaScript side writes to the object message endpoint.</li> </ul>"},{"location":"v3/lua/webbrowser/#navigate","title":"Navigate","text":"<p>The <code>Browser.Navigate</code> function starts loading a new URL into the given browser instance.</p> <pre><code>Browser.Navigate(instance, url)\n</code></pre>"},{"location":"v3/lua/webbrowser/#parameters","title":"Parameters","text":"<ul> <li>instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') </li> <li>url [string]: Url to navigate the browser instance to (in the standard URL format, e.g. file://filename or https://server/page)</li> </ul>"},{"location":"v3/lua/webbrowser/#sample-code_1","title":"Sample code","text":"<pre><code>-- Navigate the StartView browser to https://www.my-url.com/mypage\nBrowser.Navigate('StartView', 'https://www.my-url.com/mypage')\n</code></pre>"},{"location":"v3/lua/webbrowser/#show","title":"Show","text":"<p>The <code>Browser.Show</code> function is similar to the <code>Browser.Navigate</code> function, but also ensures the webbrowser is actually visible. The actual behaviour depends on the view - e.g. for the <code>SidePanel</code> view, the side panel pops out. For the <code>ProcessView</code> view, this switches from the image-view to the web view.</p> <pre><code>local oldUrl = Browser.Show(instance, url)\n</code></pre>"},{"location":"v3/lua/webbrowser/#parameters_1","title":"Parameters","text":"<ul> <li>instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') </li> <li>url [string]: Url to navigate the browser instance to (in the standard URL format, e.g. file://filename or https://server/page)</li> </ul>"},{"location":"v3/lua/webbrowser/#return-value","title":"Return value","text":"<p>The function returns the \"current\" URL of the webbrowser (the URL before changing to the given one). This can be used to return to the previous URL after hiding the browser.)</p>"},{"location":"v3/lua/webbrowser/#sample-code_2","title":"Sample code","text":"<pre><code>-- Make the SidePanel visible and navigate the web browser to https://www.my-url.com/mypage\nlocal oldUrl = Browser.Show('SidePanel', 'https://www.my-url.com/mypage')\n</code></pre>"},{"location":"v3/lua/webbrowser/#hide","title":"Hide","text":"<p>The <code>Browser.Hide</code> function is complementary to the <code>Browser.Show</code> function - it closes the browser view (only relevant for <code>SidePanel</code> and <code>ProcessView</code>).</p> <pre><code>Browser.Hide(instance)\n</code></pre>"},{"location":"v3/lua/webbrowser/#parameters_2","title":"Parameters","text":"<ul> <li>instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') </li> </ul>"},{"location":"v3/lua/webbrowser/#sample-code_3","title":"Sample code","text":"<pre><code>-- Hide the SidePanel\nBrowser.Hide('SidePanel')\n</code></pre>"},{"location":"v3/lua/webbrowser/#regmsghandler","title":"RegMsgHandler","text":"<p>The <code>Browser.RegMsgHandler</code> function registers or unregisters a LUA function to be called whenever the JavaScript running in the browser writes a message to the hostObject bridge <code>OGS.ObjectMessage</code> property.</p> <pre><code>-- Register the callback function\nfn, err = Browser.RegMsgHandler(instance, callbackfn)\n</code></pre>"},{"location":"v3/lua/webbrowser/#parameters_3","title":"Parameters","text":"<ul> <li>instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') </li> <li>callbackfn [function]: LUA function to be called when the JavaScript code writes a string to the <code>OGS.ObjectMessage</code> hostObject. If callbackfn is <code>nil</code>, then the current registration is removed. The callback function has the following signature:<pre><code>callbackfn(instance, objectMessage)\n</code></pre> </li> </ul> <p>Where instance [string] is the web browsers instance name (e.g. 'StartView') and objectMessage [string] the text which was written to the <code>OGS.ObjectMessage</code> property of the hostObject bridge from the JavaScript side.</p>"},{"location":"v3/lua/webbrowser/#return-values","title":"Return values","text":"<p>If the function was executed successfully, the callbackfn is returned as the first return value. Else nil is returned and the second return value has an error message string (wrong parameters or unknown instance).</p>"},{"location":"v3/lua/webbrowser/#sample-code_4","title":"Sample code","text":"<pre><code>local function callbackfn(instance, objectMessage)\n    -- do whatever you want to do here if the javascript \n    -- code writes the OGS.ObjectMessage property\nend\n\n-- Register a LUA function to be called from the JavaScript side\nBrowser.RegMsgHandler('StartView', callbackfn)\n</code></pre>"},{"location":"v3/lua/webbrowser/#execjs_nonblocking","title":"ExecJS_nonblocking","text":"<p>The <code>Browser.ExecJS_nonblocking</code> executes JavaScript code in the web browser instance.</p> <pre><code>Browser.ExecJS_nonblocking(instance, jstext)\n</code></pre>"},{"location":"v3/lua/webbrowser/#parameters_4","title":"Parameters","text":"<ul> <li>instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') </li> <li>jstext [string]: JavaScript string to execute in the browser. Note that this must be valid JavaScript code. </li> </ul> <p>NOTES: </p> <ul> <li>When passing strings through the function, make sure to propery escape them!</li> <li>Best practice is to write a JavaScript function in the web page and only call it through this function.</li> <li>You can serialize LUA objects to a JSON string and pass this through the function. The JavaScript side can then easily deserialize it.</li> </ul>"},{"location":"v3/lua/webbrowser/#sample-code_5","title":"Sample code","text":"<pre><code>-- Build a JavaScript command, call the function \"my_function\" with\n-- some JSON text\nlocal param = '{ \"cmd\": \"showmessage\" }'\nlocal command = \"my_function(\"..param..\");\"\n-- Call the JavaScript function in the StartView browser\nBrowser.ExecJS_nonblocking('StartView', command)\n</code></pre>"},{"location":"v3/lua/webserver/","title":"Webserver","text":""},{"location":"v3/lua/webserver/#overview","title":"Overview","text":"<p>The OGS runtime uses the Microsoft Windows builtin http.sys web server to server static pages and dynamic pages. The dynamic pages are implemented through LUA scripting and makes it possible to flexibly implement web services like OpenAPI / REST services or others.</p> <p>A typical use case is to provide a REST interface for third-party systems to connect them to OGS, another is to implement backend logic for a single page application web page frontend running inside OGS (see also OGS Webbrowser LUA interface).</p> <p>The web server LUA api works by registering LUA callback functions for specific URL prefixes, which are then called by the web server, whenever the given URL is requested from a web client.</p>"},{"location":"v3/lua/webserver/#prerequisites","title":"Prerequisites","text":"<p>To use the LUA web server API, the web server must be enabled through <code>station.ini</code> (in the <code>[WebServer]</code> section) and the Microsoft <code>http.sys</code> web server must be configured accordingly (a URL reservation must be activated through the <code>netsh http add urlacl ...</code> command).</p> <p>By default the, installer registers a web endpoint at http://localhost:59990, so the endpoint is only accessible from the local machine and only for a locally logged on user.</p> <p>To access the web server from the outside, make sure to change the listen address in the <code>station.ini</code> file, the URL reservation through <code>netsh http ...</code> and check the firewall settings. </p>"},{"location":"v3/lua/webserver/#global-webserver-table","title":"Global Webserver table","text":"<p>OGS exposes the web server through the global <code>Webserver</code> object. The <code>Webserver</code> object implements the following functions:</p> <ul> <li>RegUrl: Register a LUA callback function to be called when a specific URL prefix is requested from the web server.</li> </ul>"},{"location":"v3/lua/webserver/#regurl","title":"RegUrl","text":"<p>The <code>Webserver.RegUrl</code> function registers or unregisters a LUA function to be called whenever the web server receives a request to the given URL prefix.</p> <pre><code>fn, err = Webserver.RegUrl(prefix, callbackfn)\n</code></pre>"},{"location":"v3/lua/webserver/#parameters","title":"Parameters","text":"<ul> <li>prefix [string]: Path prefix to match against when checking the request URL. Note that this only checks for the path part of the URL (e.g. '/home'). </li> <li> <p>callbackfn [function]: LUA function to be called when a web request matches the prefix. The callback function has the following signature:</p> <pre><code>table = callbackfn(reqpath, reqparams, verb, body)\n</code></pre> <p>Where reqpath [string] is the full request path, (e.g. '/api/items'), reqparams [string] the request parameters (e.g. '?max=10&amp;class=5'), verb [integer] the request type (GET, PUT, POST, DELETE) and body [string] the body (binaty) string value (only for POST and PUT).</p> <p>The callback function should return a response table with the required parameters to build the http response (optional body).</p> <p>[Datails tbd.]</p> </li> </ul>"},{"location":"v3/lua/webserver/#return-values","title":"Return values","text":"<p>If the function was executed successfully, the callbackfn is returned as the first return value. Else nil is returned and the second return value has an error message string (wrong parameters or unknown instance).</p>"},{"location":"v3/lua/webserver/#sample-code","title":"Sample code","text":"<pre><code>local function handlerfn(reqpath, reqparams, verb, body)\n    -- process the request, return the response object (or nil\n    -- if this request is not handled) \n    return nil\nend\n-- Register a LUA function to be called whenever a web request to /api/lua\n-- is made\nBrowser.RegMsgHandler('/api/lua', handlerfn)\n</code></pre>"}]}