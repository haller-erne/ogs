{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OGS - Operator guidance system Scope This documentation provides low-level infomation about the OGS software. The main purpose is to document the API interfaces (mostly LUA scripting), the available (tool)drivers and show how everything fits together. This allows advanced users and implementors to unlock the full potential of OGS by modifying and extending the software. NOTE: This documentation is valid for OGS V3. As V3 is not yet released, some of the information might still change before the final release. Overview The documentation currently has the following information: Tool driver and tool configuration information (see Tool configuration ) LUA scripting (see LUA scripting ) LUA helper libraries (see LUA libraries )","title":"Home"},{"location":"#ogs-operator-guidance-system","text":"","title":"OGS - Operator guidance system"},{"location":"#scope","text":"This documentation provides low-level infomation about the OGS software. The main purpose is to document the API interfaces (mostly LUA scripting), the available (tool)drivers and show how everything fits together. This allows advanced users and implementors to unlock the full potential of OGS by modifying and extending the software. NOTE: This documentation is valid for OGS V3. As V3 is not yet released, some of the information might still change before the final release.","title":"Scope"},{"location":"#overview","text":"The documentation currently has the following information: Tool driver and tool configuration information (see Tool configuration ) LUA scripting (see LUA scripting ) LUA helper libraries (see LUA libraries )","title":"Overview"},{"location":"libs/_template_/","text":"Ability Abilities are CoreObjects that can be added to Players and guide the Player's animation in sync with the Ability's state machine. Spawn an Ability with World.SpawnAsset() or add an Ability as a child of an Equipment/Weapon to have it be assigned to the Player automatically when that item is equipped. Abilities can be activated by association with an Action Binding. Their internal state machine flows through the phases: Ready, Cast, Execute, Recovery, and Cooldown. An Ability begins in the Ready state and transitions to Cast when its Binding (for example Left mouse click) is activated by the owning player. It then automatically flows from Cast to Execute, then Recovery and finally Cooldown. At each of these state transitions it fires a corresponding event. Only one ability can be active at a time. By default, activating an ability will interrupt the currently active ability. The canBePrevented and preventsOtherAbilities properties can be used to customize interruption rules for competing abilities. If an ability is interrupted during the Cast phase, it will immediately reset to the Ready state. If an ability is interrupted during the Execute or Recovery phase, the ability will immediately transition to the Cooldown phase. Properties Property Name Return Type Description Tags isEnabled boolean Turns an Ability on/off. It stays on the Player but is interrupted if isEnabled is set to false during an active Ability. True by default. Read-Write canActivateWhileDead boolean Indicates if the Ability can be used while the owning Player is dead. False by default. Read-Only name string The name of the Ability. Read-Only actionBinding string This property is deprecated. Please use actionName instead, but note that actionBinding and actionName use different values. Which action binding will cause the Ability to activate. Possible values of the bindings are listed on the Ability binding page. Read-Only, Deprecated actionName string Which binding set action name will cause the Ability to activate. See Binding Sets reference. Read-Only owner Player Assigning an owner applies the Ability to that Player. Read-Write castPhaseSettings AbilityPhaseSettings Config data for the Cast phase (see below). Read-Only executePhaseSettings AbilityPhaseSettings Config data for the Execute phase. Read-Only recoveryPhaseSettings AbilityPhaseSettings Config data for the Recovery phase. Read-Only cooldownPhaseSettings AbilityPhaseSettings Config data for the Cooldown phase. Read-Only animation string Name of the animation the Player will play when the Ability is activated. Possible values: See Ability Animation for strings and other info. Read-Only canBePrevented boolean Used in conjunction with the phase property preventsOtherAbilities so multiple abilities on the same Player can block each other during specific phases. True by default. Read-Only Functions Function Name Return Type Description Tags Activate() None Activates an Ability as if the button had been pressed. None Interrupt() None Changes an Ability from Cast phase to Ready phase. If the Ability is in either Execute or Recovery phases it instead goes to Cooldown phase. None AdvancePhase() None Advances a currently active Ability from its current phase to the next phase. For example, an ability in the Cast phase will begin the Execute phase, an ability on cooldown will become ready, etc. None GetCurrentPhase() AbilityPhase The current AbilityPhase for this Ability. These are returned as one of: AbilityPhase.READY, AbilityPhase.CAST, AbilityPhase.EXECUTE, AbilityPhase.RECOVERY and AbilityPhase.COOLDOWN. None GetCurrentPhaseSettings() AbilityPhaseSettings Returns the settings for the current phase of this Ability. Returns nil if the current phase is AbilityPhase.READY . None GetPhaseTimeRemaining() number Seconds left in the current phase. None GetTargetData() AbilityTarget Returns information about what the Player has targeted this phase. None SetTargetData(AbilityTarget) None Updates information about what the Player has targeted this phase. This can affect the execution of the Ability. None Events Event Name Return Type Description Tags readyEvent Event < Ability > Fired when the Ability becomes ready. In this phase it is possible to activate it again. None castEvent Event < Ability > Fired when the Ability enters the Cast phase. None executeEvent Event < Ability > Fired when the Ability enters Execute phase. None recoveryEvent Event < Ability > Fired when the Ability enters Recovery. None cooldownEvent Event < Ability > Fired when the Ability enters Cooldown. None interruptedEvent Event < Ability > Fired when the Ability is interrupted. None tickEvent Event < Ability ability, number deltaTime> Fired every tick while the Ability is active (isEnabled = true and phase is not ready). None Examples Example using: castEvent The Cast phase begins as soon as an ability is activated. By checking if the player casting the ability isGrounded we can create an effect that propels you upwards, but it doesn't work if you are already jumping or flying. We detect this is the castEvent , which is early enough for an Interrupt() to reset the ability. --Server script local ability = script.parent function OnCast(ability) if ability.owner.isGrounded then ability.owner:SetVelocity(Vector3.UP * 2000) else ability:Interrupt() end end ability.castEvent:Connect(OnCast) See also: CoreObject.parent | Ability.owner | Player.isGrounded | Vector3.UP | Event.Connect Example using: cooldownEvent In this example, a fighting game has an \"invincible\" mechanic where player attacks are not interrupted while they have this effect. Some powerful attacks make the player invincible during the entire active cycle of the ability. The effect is gained at the beginning of the cast phase and is removed at the end of the recovery phase, before the cooldown begins. The resource system is used in keeping track of the invincibility effect. --Server script local ability = script.parent function OnCast(ability) ability.owner:AddResource(\"invincible\", 1) end function OnCooldown(ability) ability.owner:RemoveResource(\"invincible\", 1) end ability.castEvent:Connect(OnCast) ability.cooldownEvent:Connect(OnCooldown) See also: CoreObject.parent | Player.owner | Ability.castEvent | Event.Connect Example using: executeEvent Weapons implement lots of built-in gameplay that doesn't require any scripting, such as attack and reload abilities. However, they can be augmented with additional mechanics. In this example, a special sound effect is played when a weapon shoots while low on ammunition. The script expects to be a child of a weapon's \"Shoot\" ability. --Server script local ability = script.parent local weapon = script:FindAncestorByType('Weapon') local lowAmmoSound = script:GetCustomProperty(\"LowAmmoSound\") local LOW_AMMO_PERCENTAGE = 0.2 function OnExecute(ability) if weapon.currentAmmo / weapon.maxAmmo <= LOW_AMMO_PERCENTAGE then World.SpawnAsset(lowAmmoSound, {position = weapon:GetWorldPosition()}) end end ability.executeEvent:Connect(OnExecute) See also: CoreObject.parent | Weapon.currentAmmo | World.SpawnAsset | Ability.executeEvent | Event.Connect Example using: interruptedEvent The interruptedEvent fires when an ability is going through it's activation process and Interrupt() is called on it, or if it becomes disabled. In this example, interruption is a key part of the game design, so a visual effect is spawned at the player's position to help communicate the interaction between players. --Server script local ability = script.parent local interruptedVfx = script:GetCustomProperty(\"InterruptedVfx\") function OnInterrupted(ability) if Object.IsValid(ability.owner) then World.SpawnAsset(interruptedVfx, {position = ability.owner:GetWorldPosition()}) end end ability.interruptedEvent:Connect(OnInterrupted) See also: CoreObject.parent | Object.IsValid | Ability.owner | World.SpawnAsset | Player.GetWorldPosition | Event.Connect Example using: readyEvent The Ready phase begins when an ability comes off cooldown and is \"ready\" to be used again. In this example, we create an invisibility effect that takes advantage of the readyEvent , leveraging the cooldown duration of the ability as a clock to determine when to make the player visible again. -- Server script local ability = script.parent function OnExecute(ability) -- Hide the player ability.owner:SetVisibility(false) end function OnReady(ability) -- Show the player ability.owner:SetVisibility(true) end ability.readyEvent:Connect(OnReady) ability.executeEvent:Connect(OnExecute) See also: CoreObject.parent | Ability.owner | Player.SetVisibility | Event.Connect Example using: recoveryEvent The recoveryEvent marks the end of an ability's Execute phase and the beginning of its Recovery phase. In this example, a melee punch ability has a trigger that causes damage to enemies who overlap it. For it to work the trigger is only enabled for a brief moment, during the Execute phase. --Server script local ability = script.parent local trigger = script:GetCustomProperty(\"ImpactTrigger\"):WaitForObject() trigger.collision = Collision.FORCE_OFF local DAMAGE_AMOUNT = 10 function OnExecute(ability) trigger.collision = Collision.FORCE_ON end function OnRecovery(ability) trigger.collision = Collision.FORCE_OFF end ability.executeEvent:Connect(OnExecute) ability.recoveryEvent:Connect(OnRecovery) function OnBeginOverlap(trigger, other) -- Only damage enemy players if other:IsA(\"Player\") and other.team ~= ability.owner.team then other:ApplyDamage(Damage.New(DAMAGE_AMOUNT)) end end trigger.beginOverlapEvent:Connect(OnBeginOverlap) See also: CoreObject.parent | CoreObjectReference.WaitForObject | Ability.executeEvent | Event.Connect | other.IsA | Player.team | Damage.New | Trigger.beginOverlapEvent Example using: tickEvent Abilities fire the tickEvent while they are active or on cooldown (not on Ready state). In this example, a piece of equipment carries several abilities, but we want to do a common update logic on all of them. Note: Ability.tickEvent works somewhat differently from a Tick() function - tickEvent is an actual event that just happens to fire once per tick. Each invocation of the callback runs on its own task. This means that, unlike Tick() , there is no guarantee that it will wait for the previous tickEvent to finish before starting the next one. This means you can't use things like Task.Wait() to add time between ticks. local equipment = script.parent local allAbilities = equipment:GetAbilities() function OnTick(ability, deltaTime) print(\"Updating ability \" .. ability.name) end for _, ability in ipairs(allAbilities) do ability.tickEvent:Connect(OnTick) end See also: CoreObject.parent | Equipment.GetAbilities | Event.Connect | CoreLua.print Example using: Activate The Ability Activate() function behaves as if the player had pressed the key binding. In order for a server gameplay decision to result in an ability activation, it must be communicated over the network somehow. In this example, a trigger overlap is representative of an arbitrary gameplay decision on the server. A broadcast message is sent to the client, who receives the event and activates the ability. --Server script local trigger = script.parent local function OnBeginOverlap(trigger, other) if other:IsA(\"Player\") then Events.BroadcastToPlayer(other, \"SteppedOnObject\") end end trigger.beginOverlapEvent(OnBeginOverlap) --[[#description Client context script under the ability: ]] local ability = script:FindAncestorByType(\"Ability\") function OnPlayAnimation() if ability.owner and ability.owner == Game.GetLocalPlayer() then ability:Activate() end end Events.Connect(\"SteppedOnObject\", OnPlayAnimation) See also: CoreObject.parent | Trigger.beginOverlapEvent | other.IsA | Events.BroadcastToPlayer | Ability.owner | Game.GetLocalPlayer() Example using: AdvancePhase GetCurrentPhase In this example an ability is on cooldown, but can be set back to Ready by calling AdvancePhase() . function EndAbilityCooldown(ability) if ability:GetCurrentPhase() == AbilityPhase.COOLDOWN then ability:AdvancePhase() end end Example using: GetCurrentPhase GetPhaseTimeRemaining In this example, while the ability is on cooldown, the percentage completion of the cooldown is calculated. This could be useful, for instance, in displaying user interface. local ability = script:FindAncestorByType(\"Ability\") function Tick() if ability:GetCurrentPhase() == AbilityPhase.COOLDOWN then local duration = ability.cooldownPhaseSettings.duration local remaining = ability:GetPhaseTimeRemaining() local percent = 100 * (1 - remaining / duration) print(\"Cooldown remaining: %\" .. string.format(\"%.2f\",percent)) end end See also: CoreObject.FindAncestorByType | Ability.GetCurrentPhase | AbilityPhaseSettings.duration | CoreLua.print Example using: GetTargetData SetTargetData The ability's targeting data gives a lot of information about where and what the player is aiming at. If setup correctly, it can also be modified programmatically. In this example, the Z position of the target is flattened horizontally. Useful, for example, in a top-down shooter. For this to work it should be placed in a client context under the ability. The ability should also have the option \"Is Target Data Update\" turned off for the Execute phase, otherwise any data set programmatically will be overwritten when the phase changes. --Server script local ability = script:FindAncestorByType(\"Ability\") function OnCast(ability) local abilityTarget = ability:GetTargetData() local pos = abilityTarget:GetHitPosition() pos.z = ability.owner:GetWorldPosition().z + 50 abilityTarget:SetHitPosition(pos) ability:SetTargetData(abilityTarget) end ability.castEvent:Connect(OnCast) See also: CoreObject.FindAncestorByType | AbilityTarget.GetHitPosition | Ability.owner | Player.GetWorldPosition | Event.Connect Example using: Interrupt Interrupting an ability either sends it back into ready state (if it was still in the Cast phase) or puts it on cooldown. In this example, we have an ability that searches for all enemies in a 10 meter radius and interrupts their abilities. --Server script local ability = script.parent local RADIUS = 1000 -- 10 meters function OnExecute(ability) local center = ability.owner:GetWorldPosition() -- Search for enemies local enemies = Game.FindPlayersInCylinder(center, RADIUS, {ignoreTeams = ability.owner.team}) for _, enemy in ipairs(enemies) do -- Interrupt all their abilities local enemyAbilities = enemy:GetAbilities() for _,a in ipairs(enemyAbilities) do a:Interrupt() end end end ability.executeEvent:Connect(OnExecute) See also: CoreObject.parent | Ability.owner | Player.GetWorldPosition | Game.FindPlayersInCylinder | Event.Connect Example using: actionName Even though some API properties are read-only, they are useful is solutions such as user interface. In this example, a client context script searches the local player's list of abilities to find one that matches the action name (input) designated for this UI component. When it's found, the ability's name is written to the UI Text object. --Client script local ACTION_NAME = script:GetCustomProperty(\"ActionName\") local NAME_UI = script:GetCustomProperty(\"NameUIText\"):WaitForObject() function GetLocalPlayerAbilityWithActionName() local player = Game.GetLocalPlayer() local abilities = player:GetAbilities() for _, ability in pairs(abilities) do if ability.actionName == ACTION_NAME then return ability end end return nil end function Tick() local ability = GetLocalPlayerAbilityWithActionName() if ability then NAME_UI.text = ability.name end end See also: CoreObject.name | CoreObjectReference.WaitForObject | Game.GetLocalPlayer | Player.GetAbilities | UIText.text Example using: animation In this example, the ProcessAbilities() function can be called once, such as at the beginning of a round, to take inventory of a player's abilities and classify them based on animation. This example also demonstrates how to disconnect event listeners so that we don't listen for the same event multiple times. --Server script function OnMelee1HandCast(ability) print(\"One-handed melee attack\") end function OnMelee2HandCast(ability) print(\"Two-handed melee attack\") end local abilityEventListeners = {} function CleanupListeners(player) -- If we have previously processed this player, cleanup all listeners if abilityEventListeners[player] then for i, eventListener in ipairs(abilityEventListeners[player]) do eventListener:Disconnect() end abilityEventListeners[player] = nil end end function ProcessAbilities(player) CleanupListeners(player) local allAbilities = player:GetAbilities() for _, ability in ipairs(allAbilities) do if string.match(ability.animation, \"melee\") then local eventListener if string.match(ability.animation, \"1h\") then eventListener = ability.castEvent:Connect(OnMelee1HandCast) else eventListener = ability.castEvent:Connect(OnMelee2HandCast) end table.insert(abilityEventListeners[player], eventListener) end end end -- Lets also cleanup when a player leaves the game, as perhaps their ability objects might stay in the game. Game.playerLeftEvent:Connect(CleanupListeners) See also: EventListener.Disconnect | Player.GetAbilities | Ability.castEvent | Event.Connect | Game.playerLeftEvent | CoreLua.print Example using: canActivateWhileDead Some games may have abilities that can be used while the player is dead. In this example, we have abilities that can only be activated while dead. If not dead, then it's interrupted. --Server script local ability = script:FindAncestorByType(\"Ability\") function OnCast(ability) if ability.canActivateWhileDead and not ability.owner.isDead then ability:Interrupt() end end ability.castEvent:Connect(OnCast) --[[#description On the client context, a user interface component that displays ability details is hidden until the player dies: ]] local abilityCanvas = script:GetCustomProperty(\"Canvas\") local ACTION_NAME = script:GetCustomProperty(\"ActionName\") function Tick(deltaTime) local ability = GetLocalPlayerAbilityWithActionName() if ability and ability.isEnabled and ability.canActivateWhileDead and ability.owner and ability.owner.isDead then abilityCanvas.visibility = Visibility.INHERIT else abilityCanvas.visibility = Visibility.FORCE_OFF end end -- Searches the local player's abilities until one with a matching action name is found -- The ACTION_NAME search criteria should be set in the custom property function GetLocalPlayerAbilityWithActionName() local abilities = Game.GetLocalPlayer():GetAbilities() for _, ability in pairs(abilities) do if ability.actionName == ACTION_NAME then return ability end end return nil end See also: CoreObject.FindAncestorByType | Ability.owner | Player.isDead | Event.Connect | CoreLua.Tick Example using: canBePrevented In this example, an ability recognizes that it has been interrupted by the activation of another, special ability, that is setup to serve for animation cancelling. The canBePrevented property is usually true in this game, but in this special case it has been configured as false so that it can be activated at any time. The player gains vertical impulse as result of the synergy and hears a small audio cue that helps communicate the mechanic. --Server script local ability = script.parent local cancelSound = script:GetCustomProperty(\"CancelSound\") function OnInterrupted(ability) local player = ability.owner if not Object.IsValid(player) then return end for _, a in ipairs(player:GetAbilities()) do if a:GetCurrentPhase() ~= AbilityPhase.READY and not a.canBePrevented then player:AddImpulse(Vector3.UP * 1000) World.SpawnAsset(cancelSound, {position = player:GetWorldPosition()}) return end end end ability.interruptedEvent:Connect(OnInterrupted) See also: CoreObject.parent | Ability.owner | Object.IsValid | Player.GetAbilities | Vector3.UP | World.SpawnAsset | Event.Connect Example using: castPhaseSettings executePhaseSettings recoveryPhaseSettings cooldownPhaseSettings In this example, a function in a client context script can be called to show the elapsed times for an ability. The UI Text it controls displays how many seconds are remaining in the current phase, and the color of the text blends from black to white to indicate the percentage of completion. Although the Execute and Recovery phases are actually separate, they are here presented to the player as a single phase. --Client script local COUNTDOWN_TEXT = script:GetCustomProperty(\"CountdownText\"):WaitForObject() function UpdateForAbility(ability) local currentPhase = ability:GetCurrentPhase() local percent = 1 local cooldownText = \"Ready\" if currentPhase ~= AbilityPhase.READY then local phaseDuration local timeRemaining = ability:GetPhaseTimeRemaining() if currentPhase == AbilityPhase.CAST then phaseDuration = ability.castPhaseSettings.duration elseif currentPhase == AbilityPhase.EXECUTE then -- In the case of Execute and Recovery phases, we can show those as a single one local recoveryD = ability.recoveryPhaseSettings.duration phaseDuration = ability.executePhaseSettings.duration + recoveryD timeRemaining = timeRemaining + recoveryD elseif currentPhase == AbilityPhase.RECOVERY then phaseDuration = ability.recoveryPhaseSettings.duration else --currentPhase == AbilityPhase.COOLDOWN phaseDuration = ability.cooldownPhaseSettings.duration end if phaseDuration > 0 then percent = 1 - timeRemaining / phaseDuration end cooldownText = string.format(\"%.1f\", timeRemaining) end COUNTDOWN_TEXT.text = cooldownText local c = Color.Lerp(Color.BLACK, Color.WHITE, percent) COUNTDOWN_TEXT:SetColor(c) end See also: CoreObject.GetCustomProperty | CoreObjectReference.WaitForObject | Ability.GetCurrentPhase | AbilityPhaseSettings.duration | UIText.text | Color.Lerp Example using: isEnabled In this example, an equipment is setup with multiple abilities that all use the same action binding. This script cycles through the abilities, making sure only one is enabled at a time. The owner property is cleared for the previous ability and set for the next one, as part of ensuring the correct one activates when the binding is pressed. --Server script local equipment = script:FindAncestorByType(\"Equipment\") local abilities = {} local abilityIndex = 1 function OnAbilityRecovery(ability) if (#abilities > 1) then abilities[abilityIndex].isEnabled = false abilities[abilityIndex].owner = nil abilityIndex = abilityIndex + 1 if (abilityIndex > #abilities) then abilityIndex = 1 end abilities[abilityIndex].isEnabled = true abilities[abilityIndex].owner = equipment.owner end end for _, child in pairs(equipment:FindDescendantsByType(\"Ability\")) do table.insert(abilities, child) child.isEnabled = (#abilities == 1) child.recoveryEvent:Connect(OnAbilityRecovery) end See also: CoreObject.FindAncestorByType | Ability.owner | Equipment.owner | Event.Connect Example using: owner Usually, abilities are presented as part of an equipment, but that isn't a requirement. In this example, when new players join the game they are assigned an ability through the use of the owner property. --Server script local abilityTemplate = script:GetCustomProperty(\"AbilityTemplate\") function OnPlayerJoined(player) local ability = World.SpawnAsset(abilityTemplate) ability.owner = player end Game.playerJoinedEvent:Connect(OnPlayerJoined) See also: CoreObject.GetCustomProperty | World.SpawnAsset | Player.owner | Game.playerJoinedEvent | Event.Connect Tutorials Abilities in Core","title":"Ability"},{"location":"libs/_template_/#ability","text":"Abilities are CoreObjects that can be added to Players and guide the Player's animation in sync with the Ability's state machine. Spawn an Ability with World.SpawnAsset() or add an Ability as a child of an Equipment/Weapon to have it be assigned to the Player automatically when that item is equipped. Abilities can be activated by association with an Action Binding. Their internal state machine flows through the phases: Ready, Cast, Execute, Recovery, and Cooldown. An Ability begins in the Ready state and transitions to Cast when its Binding (for example Left mouse click) is activated by the owning player. It then automatically flows from Cast to Execute, then Recovery and finally Cooldown. At each of these state transitions it fires a corresponding event. Only one ability can be active at a time. By default, activating an ability will interrupt the currently active ability. The canBePrevented and preventsOtherAbilities properties can be used to customize interruption rules for competing abilities. If an ability is interrupted during the Cast phase, it will immediately reset to the Ready state. If an ability is interrupted during the Execute or Recovery phase, the ability will immediately transition to the Cooldown phase.","title":"Ability"},{"location":"libs/_template_/#properties","text":"Property Name Return Type Description Tags isEnabled boolean Turns an Ability on/off. It stays on the Player but is interrupted if isEnabled is set to false during an active Ability. True by default. Read-Write canActivateWhileDead boolean Indicates if the Ability can be used while the owning Player is dead. False by default. Read-Only name string The name of the Ability. Read-Only actionBinding string This property is deprecated. Please use actionName instead, but note that actionBinding and actionName use different values. Which action binding will cause the Ability to activate. Possible values of the bindings are listed on the Ability binding page. Read-Only, Deprecated actionName string Which binding set action name will cause the Ability to activate. See Binding Sets reference. Read-Only owner Player Assigning an owner applies the Ability to that Player. Read-Write castPhaseSettings AbilityPhaseSettings Config data for the Cast phase (see below). Read-Only executePhaseSettings AbilityPhaseSettings Config data for the Execute phase. Read-Only recoveryPhaseSettings AbilityPhaseSettings Config data for the Recovery phase. Read-Only cooldownPhaseSettings AbilityPhaseSettings Config data for the Cooldown phase. Read-Only animation string Name of the animation the Player will play when the Ability is activated. Possible values: See Ability Animation for strings and other info. Read-Only canBePrevented boolean Used in conjunction with the phase property preventsOtherAbilities so multiple abilities on the same Player can block each other during specific phases. True by default. Read-Only","title":"Properties"},{"location":"libs/_template_/#functions","text":"Function Name Return Type Description Tags Activate() None Activates an Ability as if the button had been pressed. None Interrupt() None Changes an Ability from Cast phase to Ready phase. If the Ability is in either Execute or Recovery phases it instead goes to Cooldown phase. None AdvancePhase() None Advances a currently active Ability from its current phase to the next phase. For example, an ability in the Cast phase will begin the Execute phase, an ability on cooldown will become ready, etc. None GetCurrentPhase() AbilityPhase The current AbilityPhase for this Ability. These are returned as one of: AbilityPhase.READY, AbilityPhase.CAST, AbilityPhase.EXECUTE, AbilityPhase.RECOVERY and AbilityPhase.COOLDOWN. None GetCurrentPhaseSettings() AbilityPhaseSettings Returns the settings for the current phase of this Ability. Returns nil if the current phase is AbilityPhase.READY . None GetPhaseTimeRemaining() number Seconds left in the current phase. None GetTargetData() AbilityTarget Returns information about what the Player has targeted this phase. None SetTargetData(AbilityTarget) None Updates information about what the Player has targeted this phase. This can affect the execution of the Ability. None","title":"Functions"},{"location":"libs/_template_/#events","text":"Event Name Return Type Description Tags readyEvent Event < Ability > Fired when the Ability becomes ready. In this phase it is possible to activate it again. None castEvent Event < Ability > Fired when the Ability enters the Cast phase. None executeEvent Event < Ability > Fired when the Ability enters Execute phase. None recoveryEvent Event < Ability > Fired when the Ability enters Recovery. None cooldownEvent Event < Ability > Fired when the Ability enters Cooldown. None interruptedEvent Event < Ability > Fired when the Ability is interrupted. None tickEvent Event < Ability ability, number deltaTime> Fired every tick while the Ability is active (isEnabled = true and phase is not ready). None","title":"Events"},{"location":"libs/_template_/#examples","text":"Example using:","title":"Examples"},{"location":"libs/_template_/#castevent","text":"The Cast phase begins as soon as an ability is activated. By checking if the player casting the ability isGrounded we can create an effect that propels you upwards, but it doesn't work if you are already jumping or flying. We detect this is the castEvent , which is early enough for an Interrupt() to reset the ability. --Server script local ability = script.parent function OnCast(ability) if ability.owner.isGrounded then ability.owner:SetVelocity(Vector3.UP * 2000) else ability:Interrupt() end end ability.castEvent:Connect(OnCast) See also: CoreObject.parent | Ability.owner | Player.isGrounded | Vector3.UP | Event.Connect Example using:","title":"castEvent"},{"location":"libs/_template_/#cooldownevent","text":"In this example, a fighting game has an \"invincible\" mechanic where player attacks are not interrupted while they have this effect. Some powerful attacks make the player invincible during the entire active cycle of the ability. The effect is gained at the beginning of the cast phase and is removed at the end of the recovery phase, before the cooldown begins. The resource system is used in keeping track of the invincibility effect. --Server script local ability = script.parent function OnCast(ability) ability.owner:AddResource(\"invincible\", 1) end function OnCooldown(ability) ability.owner:RemoveResource(\"invincible\", 1) end ability.castEvent:Connect(OnCast) ability.cooldownEvent:Connect(OnCooldown) See also: CoreObject.parent | Player.owner | Ability.castEvent | Event.Connect Example using:","title":"cooldownEvent"},{"location":"libs/_template_/#executeevent","text":"Weapons implement lots of built-in gameplay that doesn't require any scripting, such as attack and reload abilities. However, they can be augmented with additional mechanics. In this example, a special sound effect is played when a weapon shoots while low on ammunition. The script expects to be a child of a weapon's \"Shoot\" ability. --Server script local ability = script.parent local weapon = script:FindAncestorByType('Weapon') local lowAmmoSound = script:GetCustomProperty(\"LowAmmoSound\") local LOW_AMMO_PERCENTAGE = 0.2 function OnExecute(ability) if weapon.currentAmmo / weapon.maxAmmo <= LOW_AMMO_PERCENTAGE then World.SpawnAsset(lowAmmoSound, {position = weapon:GetWorldPosition()}) end end ability.executeEvent:Connect(OnExecute) See also: CoreObject.parent | Weapon.currentAmmo | World.SpawnAsset | Ability.executeEvent | Event.Connect Example using:","title":"executeEvent"},{"location":"libs/_template_/#interruptedevent","text":"The interruptedEvent fires when an ability is going through it's activation process and Interrupt() is called on it, or if it becomes disabled. In this example, interruption is a key part of the game design, so a visual effect is spawned at the player's position to help communicate the interaction between players. --Server script local ability = script.parent local interruptedVfx = script:GetCustomProperty(\"InterruptedVfx\") function OnInterrupted(ability) if Object.IsValid(ability.owner) then World.SpawnAsset(interruptedVfx, {position = ability.owner:GetWorldPosition()}) end end ability.interruptedEvent:Connect(OnInterrupted) See also: CoreObject.parent | Object.IsValid | Ability.owner | World.SpawnAsset | Player.GetWorldPosition | Event.Connect Example using:","title":"interruptedEvent"},{"location":"libs/_template_/#readyevent","text":"The Ready phase begins when an ability comes off cooldown and is \"ready\" to be used again. In this example, we create an invisibility effect that takes advantage of the readyEvent , leveraging the cooldown duration of the ability as a clock to determine when to make the player visible again. -- Server script local ability = script.parent function OnExecute(ability) -- Hide the player ability.owner:SetVisibility(false) end function OnReady(ability) -- Show the player ability.owner:SetVisibility(true) end ability.readyEvent:Connect(OnReady) ability.executeEvent:Connect(OnExecute) See also: CoreObject.parent | Ability.owner | Player.SetVisibility | Event.Connect Example using:","title":"readyEvent"},{"location":"libs/_template_/#recoveryevent","text":"The recoveryEvent marks the end of an ability's Execute phase and the beginning of its Recovery phase. In this example, a melee punch ability has a trigger that causes damage to enemies who overlap it. For it to work the trigger is only enabled for a brief moment, during the Execute phase. --Server script local ability = script.parent local trigger = script:GetCustomProperty(\"ImpactTrigger\"):WaitForObject() trigger.collision = Collision.FORCE_OFF local DAMAGE_AMOUNT = 10 function OnExecute(ability) trigger.collision = Collision.FORCE_ON end function OnRecovery(ability) trigger.collision = Collision.FORCE_OFF end ability.executeEvent:Connect(OnExecute) ability.recoveryEvent:Connect(OnRecovery) function OnBeginOverlap(trigger, other) -- Only damage enemy players if other:IsA(\"Player\") and other.team ~= ability.owner.team then other:ApplyDamage(Damage.New(DAMAGE_AMOUNT)) end end trigger.beginOverlapEvent:Connect(OnBeginOverlap) See also: CoreObject.parent | CoreObjectReference.WaitForObject | Ability.executeEvent | Event.Connect | other.IsA | Player.team | Damage.New | Trigger.beginOverlapEvent Example using:","title":"recoveryEvent"},{"location":"libs/_template_/#tickevent","text":"Abilities fire the tickEvent while they are active or on cooldown (not on Ready state). In this example, a piece of equipment carries several abilities, but we want to do a common update logic on all of them. Note: Ability.tickEvent works somewhat differently from a Tick() function - tickEvent is an actual event that just happens to fire once per tick. Each invocation of the callback runs on its own task. This means that, unlike Tick() , there is no guarantee that it will wait for the previous tickEvent to finish before starting the next one. This means you can't use things like Task.Wait() to add time between ticks. local equipment = script.parent local allAbilities = equipment:GetAbilities() function OnTick(ability, deltaTime) print(\"Updating ability \" .. ability.name) end for _, ability in ipairs(allAbilities) do ability.tickEvent:Connect(OnTick) end See also: CoreObject.parent | Equipment.GetAbilities | Event.Connect | CoreLua.print Example using:","title":"tickEvent"},{"location":"libs/_template_/#activate","text":"The Ability Activate() function behaves as if the player had pressed the key binding. In order for a server gameplay decision to result in an ability activation, it must be communicated over the network somehow. In this example, a trigger overlap is representative of an arbitrary gameplay decision on the server. A broadcast message is sent to the client, who receives the event and activates the ability. --Server script local trigger = script.parent local function OnBeginOverlap(trigger, other) if other:IsA(\"Player\") then Events.BroadcastToPlayer(other, \"SteppedOnObject\") end end trigger.beginOverlapEvent(OnBeginOverlap) --[[#description Client context script under the ability: ]] local ability = script:FindAncestorByType(\"Ability\") function OnPlayAnimation() if ability.owner and ability.owner == Game.GetLocalPlayer() then ability:Activate() end end Events.Connect(\"SteppedOnObject\", OnPlayAnimation) See also: CoreObject.parent | Trigger.beginOverlapEvent | other.IsA | Events.BroadcastToPlayer | Ability.owner | Game.GetLocalPlayer() Example using:","title":"Activate"},{"location":"libs/_template_/#advancephase","text":"","title":"AdvancePhase"},{"location":"libs/_template_/#getcurrentphase","text":"In this example an ability is on cooldown, but can be set back to Ready by calling AdvancePhase() . function EndAbilityCooldown(ability) if ability:GetCurrentPhase() == AbilityPhase.COOLDOWN then ability:AdvancePhase() end end Example using:","title":"GetCurrentPhase"},{"location":"libs/_template_/#getcurrentphase_1","text":"","title":"GetCurrentPhase"},{"location":"libs/_template_/#getphasetimeremaining","text":"In this example, while the ability is on cooldown, the percentage completion of the cooldown is calculated. This could be useful, for instance, in displaying user interface. local ability = script:FindAncestorByType(\"Ability\") function Tick() if ability:GetCurrentPhase() == AbilityPhase.COOLDOWN then local duration = ability.cooldownPhaseSettings.duration local remaining = ability:GetPhaseTimeRemaining() local percent = 100 * (1 - remaining / duration) print(\"Cooldown remaining: %\" .. string.format(\"%.2f\",percent)) end end See also: CoreObject.FindAncestorByType | Ability.GetCurrentPhase | AbilityPhaseSettings.duration | CoreLua.print Example using:","title":"GetPhaseTimeRemaining"},{"location":"libs/_template_/#gettargetdata","text":"","title":"GetTargetData"},{"location":"libs/_template_/#settargetdata","text":"The ability's targeting data gives a lot of information about where and what the player is aiming at. If setup correctly, it can also be modified programmatically. In this example, the Z position of the target is flattened horizontally. Useful, for example, in a top-down shooter. For this to work it should be placed in a client context under the ability. The ability should also have the option \"Is Target Data Update\" turned off for the Execute phase, otherwise any data set programmatically will be overwritten when the phase changes. --Server script local ability = script:FindAncestorByType(\"Ability\") function OnCast(ability) local abilityTarget = ability:GetTargetData() local pos = abilityTarget:GetHitPosition() pos.z = ability.owner:GetWorldPosition().z + 50 abilityTarget:SetHitPosition(pos) ability:SetTargetData(abilityTarget) end ability.castEvent:Connect(OnCast) See also: CoreObject.FindAncestorByType | AbilityTarget.GetHitPosition | Ability.owner | Player.GetWorldPosition | Event.Connect Example using:","title":"SetTargetData"},{"location":"libs/_template_/#interrupt","text":"Interrupting an ability either sends it back into ready state (if it was still in the Cast phase) or puts it on cooldown. In this example, we have an ability that searches for all enemies in a 10 meter radius and interrupts their abilities. --Server script local ability = script.parent local RADIUS = 1000 -- 10 meters function OnExecute(ability) local center = ability.owner:GetWorldPosition() -- Search for enemies local enemies = Game.FindPlayersInCylinder(center, RADIUS, {ignoreTeams = ability.owner.team}) for _, enemy in ipairs(enemies) do -- Interrupt all their abilities local enemyAbilities = enemy:GetAbilities() for _,a in ipairs(enemyAbilities) do a:Interrupt() end end end ability.executeEvent:Connect(OnExecute) See also: CoreObject.parent | Ability.owner | Player.GetWorldPosition | Game.FindPlayersInCylinder | Event.Connect Example using:","title":"Interrupt"},{"location":"libs/_template_/#actionname","text":"Even though some API properties are read-only, they are useful is solutions such as user interface. In this example, a client context script searches the local player's list of abilities to find one that matches the action name (input) designated for this UI component. When it's found, the ability's name is written to the UI Text object. --Client script local ACTION_NAME = script:GetCustomProperty(\"ActionName\") local NAME_UI = script:GetCustomProperty(\"NameUIText\"):WaitForObject() function GetLocalPlayerAbilityWithActionName() local player = Game.GetLocalPlayer() local abilities = player:GetAbilities() for _, ability in pairs(abilities) do if ability.actionName == ACTION_NAME then return ability end end return nil end function Tick() local ability = GetLocalPlayerAbilityWithActionName() if ability then NAME_UI.text = ability.name end end See also: CoreObject.name | CoreObjectReference.WaitForObject | Game.GetLocalPlayer | Player.GetAbilities | UIText.text Example using:","title":"actionName"},{"location":"libs/_template_/#animation","text":"In this example, the ProcessAbilities() function can be called once, such as at the beginning of a round, to take inventory of a player's abilities and classify them based on animation. This example also demonstrates how to disconnect event listeners so that we don't listen for the same event multiple times. --Server script function OnMelee1HandCast(ability) print(\"One-handed melee attack\") end function OnMelee2HandCast(ability) print(\"Two-handed melee attack\") end local abilityEventListeners = {} function CleanupListeners(player) -- If we have previously processed this player, cleanup all listeners if abilityEventListeners[player] then for i, eventListener in ipairs(abilityEventListeners[player]) do eventListener:Disconnect() end abilityEventListeners[player] = nil end end function ProcessAbilities(player) CleanupListeners(player) local allAbilities = player:GetAbilities() for _, ability in ipairs(allAbilities) do if string.match(ability.animation, \"melee\") then local eventListener if string.match(ability.animation, \"1h\") then eventListener = ability.castEvent:Connect(OnMelee1HandCast) else eventListener = ability.castEvent:Connect(OnMelee2HandCast) end table.insert(abilityEventListeners[player], eventListener) end end end -- Lets also cleanup when a player leaves the game, as perhaps their ability objects might stay in the game. Game.playerLeftEvent:Connect(CleanupListeners) See also: EventListener.Disconnect | Player.GetAbilities | Ability.castEvent | Event.Connect | Game.playerLeftEvent | CoreLua.print Example using:","title":"animation"},{"location":"libs/_template_/#canactivatewhiledead","text":"Some games may have abilities that can be used while the player is dead. In this example, we have abilities that can only be activated while dead. If not dead, then it's interrupted. --Server script local ability = script:FindAncestorByType(\"Ability\") function OnCast(ability) if ability.canActivateWhileDead and not ability.owner.isDead then ability:Interrupt() end end ability.castEvent:Connect(OnCast) --[[#description On the client context, a user interface component that displays ability details is hidden until the player dies: ]] local abilityCanvas = script:GetCustomProperty(\"Canvas\") local ACTION_NAME = script:GetCustomProperty(\"ActionName\") function Tick(deltaTime) local ability = GetLocalPlayerAbilityWithActionName() if ability and ability.isEnabled and ability.canActivateWhileDead and ability.owner and ability.owner.isDead then abilityCanvas.visibility = Visibility.INHERIT else abilityCanvas.visibility = Visibility.FORCE_OFF end end -- Searches the local player's abilities until one with a matching action name is found -- The ACTION_NAME search criteria should be set in the custom property function GetLocalPlayerAbilityWithActionName() local abilities = Game.GetLocalPlayer():GetAbilities() for _, ability in pairs(abilities) do if ability.actionName == ACTION_NAME then return ability end end return nil end See also: CoreObject.FindAncestorByType | Ability.owner | Player.isDead | Event.Connect | CoreLua.Tick Example using:","title":"canActivateWhileDead"},{"location":"libs/_template_/#canbeprevented","text":"In this example, an ability recognizes that it has been interrupted by the activation of another, special ability, that is setup to serve for animation cancelling. The canBePrevented property is usually true in this game, but in this special case it has been configured as false so that it can be activated at any time. The player gains vertical impulse as result of the synergy and hears a small audio cue that helps communicate the mechanic. --Server script local ability = script.parent local cancelSound = script:GetCustomProperty(\"CancelSound\") function OnInterrupted(ability) local player = ability.owner if not Object.IsValid(player) then return end for _, a in ipairs(player:GetAbilities()) do if a:GetCurrentPhase() ~= AbilityPhase.READY and not a.canBePrevented then player:AddImpulse(Vector3.UP * 1000) World.SpawnAsset(cancelSound, {position = player:GetWorldPosition()}) return end end end ability.interruptedEvent:Connect(OnInterrupted) See also: CoreObject.parent | Ability.owner | Object.IsValid | Player.GetAbilities | Vector3.UP | World.SpawnAsset | Event.Connect Example using:","title":"canBePrevented"},{"location":"libs/_template_/#castphasesettings","text":"","title":"castPhaseSettings"},{"location":"libs/_template_/#executephasesettings","text":"","title":"executePhaseSettings"},{"location":"libs/_template_/#recoveryphasesettings","text":"","title":"recoveryPhaseSettings"},{"location":"libs/_template_/#cooldownphasesettings","text":"In this example, a function in a client context script can be called to show the elapsed times for an ability. The UI Text it controls displays how many seconds are remaining in the current phase, and the color of the text blends from black to white to indicate the percentage of completion. Although the Execute and Recovery phases are actually separate, they are here presented to the player as a single phase. --Client script local COUNTDOWN_TEXT = script:GetCustomProperty(\"CountdownText\"):WaitForObject() function UpdateForAbility(ability) local currentPhase = ability:GetCurrentPhase() local percent = 1 local cooldownText = \"Ready\" if currentPhase ~= AbilityPhase.READY then local phaseDuration local timeRemaining = ability:GetPhaseTimeRemaining() if currentPhase == AbilityPhase.CAST then phaseDuration = ability.castPhaseSettings.duration elseif currentPhase == AbilityPhase.EXECUTE then -- In the case of Execute and Recovery phases, we can show those as a single one local recoveryD = ability.recoveryPhaseSettings.duration phaseDuration = ability.executePhaseSettings.duration + recoveryD timeRemaining = timeRemaining + recoveryD elseif currentPhase == AbilityPhase.RECOVERY then phaseDuration = ability.recoveryPhaseSettings.duration else --currentPhase == AbilityPhase.COOLDOWN phaseDuration = ability.cooldownPhaseSettings.duration end if phaseDuration > 0 then percent = 1 - timeRemaining / phaseDuration end cooldownText = string.format(\"%.1f\", timeRemaining) end COUNTDOWN_TEXT.text = cooldownText local c = Color.Lerp(Color.BLACK, Color.WHITE, percent) COUNTDOWN_TEXT:SetColor(c) end See also: CoreObject.GetCustomProperty | CoreObjectReference.WaitForObject | Ability.GetCurrentPhase | AbilityPhaseSettings.duration | UIText.text | Color.Lerp Example using:","title":"cooldownPhaseSettings"},{"location":"libs/_template_/#isenabled","text":"In this example, an equipment is setup with multiple abilities that all use the same action binding. This script cycles through the abilities, making sure only one is enabled at a time. The owner property is cleared for the previous ability and set for the next one, as part of ensuring the correct one activates when the binding is pressed. --Server script local equipment = script:FindAncestorByType(\"Equipment\") local abilities = {} local abilityIndex = 1 function OnAbilityRecovery(ability) if (#abilities > 1) then abilities[abilityIndex].isEnabled = false abilities[abilityIndex].owner = nil abilityIndex = abilityIndex + 1 if (abilityIndex > #abilities) then abilityIndex = 1 end abilities[abilityIndex].isEnabled = true abilities[abilityIndex].owner = equipment.owner end end for _, child in pairs(equipment:FindDescendantsByType(\"Ability\")) do table.insert(abilities, child) child.isEnabled = (#abilities == 1) child.recoveryEvent:Connect(OnAbilityRecovery) end See also: CoreObject.FindAncestorByType | Ability.owner | Equipment.owner | Event.Connect Example using:","title":"isEnabled"},{"location":"libs/_template_/#owner","text":"Usually, abilities are presented as part of an equipment, but that isn't a requirement. In this example, when new players join the game they are assigned an ability through the use of the owner property. --Server script local abilityTemplate = script:GetCustomProperty(\"AbilityTemplate\") function OnPlayerJoined(player) local ability = World.SpawnAsset(abilityTemplate) ability.owner = player end Game.playerJoinedEvent:Connect(OnPlayerJoined) See also: CoreObject.GetCustomProperty | World.SpawnAsset | Player.owner | Game.playerJoinedEvent | Event.Connect","title":"owner"},{"location":"libs/_template_/#tutorials","text":"Abilities in Core","title":"Tutorials"},{"location":"libs/lua-ads/","text":"","title":"ADS communication (TwinCat, Nexeed, Beckhoff)"},{"location":"libs/lua-hid/","text":"","title":"USB HID Devices (Buttons, Arduino, etc.)"},{"location":"libs/lua-modbus/","text":"","title":"Modbus/TCP/UDP communication"},{"location":"libs/lua-opcua/","text":"","title":"OpcUA communication"},{"location":"tools/","text":"Tool configuration Overview station.ini","title":"Overview"},{"location":"tools/#tool-configuration","text":"","title":"Tool configuration"},{"location":"tools/#overview","text":"","title":"Overview"},{"location":"tools/#stationini","text":"","title":"station.ini"},{"location":"tools/remote-tool/","text":"RemoteTool OGS supports connecting tools over a ToolGateway . This enables advanced tool management scenarios, e.g. \"roaming\" tools between multiple stations. Using the RemoteTool driver requires a ToolGateway running on a server - the server then actually controls the tool, whereas the OGS stations only communication with the ToolGateway . This allows delegating tool management to the central ToolGateway . For each tool managed through the ToolGateway , OGS only uses a generic RemoteTool type channel in its local configuration, the ToolGateway then has the actual tool-specific configuration (like e.g. OpenProtocol tools ). Installation The RemoteTool driver is implemented in RemoteTool.dll . To use any RemoteTool tool, the driver must be loaded in the [TOOL_DLL] section of the projects station.ini configuration file (see also Tool configuration ). To enable the driver in station.ini, set it as follows: [TOOL_DLL] RemoteTool.dll=1 The overall parameters for the RemoteTool driver are configured in the \u00b4[RemoteTool] section. This is basically used to configure the ToolGateway` connection parameters, here is a sample setup: [RemoteTool] ToolGateway_Addr=mytoolgateway.mycompany.com ToolGateway_Port= For more information about the driver parameters, see Driver Parameters below. Tool registration and configuration All RemoteTool -tools are registered in the [CHANNELS] section of the projects station.ini file. The [CHANNELS] section only defines a channel number to channel name mapping - the channel/tool specific settings are then configured in a seperate section defined by the channel name. Inside the section, a reference to the RemoteTool driver then links driver and channel accordingly. The overall layout is therefore as follows (sample is for channel 2): [CHANNELS] # Map the channel/tool 2 to the 'RemoteTool_Nexo1'-section 2=RemoteTool_Nexo1 [RemoteTool_Nexo1] # link to the RemoteTool driver DRIVER=RemoteTool # more channel/tool specific parameters for this tool/driver Please see Channel/tool parameter reference below for more information about the available parameters. Channel/tool parameter reference Currently, there are no channel/tool-specific parameters needed (other than specifying the DRIVER=RemoteTool ) to use this driver. All concrete tool communication settings are to be configured on the ToolGateway server side. Driver parameter reference The driver parameters are defined in the [RemoteTool] section in the projects station.ini . The following parameters are available: ToolGateway_Addr IP address or hostname of the tool gateway. ToolGateway_Port (optional) Port number to use for connecting to the tool gateway. If not given, the driver tries to use the RPC endpoint mapper using the service UUID to resolve the connection endpoint (might require additional firewall settings).","title":"Remote Tool"},{"location":"tools/remote-tool/#remotetool","text":"OGS supports connecting tools over a ToolGateway . This enables advanced tool management scenarios, e.g. \"roaming\" tools between multiple stations. Using the RemoteTool driver requires a ToolGateway running on a server - the server then actually controls the tool, whereas the OGS stations only communication with the ToolGateway . This allows delegating tool management to the central ToolGateway . For each tool managed through the ToolGateway , OGS only uses a generic RemoteTool type channel in its local configuration, the ToolGateway then has the actual tool-specific configuration (like e.g. OpenProtocol tools ).","title":"RemoteTool"},{"location":"tools/remote-tool/#installation","text":"The RemoteTool driver is implemented in RemoteTool.dll . To use any RemoteTool tool, the driver must be loaded in the [TOOL_DLL] section of the projects station.ini configuration file (see also Tool configuration ). To enable the driver in station.ini, set it as follows: [TOOL_DLL] RemoteTool.dll=1 The overall parameters for the RemoteTool driver are configured in the \u00b4[RemoteTool] section. This is basically used to configure the ToolGateway` connection parameters, here is a sample setup: [RemoteTool] ToolGateway_Addr=mytoolgateway.mycompany.com ToolGateway_Port= For more information about the driver parameters, see Driver Parameters below.","title":"Installation"},{"location":"tools/remote-tool/#tool-registration-and-configuration","text":"All RemoteTool -tools are registered in the [CHANNELS] section of the projects station.ini file. The [CHANNELS] section only defines a channel number to channel name mapping - the channel/tool specific settings are then configured in a seperate section defined by the channel name. Inside the section, a reference to the RemoteTool driver then links driver and channel accordingly. The overall layout is therefore as follows (sample is for channel 2): [CHANNELS] # Map the channel/tool 2 to the 'RemoteTool_Nexo1'-section 2=RemoteTool_Nexo1 [RemoteTool_Nexo1] # link to the RemoteTool driver DRIVER=RemoteTool # more channel/tool specific parameters for this tool/driver Please see Channel/tool parameter reference below for more information about the available parameters.","title":"Tool registration and configuration"},{"location":"tools/remote-tool/#channeltool-parameter-reference","text":"Currently, there are no channel/tool-specific parameters needed (other than specifying the DRIVER=RemoteTool ) to use this driver. All concrete tool communication settings are to be configured on the ToolGateway server side.","title":"Channel/tool parameter reference"},{"location":"tools/remote-tool/#driver-parameter-reference","text":"The driver parameters are defined in the [RemoteTool] section in the projects station.ini . The following parameters are available:","title":"Driver parameter reference"},{"location":"tools/remote-tool/#toolgateway_addr","text":"IP address or hostname of the tool gateway.","title":"ToolGateway_Addr"},{"location":"tools/remote-tool/#toolgateway_port","text":"(optional) Port number to use for connecting to the tool gateway. If not given, the driver tries to use the RPC endpoint mapper using the service UUID to resolve the connection endpoint (might require additional firewall settings).","title":"ToolGateway_Port"},{"location":"tools/openprotocol/","text":"OpenProtocol tools OGS supports connecting tools with OpenProtocol interface. As tools differ in functionality and also different tool vendors implement the OpenProtocol specification in slightly different ways, OGS has special protocol handlers for the following tools: Rexroth Nexo and Nexo 2 wireless tools (for more information, see Nexo OpenProtocol ) Rexroth CS351 and KE350 system tools (for more information, see System 350 OpenProtocol ) GWK Operator+ torque wrenches (for more information, see GWK Operator+ OpenProtocol ) Crane TCI torque wrenches (for more information, see Crane OpenProtocol ) Gehmeyr Exact Wifi tools (for more information, see Gehmeyr OpenProtocol ) The overall configuration for these tools is similar and the actual driver has the same set of configuration parameters - described on this page. Installation The OpenProtocol driver is implemented in OpConn.dll . To use any OpenProtocol tool, the driver must be loaded in the [TOOL_DLL] section of the projects station.ini configuration file (see also Tool configuration ). Tool registration and configuration All OpenProtocol -tools are registered in the [OPENPROTO] section of the projects station.ini file. The [OPENPROTO] section mixes the tool parameters and the channel mapping (due to historic reasons) by combining the channel number and the parameter name/value in the station.ini entry. Each parameter is prefixed with the channel number and followed by parameter name as follows: CHANNEL_<two-digit channel>_<param name>=<param value> Where - <two-digit channel> is the channel number in the range 01...99 (the channel number maps 1:1 to the tool number from the workflow configuration) - <param name> is the parameter name (see Channel parameter reference ) - <param value> is the actual parameter value for the given parameter In addition to the channel-specific parameters, there are also shared parameters. These act as default parameters for the channel-specific settings and can be overridden by the channel specific values. For more details on the shared parameters, see Shared parameter reference ) below . A sample OpenProtocol tool configuration (channel 01) would therefore look similar to the following: [OPENPROTO] # Shared/default parameters PORT=4545 # Channel/Tool 1 parameters CHANNEL_01=10.10.2.163 CHANNEL_01_TYPE=NEXO CHANNEL_01_CHECK_TIME_ENABLED=1 CHANNEL_01_NEXONAR_CHANNEL=6 CHANNEL_01_CURVE_REQUEST=1 Shared parameter reference PORT (optional, defaults to 4545) EXTERNAL_IO_OFFSET CHECK_TIME_INTERVAL and TIME_TOLERANCE EXTERNAL_IO_OFFSET Channel parameter reference For specific information about a tools settings or the tools configuration needed (on the tool side), please see the tool-specific information. In general, the following parameters are available for a OpenProtocol -tool: Connection information PORT (optional, defaults to the shared parameter value) TYPE (mandatory) CCW_ACK PARAMS ALIVEXMTT SHOWALIVE RSPTIMEOUT BARCODE_MID0051_REV CHECK_EXT_COND APPL_START CURVE_REQUEST CHECK_TIME_ENABLED IGNORE_ID","title":"Overview"},{"location":"tools/openprotocol/#openprotocol-tools","text":"OGS supports connecting tools with OpenProtocol interface. As tools differ in functionality and also different tool vendors implement the OpenProtocol specification in slightly different ways, OGS has special protocol handlers for the following tools: Rexroth Nexo and Nexo 2 wireless tools (for more information, see Nexo OpenProtocol ) Rexroth CS351 and KE350 system tools (for more information, see System 350 OpenProtocol ) GWK Operator+ torque wrenches (for more information, see GWK Operator+ OpenProtocol ) Crane TCI torque wrenches (for more information, see Crane OpenProtocol ) Gehmeyr Exact Wifi tools (for more information, see Gehmeyr OpenProtocol ) The overall configuration for these tools is similar and the actual driver has the same set of configuration parameters - described on this page.","title":"OpenProtocol tools"},{"location":"tools/openprotocol/#installation","text":"The OpenProtocol driver is implemented in OpConn.dll . To use any OpenProtocol tool, the driver must be loaded in the [TOOL_DLL] section of the projects station.ini configuration file (see also Tool configuration ).","title":"Installation"},{"location":"tools/openprotocol/#tool-registration-and-configuration","text":"All OpenProtocol -tools are registered in the [OPENPROTO] section of the projects station.ini file. The [OPENPROTO] section mixes the tool parameters and the channel mapping (due to historic reasons) by combining the channel number and the parameter name/value in the station.ini entry. Each parameter is prefixed with the channel number and followed by parameter name as follows: CHANNEL_<two-digit channel>_<param name>=<param value> Where - <two-digit channel> is the channel number in the range 01...99 (the channel number maps 1:1 to the tool number from the workflow configuration) - <param name> is the parameter name (see Channel parameter reference ) - <param value> is the actual parameter value for the given parameter In addition to the channel-specific parameters, there are also shared parameters. These act as default parameters for the channel-specific settings and can be overridden by the channel specific values. For more details on the shared parameters, see Shared parameter reference ) below . A sample OpenProtocol tool configuration (channel 01) would therefore look similar to the following: [OPENPROTO] # Shared/default parameters PORT=4545 # Channel/Tool 1 parameters CHANNEL_01=10.10.2.163 CHANNEL_01_TYPE=NEXO CHANNEL_01_CHECK_TIME_ENABLED=1 CHANNEL_01_NEXONAR_CHANNEL=6 CHANNEL_01_CURVE_REQUEST=1","title":"Tool registration and configuration"},{"location":"tools/openprotocol/#shared-parameter-reference","text":"","title":"Shared parameter reference"},{"location":"tools/openprotocol/#port","text":"(optional, defaults to 4545)","title":"PORT"},{"location":"tools/openprotocol/#external_io_offset","text":"","title":"EXTERNAL_IO_OFFSET"},{"location":"tools/openprotocol/#check_time_interval-and-time_tolerance","text":"","title":"CHECK_TIME_INTERVAL and TIME_TOLERANCE"},{"location":"tools/openprotocol/#external_io_offset_1","text":"","title":"EXTERNAL_IO_OFFSET"},{"location":"tools/openprotocol/#channel-parameter-reference","text":"For specific information about a tools settings or the tools configuration needed (on the tool side), please see the tool-specific information. In general, the following parameters are available for a OpenProtocol -tool:","title":"Channel parameter reference"},{"location":"tools/openprotocol/#connection-information","text":"","title":"Connection information"},{"location":"tools/openprotocol/#port_1","text":"(optional, defaults to the shared parameter value)","title":"PORT"},{"location":"tools/openprotocol/#type","text":"(mandatory)","title":"TYPE"},{"location":"tools/openprotocol/#ccw_ack","text":"","title":"CCW_ACK"},{"location":"tools/openprotocol/#params","text":"","title":"PARAMS"},{"location":"tools/openprotocol/#alivexmtt","text":"","title":"ALIVEXMTT"},{"location":"tools/openprotocol/#showalive","text":"","title":"SHOWALIVE"},{"location":"tools/openprotocol/#rsptimeout","text":"","title":"RSPTIMEOUT"},{"location":"tools/openprotocol/#barcode_mid0051_rev","text":"","title":"BARCODE_MID0051_REV"},{"location":"tools/openprotocol/#check_ext_cond","text":"","title":"CHECK_EXT_COND"},{"location":"tools/openprotocol/#appl_start","text":"","title":"APPL_START"},{"location":"tools/openprotocol/#curve_request","text":"","title":"CURVE_REQUEST"},{"location":"tools/openprotocol/#check_time_enabled","text":"","title":"CHECK_TIME_ENABLED"},{"location":"tools/openprotocol/#ignore_id","text":"","title":"IGNORE_ID"},{"location":"v3/getting-started/","text":"","title":"Getting Started"},{"location":"v3/lua/webbrowser/","text":"Browser Overview The OGS runtime uses up to 4 web browser (Microsoft WebView2) instances. The instances are: - StartView : Browser on the start screen - ProcessView : Browser on the process screen (only visible, if the url -parameter in the job/task is set) - SidePanel : Browser on the slide-in side panel (requires enabling the sidepanel in station.ini ) - InstructionView : Browser in the instruction view popup (is triggered from LUA, so only visible with custom LUA code) The OGS infrastructure provides functions to bidirectionally exchange data between the JavaScript code running inside the web browser and the LUA code running inside OGS. There is a LUA function to execute JavaScript code in the webbrowser and a JavaScript bride, which calls a LUA function (if registered accordingly). To implement this functionality, OGS provides the following: - For the JavaScript side: a bridge implementation accessibal through the hostObjects interface of the Chromium browser ( window.chrome.webview.hostObjects.sync.OGS ) - For the LUA side: a global Browser table with functions to manipulate the browser instances JavaScript hostObjects bridge OGS registers a hostObject in the WebView2 browser for the JavaScript side. The registered object is named OGS and implements a single string property ObjectMessage . To send a string to OGS from JavaScript, simply assign a value to the window.chrome.webview.hostObjects.sync.OGS.ObjectMessage property. Sample code // send a command string to OGS function sendOgsCommand(cmd) { if (!window.chrome || !window.chrome.webview || !window.chrome.webview.hostObjects || !window.chrome.webview.hostObjects.sync) { // WebView2 is not yet fully initialized return; } let ogs = window.chrome.webview.hostObjects.sync.OGS; if (ogs) { ogs.ObjectMessage = cmd; } } Global Browser table OGS exposes the browser instances through the global Browser object. The Browser object implements the following functions: Navigate : Load a new URL in the web browser ExecJS_nonblocking : Run javascript inside the web browser (asynchronously, not returning a value) RegMsgHandler : Register a LUA callback function to be called when the JavaScript side writes to the object message endpoint. Navigate The Browser.Navigate function starts loading a new URL into the given browser instance. Browser.Navigate(instance, url) Parameters instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') url [string]: Url to navigate the browser instance to (in the standard URL format, e.g. file://filename or https://server/page) Sample code -- Navigate the StartView browser to https://www.my-url.com/mypage Browser.Navigate('StartView', 'https://www.my-url.com/mypage') RegMsgHandler The Browser.RegMsgHandler function registers or unregisters a LUA function to be called whenever the JavaScript running in the browser writes a message to the hostObject bridge OGS.ObjectMessage property. -- Register the callback function fn, err = Browser.RegMsgHandler(instance, callbackfn) Parameters instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') callbackfn [function]: LUA function to be called when the JavaScript code writes a string to the OGS.ObjectMessage hostObject. If callbackfn is nil , then the current registration is removed. The callback function has the following signature: callbackfn(instance, objectMessage) Where instance [string] is the web browsers instance name (e.g. 'StartView') and objectMessage [string] the text which was written to the OGS.ObjectMessage property of the hostObject bridge from the JavaScript side. Return values If the function was executed successfully, the callbackfn is returned as the first return value. Else nil is returned and the second return value has an error message string (wrong parameters or unknown instance). Sample code local function callbackfn(instance, objectMessage) -- do whatever you want to do here if the javascript -- code writes the OGS.ObjectMessage property end -- Register a LUA function to be called from the JavaScript side Browser.RegMsgHandler('StartView', callbackfn) ExecJS_nonblocking The Browser.ExecJS_nonblocking executes JavaScript code in the web browser instance. Browser.ExecJS_nonblocking(instance, jstext) Parameters instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') jstext [string]: JavaScript string to execute in the browser. Note that this must be valid JavaScript code. NOTES : When passing strings through the function, make sure to propery escape them! Best practice is to write a JavaScript function in the web page and only call it through this function. You can serialize LUA objects to a JSON string and pass this through the function. The JavaScript side can then easily deserialize it. Sample code -- Build a JavaScript command, call the function \"my_function\" with -- some JSON text local param = '{ \"cmd\": \"showmessage\" }' local command = \"my_function(\"..param..\");\" -- Call the JavaScript function in the StartView browser Browser.ExecJS_nonblocking('StartView', command)","title":"Web browsers"},{"location":"v3/lua/webbrowser/#browser","text":"","title":"Browser"},{"location":"v3/lua/webbrowser/#overview","text":"The OGS runtime uses up to 4 web browser (Microsoft WebView2) instances. The instances are: - StartView : Browser on the start screen - ProcessView : Browser on the process screen (only visible, if the url -parameter in the job/task is set) - SidePanel : Browser on the slide-in side panel (requires enabling the sidepanel in station.ini ) - InstructionView : Browser in the instruction view popup (is triggered from LUA, so only visible with custom LUA code) The OGS infrastructure provides functions to bidirectionally exchange data between the JavaScript code running inside the web browser and the LUA code running inside OGS. There is a LUA function to execute JavaScript code in the webbrowser and a JavaScript bride, which calls a LUA function (if registered accordingly). To implement this functionality, OGS provides the following: - For the JavaScript side: a bridge implementation accessibal through the hostObjects interface of the Chromium browser ( window.chrome.webview.hostObjects.sync.OGS ) - For the LUA side: a global Browser table with functions to manipulate the browser instances","title":"Overview"},{"location":"v3/lua/webbrowser/#javascript-hostobjects-bridge","text":"OGS registers a hostObject in the WebView2 browser for the JavaScript side. The registered object is named OGS and implements a single string property ObjectMessage . To send a string to OGS from JavaScript, simply assign a value to the window.chrome.webview.hostObjects.sync.OGS.ObjectMessage property.","title":"JavaScript hostObjects bridge"},{"location":"v3/lua/webbrowser/#sample-code","text":"// send a command string to OGS function sendOgsCommand(cmd) { if (!window.chrome || !window.chrome.webview || !window.chrome.webview.hostObjects || !window.chrome.webview.hostObjects.sync) { // WebView2 is not yet fully initialized return; } let ogs = window.chrome.webview.hostObjects.sync.OGS; if (ogs) { ogs.ObjectMessage = cmd; } }","title":"Sample code"},{"location":"v3/lua/webbrowser/#global-browser-table","text":"OGS exposes the browser instances through the global Browser object. The Browser object implements the following functions: Navigate : Load a new URL in the web browser ExecJS_nonblocking : Run javascript inside the web browser (asynchronously, not returning a value) RegMsgHandler : Register a LUA callback function to be called when the JavaScript side writes to the object message endpoint.","title":"Global Browser table"},{"location":"v3/lua/webbrowser/#navigate","text":"The Browser.Navigate function starts loading a new URL into the given browser instance. Browser.Navigate(instance, url)","title":"Navigate"},{"location":"v3/lua/webbrowser/#parameters","text":"instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') url [string]: Url to navigate the browser instance to (in the standard URL format, e.g. file://filename or https://server/page)","title":"Parameters"},{"location":"v3/lua/webbrowser/#sample-code_1","text":"-- Navigate the StartView browser to https://www.my-url.com/mypage Browser.Navigate('StartView', 'https://www.my-url.com/mypage')","title":"Sample code"},{"location":"v3/lua/webbrowser/#regmsghandler","text":"The Browser.RegMsgHandler function registers or unregisters a LUA function to be called whenever the JavaScript running in the browser writes a message to the hostObject bridge OGS.ObjectMessage property. -- Register the callback function fn, err = Browser.RegMsgHandler(instance, callbackfn)","title":"RegMsgHandler"},{"location":"v3/lua/webbrowser/#parameters_1","text":"instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') callbackfn [function]: LUA function to be called when the JavaScript code writes a string to the OGS.ObjectMessage hostObject. If callbackfn is nil , then the current registration is removed. The callback function has the following signature: callbackfn(instance, objectMessage) Where instance [string] is the web browsers instance name (e.g. 'StartView') and objectMessage [string] the text which was written to the OGS.ObjectMessage property of the hostObject bridge from the JavaScript side.","title":"Parameters"},{"location":"v3/lua/webbrowser/#return-values","text":"If the function was executed successfully, the callbackfn is returned as the first return value. Else nil is returned and the second return value has an error message string (wrong parameters or unknown instance).","title":"Return values"},{"location":"v3/lua/webbrowser/#sample-code_2","text":"local function callbackfn(instance, objectMessage) -- do whatever you want to do here if the javascript -- code writes the OGS.ObjectMessage property end -- Register a LUA function to be called from the JavaScript side Browser.RegMsgHandler('StartView', callbackfn)","title":"Sample code"},{"location":"v3/lua/webbrowser/#execjs_nonblocking","text":"The Browser.ExecJS_nonblocking executes JavaScript code in the web browser instance. Browser.ExecJS_nonblocking(instance, jstext)","title":"ExecJS_nonblocking"},{"location":"v3/lua/webbrowser/#parameters_2","text":"instance [string]: Web browser instance name (one of 'StartView', 'ProcessView', 'SidePanel', 'InstructionView') jstext [string]: JavaScript string to execute in the browser. Note that this must be valid JavaScript code. NOTES : When passing strings through the function, make sure to propery escape them! Best practice is to write a JavaScript function in the web page and only call it through this function. You can serialize LUA objects to a JSON string and pass this through the function. The JavaScript side can then easily deserialize it.","title":"Parameters"},{"location":"v3/lua/webbrowser/#sample-code_3","text":"-- Build a JavaScript command, call the function \"my_function\" with -- some JSON text local param = '{ \"cmd\": \"showmessage\" }' local command = \"my_function(\"..param..\");\" -- Call the JavaScript function in the StartView browser Browser.ExecJS_nonblocking('StartView', command)","title":"Sample code"},{"location":"v3/lua/webserver/","text":"Webserver Overview The OGS runtime uses the Microsoft Windows builtin http.sys web server to server static pages and dynamic pages. The dynamic pages are implemented through LUA scripting and makes it possible to flexibly implement web services like OpenAPI / REST services or others. A typical use case is to provide a REST interface for third-party systems to connect them to OGS, another is to implement backend logic for a single page application web page frontend running inside OGS (see also OGS Webbrowser LUA interface ). The web server LUA api works by registering LUA callback functions for specific URL prefixes, which are then called by the web server, whenever the given URL is requested from a web client. Prerequisites To use the LUA web server API, the web server must be enabled through station.ini (in the [WebServer] section) and the Microsoft http.sys web server must be configured accordingly (a URL reservation must be activated through the netsh http add urlacl ... command). By default the, installer registers a web endpoint at http://localhost:59990, so the endpoint is only accessible from the local machine and only for a locally logged on user. To access the web server from the outside, make sure to change the listen address in the station.ini file, the URL reservation through netsh http ... and check the firewall settings. Global Webserver table OGS exposes the web server through the global Webserver object. The Webserver object implements the following functions: RegUrl : Register a LUA callback function to be called when a specific URL prefix is requested from the web server. RegUrl The Webserver.RegUrl function registers or unregisters a LUA function to be called whenever the web server receives a request to the given URL prefix. fn, err = Webserver.RegUrl(prefix, callbackfn) Parameters prefix [string]: Path prefix to match against when checking the request URL. Note that this only checks for the path part of the URL (e.g. '/home'). callbackfn [function]: LUA function to be called when a web request matches the prefix. The callback function has the following signature: table = callbackfn(reqpath, reqparams, verb, body) Where reqpath [string] is the full request path, (e.g. '/api/items'), reqparams [string] the request parameters (e.g. '?max=10&class=5'), verb [integer] the request type (GET, PUT, POST, DELETE) and body [string] the body (binaty) string value (only for POST and PUT). The callback function should return a response table with the required parameters to build the http response (optional body). [Datails tbd.] Return values If the function was executed successfully, the callbackfn is returned as the first return value. Else nil is returned and the second return value has an error message string (wrong parameters or unknown instance). Sample code local function handlerfn(reqpath, reqparams, verb, body) -- process the request, return the response object (or nil -- if this request is not handled) return nil end -- Register a LUA function to be called whenever a web request to /api/lua -- is made Browser.RegMsgHandler('/api/lua', handlerfn)","title":"Webserver (and REST API)"},{"location":"v3/lua/webserver/#webserver","text":"","title":"Webserver"},{"location":"v3/lua/webserver/#overview","text":"The OGS runtime uses the Microsoft Windows builtin http.sys web server to server static pages and dynamic pages. The dynamic pages are implemented through LUA scripting and makes it possible to flexibly implement web services like OpenAPI / REST services or others. A typical use case is to provide a REST interface for third-party systems to connect them to OGS, another is to implement backend logic for a single page application web page frontend running inside OGS (see also OGS Webbrowser LUA interface ). The web server LUA api works by registering LUA callback functions for specific URL prefixes, which are then called by the web server, whenever the given URL is requested from a web client.","title":"Overview"},{"location":"v3/lua/webserver/#prerequisites","text":"To use the LUA web server API, the web server must be enabled through station.ini (in the [WebServer] section) and the Microsoft http.sys web server must be configured accordingly (a URL reservation must be activated through the netsh http add urlacl ... command). By default the, installer registers a web endpoint at http://localhost:59990, so the endpoint is only accessible from the local machine and only for a locally logged on user. To access the web server from the outside, make sure to change the listen address in the station.ini file, the URL reservation through netsh http ... and check the firewall settings.","title":"Prerequisites"},{"location":"v3/lua/webserver/#global-webserver-table","text":"OGS exposes the web server through the global Webserver object. The Webserver object implements the following functions: RegUrl : Register a LUA callback function to be called when a specific URL prefix is requested from the web server.","title":"Global Webserver table"},{"location":"v3/lua/webserver/#regurl","text":"The Webserver.RegUrl function registers or unregisters a LUA function to be called whenever the web server receives a request to the given URL prefix. fn, err = Webserver.RegUrl(prefix, callbackfn)","title":"RegUrl"},{"location":"v3/lua/webserver/#parameters","text":"prefix [string]: Path prefix to match against when checking the request URL. Note that this only checks for the path part of the URL (e.g. '/home'). callbackfn [function]: LUA function to be called when a web request matches the prefix. The callback function has the following signature: table = callbackfn(reqpath, reqparams, verb, body) Where reqpath [string] is the full request path, (e.g. '/api/items'), reqparams [string] the request parameters (e.g. '?max=10&class=5'), verb [integer] the request type (GET, PUT, POST, DELETE) and body [string] the body (binaty) string value (only for POST and PUT). The callback function should return a response table with the required parameters to build the http response (optional body). [Datails tbd.]","title":"Parameters"},{"location":"v3/lua/webserver/#return-values","text":"If the function was executed successfully, the callbackfn is returned as the first return value. Else nil is returned and the second return value has an error message string (wrong parameters or unknown instance).","title":"Return values"},{"location":"v3/lua/webserver/#sample-code","text":"local function handlerfn(reqpath, reqparams, verb, body) -- process the request, return the response object (or nil -- if this request is not handled) return nil end -- Register a LUA function to be called whenever a web request to /api/lua -- is made Browser.RegMsgHandler('/api/lua', handlerfn)","title":"Sample code"}]}